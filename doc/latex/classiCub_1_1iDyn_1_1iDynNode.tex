\hypertarget{classiCub_1_1iDyn_1_1iDynNode}{}\doxysection{i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node Class Reference}
\label{classiCub_1_1iDyn_1_1iDynNode}\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}


A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between limbs.  




{\ttfamily \#include $<$i\+Dyn\+Body.\+h$>$}



Inheritance diagram for i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classiCub_1_1iDyn_1_1iDynNode__inherit__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a9a53a62a5df3d14d368e99efcaa09551}{i\+Dyn\+Node}} (const \mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362}{New\+Eul\+Mode}} \+\_\+mode=\mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3}{DYNAMIC}})
\begin{DoxyCompactList}\small\item\em Default constructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a0ead90a8cf09284157951a00025c6471}{i\+Dyn\+Node}} (const std\+::string \&\+\_\+info, const \mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362}{New\+Eul\+Mode}} \+\_\+mode=\mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3}{DYNAMIC}}, unsigned int verb=\mbox{\hyperlink{namespaceiCub_1_1skinDynLib_a790824a527802db93c40eca73839b72da16220311c35a0345c00855ea2032c695}{i\+Cub\+::skin\+Dyn\+Lib\+::\+VERBOSE}})
\begin{DoxyCompactList}\small\item\em Constructor with parameters. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_af1d930993d89391e724637e4cd4c123b}{add\+Limb}} (\mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynLimb}{i\+Dyn\+::i\+Dyn\+Limb}} $\ast$limb, const yarp\+::sig\+::\+Matrix \&\mbox{\hyperlink{compute__ekf__sym_8m_afaafc315b95987fc2b071bcd8f698b81}{H}}, const \mbox{\hyperlink{namespaceiCub_1_1iDyn_a2242db13fd8695c6b4e5c086809f45f1}{Flow\+Type}} kin\+Flow=\mbox{\hyperlink{namespaceiCub_1_1iDyn_a2242db13fd8695c6b4e5c086809f45f1a2ade845ecc299911bc2906e1e2539064}{RBT\+\_\+\+NODE\+\_\+\+OUT}}, const \mbox{\hyperlink{namespaceiCub_1_1iDyn_a2242db13fd8695c6b4e5c086809f45f1}{Flow\+Type}} wre\+Flow=\mbox{\hyperlink{namespaceiCub_1_1iDyn_a2242db13fd8695c6b4e5c086809f45f1a733307f2252a4e82441f412c04653a29}{RBT\+\_\+\+NODE\+\_\+\+IN}}, bool has\+Sensor=false)
\begin{DoxyCompactList}\small\item\em Add one limb to the node, defining its \mbox{\hyperlink{classiCub_1_1iDyn_1_1RigidBodyTransformation}{Rigid\+Body\+Transformation}}. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Matrix \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a5ea75d75c4a4af88cb908b58cc544fb0}{get\+RBT}} (unsigned int i\+Limb) const
\begin{DoxyCompactList}\small\item\em Return the RBT matrix of a certain limb attached to the node. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a80b3da23a78324dff920a4d90e9050bb}{solve\+Kinematics}} (const yarp\+::sig\+::\+Vector \&w0, const yarp\+::sig\+::\+Vector \&dw0, const yarp\+::sig\+::\+Vector \&ddp0)
\begin{DoxyCompactList}\small\item\em Main function to manage the exchange of kinematic information among the limbs attached to the node. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_aa55a020dd4b6cd51c3c586099a38c059}{solve\+Kinematics}} ()
\begin{DoxyCompactList}\small\item\em Main function to manage the exchange of kinematic information among the limbs attached to the node. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_ac62354060f29d440a9e9c36991bc868a}{set\+Kinematic\+Measure}} (const yarp\+::sig\+::\+Vector \&w0, const yarp\+::sig\+::\+Vector \&dw0, const yarp\+::sig\+::\+Vector \&ddp0)
\begin{DoxyCompactList}\small\item\em Set the kinematic measurement (w,dw,ddp) on the limb where the kinematic flow is of type RBT\+\_\+\+NODE\+\_\+\+IN. \end{DoxyCompactList}\item 
virtual bool \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_ad166af36d544d12a2aa6c3780fb06686}{solve\+Wrench}} ()
\begin{DoxyCompactList}\small\item\em Main function to manage the exchange of wrench information among the limbs attached to the node. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_af1cebfe81b63f533efd2f8d89300f0a7}{solve\+Wrench}} (const yarp\+::sig\+::\+Matrix \&FM)
\begin{DoxyCompactList}\small\item\em This is to manage the exchange of wrench information among the limbs attached to the node. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_aa277ea9054106efe80d77e4e9c120978}{solve\+Wrench}} (const yarp\+::sig\+::\+Matrix \&\mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_afbae85fc951a816738e887545dec6d1b}{F}}, const yarp\+::sig\+::\+Matrix \&M)
\begin{DoxyCompactList}\small\item\em This is to manage the exchange of wrench information among the limbs attached to the node. \end{DoxyCompactList}\item 
virtual bool \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a7baf9422767d3f38b7d63ce72c246565}{set\+Wrench\+Measure}} (const yarp\+::sig\+::\+Matrix \&\mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_afbae85fc951a816738e887545dec6d1b}{F}}, const yarp\+::sig\+::\+Matrix \&M)
\begin{DoxyCompactList}\small\item\em Set the wrench measure on the limbs with input wrench. \end{DoxyCompactList}\item 
virtual bool \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a3c3bf2f7eaa01c9c1bea5444e52f7ee8}{set\+Wrench\+Measure}} (const yarp\+::sig\+::\+Matrix \&FM)
\begin{DoxyCompactList}\small\item\em Set the wrench measure on the limbs with input wrench. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a49993bd267e6b663221d70ed0a3b3f37}{get\+Force}} () const
\begin{DoxyCompactList}\small\item\em Return the node force. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a43d1306faec97f30675d668b620c6409}{get\+Moment}} () const
\begin{DoxyCompactList}\small\item\em Return the node moment. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a90aaa82fdf13d57f059a9e2f12af4380}{get\+Ang\+Vel}} () const
\begin{DoxyCompactList}\small\item\em Return the node angular velocity. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a3f004d511bde994e2a5ab5108f59cf5d}{get\+Ang\+Acc}} () const
\begin{DoxyCompactList}\small\item\em Return the node angular acceleration. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_abb96b671aed849b4b815a9552e2c059f}{get\+Lin\+Acc}} () const
\begin{DoxyCompactList}\small\item\em Return the node linear acceleration. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Matrix \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_ac73ef1a6dbf022982665ec558bd84450}{compute\+Jacobian}} (unsigned int i\+Chain)
\begin{DoxyCompactList}\small\item\em Compute the Jacobian of the limb with index i\+Chain in the node, in its default direction (as it would be done by \mbox{\hyperlink{namespaceiCub_1_1iKin}{i\+Kin}}). \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Matrix \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_ab3df54f3b7732d811b7d455254f54943}{compute\+Jacobian}} (unsigned int i\+Chain, unsigned int i\+Link)
\begin{DoxyCompactList}\small\item\em Compute the Jacobian of the i-\/th link of the limb with index i\+Chain in the node, in its default direction (as it would be done by \mbox{\hyperlink{namespaceiCub_1_1iKin}{i\+Kin}}). \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Matrix \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a5010cc99800cced452459d674a21e665}{compute\+Jacobian}} (unsigned int i\+ChainA, \mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}} dirA, unsigned int i\+ChainB, \mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}} dirB)
\begin{DoxyCompactList}\small\item\em Compute the Jacobian between two links in two different chains. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Matrix \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a48fd9aebc74f6bc4b9a57a593c36dfc9}{compute\+Jacobian}} (unsigned int i\+ChainA, \mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}} dirA, unsigned int i\+ChainB, unsigned int i\+LinkB, \mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}} dirB)
\begin{DoxyCompactList}\small\item\em Compute the Jacobian between two links in two different chains. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a7eb7948ffb0c9eafb1d9cd9741cc38ca}{compute\+Pose}} (unsigned int i\+ChainA, \mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}} dirA, unsigned int i\+ChainB, \mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}} dirB, const bool axis\+Rep)
\begin{DoxyCompactList}\small\item\em Compute the Pose of the end-\/effector, given a \char`\"{}virtual\char`\"{} chain connecting two limbs. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_aded1c0769eebf83dbfbbea34d078f99e}{compute\+Pose}} (unsigned int i\+ChainA, \mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}} dirA, unsigned int i\+ChainB, unsigned int i\+LinkB, \mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}} dirB, const bool axis\+Rep)
\begin{DoxyCompactList}\small\item\em Compute the Pose of the end-\/effector, given a \char`\"{}virtual\char`\"{} chain connecting two limbs. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Matrix \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_aa106c9340f7e2ffd57305868ac5c87a2}{TESTING\+\_\+compute\+COMJacobian}} (unsigned int i\+Chain, unsigned int i\+Link)
\begin{DoxyCompactList}\small\item\em Compute the Jacobian of the COM of the i-\/th link of the limb with index i\+Chain in the node. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Matrix \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a93feed610e2fbfc9c1f254668a3ee6f9}{TESTING\+\_\+compute\+COMJacobian}} (unsigned int i\+ChainA, \mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}} dirA, unsigned int i\+ChainB, unsigned int i\+LinkB, \mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}} dirB)
\begin{DoxyCompactList}\small\item\em Compute the Jacobian of the COM of link i\+LinkB, in chainB, when two different chains (A and B) are connected. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_aea991e45c7d4b8bda29189071dffc5d5}{zero}} ()
\begin{DoxyCompactList}\small\item\em Reset all data to zero. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a693d676c499a4356d1696a24692d915c}{compute\+\_\+\+Pn\+\_\+\+HAN}} (unsigned int i\+ChainA, \mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}} dirA, unsigned int i\+ChainB, \mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}} dirB, yarp\+::sig\+::\+Matrix \&Pn, yarp\+::sig\+::\+Matrix \&H\+\_\+\+A\+\_\+\+Node)
\begin{DoxyCompactList}\small\item\em Compute Pn and H\+\_\+\+A\+\_\+\+Node matrices given two chains. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_ace1daa891c049fadbede769ad26a6cfa}{compute\+\_\+\+Pn\+\_\+\+HAN}} (unsigned int i\+ChainA, \mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}} dirA, unsigned int i\+ChainB, unsigned int i\+LinkB, \mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}} dirB, yarp\+::sig\+::\+Matrix \&Pn, yarp\+::sig\+::\+Matrix \&H\+\_\+\+A\+\_\+\+Node)
\begin{DoxyCompactList}\small\item\em Compute Pn and H\+\_\+\+A\+\_\+\+Node matrices given two chains. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_adc620c5393e599eed31dba2335b34192}{compute\+\_\+\+Pn\+\_\+\+HAN\+\_\+\+COM}} (unsigned int i\+ChainA, \mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}} dirA, unsigned int i\+ChainB, unsigned int i\+LinkB, \mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}} dirB, yarp\+::sig\+::\+Matrix \&Pn, yarp\+::sig\+::\+Matrix \&H\+\_\+\+A\+\_\+\+Node)
\begin{DoxyCompactList}\small\item\em Compute Pn and H\+\_\+\+A\+\_\+\+Node matrices given two chains. \end{DoxyCompactList}\item 
unsigned int \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a6609ff72c5f8fdbb48d232a6a4d84d65}{how\+Many\+Wrench\+Inputs}} (bool after\+Attach=false) const
\begin{DoxyCompactList}\small\item\em Return the number of limbs with wrench input, i.\+e. \end{DoxyCompactList}\item 
unsigned int \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a3feea80c9d503b766d37afe108be6ce2}{how\+Many\+Kinematic\+Inputs}} (bool after\+Attach=false) const
\begin{DoxyCompactList}\small\item\em Return the number of limbs with kinematic input, i.\+e. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::deque$<$ \mbox{\hyperlink{classiCub_1_1iDyn_1_1RigidBodyTransformation}{Rigid\+Body\+Transformation}} $>$ \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_aa2348a39cc0576e4de7624580a6997b9}{rbt\+List}}
\begin{DoxyCompactList}\small\item\em the list of RBT \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362}{New\+Eul\+Mode}} \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a6a4212761245758347118b0b685b83bf}{mode}}
\begin{DoxyCompactList}\small\item\em STATIC/\+DYNAMIC/\+DYNAMIC\+\_\+\+W\+\_\+\+ROTOR/\+DYNAMIC\+\_\+\+CORIOLIS\+\_\+\+GRAVITY. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a9c71d184a9385364ca17ac8acb134f99}{info}}
\begin{DoxyCompactList}\small\item\em info or useful notes \end{DoxyCompactList}\item 
unsigned int \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a5fca92c14ebe1efb92463eb77ed67352}{verbose}}
\begin{DoxyCompactList}\small\item\em verbosity flag \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a74a74e80b0abb7063546f8b261bf359f}{w}}
\begin{DoxyCompactList}\small\item\em angular velocity \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_ad03a7e6af6ef82ff22fe36456329d2c8}{dw}}
\begin{DoxyCompactList}\small\item\em angular acceleration \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a0c97b6d7b00ae9252f0c8b336a60e30c}{ddp}}
\begin{DoxyCompactList}\small\item\em linear acceleration \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_afbae85fc951a816738e887545dec6d1b}{F}}
\begin{DoxyCompactList}\small\item\em force \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a80d77ab92e63190024ee4b8c8e116637}{Mu}}
\begin{DoxyCompactList}\small\item\em moment \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_af1ec3966a72191b31f266809403bfd06}{COM}}
\begin{DoxyCompactList}\small\item\em COM position of the node. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_ad5db3235dc804286712724c035345412}{mass}}
\begin{DoxyCompactList}\small\item\em total mass of the node \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between limbs. 

A virtual node, connecting multiple limbs, is set. The limbs can exchange kinematics and wrench information with the node through a Rigid\+Body\+Transfromation. The node only has kinematic (w,dw,ddp) and wrench (F,Mu) information\+: no mass, length, inertia, COM, or else. Each limb is connected to the node by a roto-\/translation matrix, which must be set when a limb is attached to the node\+: a Rigid\+Body\+Transfromation object is then created, which allows the proper computation of wrench and kinematic variables. When multiple limbs are attached to a node, the kinematic variables are set by a single limb, having kinematic flow = RBT\+\_\+\+NODE\+\_\+\+IN, while the wrench variables are found as the sum of the wrench contribution of all the links (inbound and outbound wrenches must balance in the node). 

Definition at line 531 of file i\+Dyn\+Body.\+h.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a9a53a62a5df3d14d368e99efcaa09551}\label{classiCub_1_1iDyn_1_1iDynNode_a9a53a62a5df3d14d368e99efcaa09551}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!iDynNode@{iDynNode}}
\index{iDynNode@{iDynNode}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{iDynNode()}{iDynNode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily i\+Dyn\+Node\+::i\+Dyn\+Node (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362}{New\+Eul\+Mode}}}]{\+\_\+mode = {\ttfamily \mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3}{DYNAMIC}}} }\end{DoxyParamCaption})}



Default constructor. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+mode} & the modality for dynamic computation \\
\hline
\end{DoxyParams}


Definition at line 416 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a0ead90a8cf09284157951a00025c6471}\label{classiCub_1_1iDyn_1_1iDynNode_a0ead90a8cf09284157951a00025c6471}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!iDynNode@{iDynNode}}
\index{iDynNode@{iDynNode}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{iDynNode()}{iDynNode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily i\+Dyn\+Node\+::i\+Dyn\+Node (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{\+\_\+info,  }\item[{const \mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362}{New\+Eul\+Mode}}}]{\+\_\+mode = {\ttfamily \mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3}{DYNAMIC}}},  }\item[{unsigned int}]{verb = {\ttfamily \mbox{\hyperlink{namespaceiCub_1_1skinDynLib_a790824a527802db93c40eca73839b72da16220311c35a0345c00855ea2032c695}{i\+Cub\+::skin\+Dyn\+Lib\+::\+VERBOSE}}} }\end{DoxyParamCaption})}



Constructor with parameters. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+info} & some information on the node, i.\+e. its description \\
\hline
{\em \+\_\+mode} & the modality for dynamic computation \\
\hline
{\em verb} & verbosity level \\
\hline
\end{DoxyParams}


Definition at line 424 of file i\+Dyn\+Body.\+cpp.



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_af1d930993d89391e724637e4cd4c123b}\label{classiCub_1_1iDyn_1_1iDynNode_af1d930993d89391e724637e4cd4c123b}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!addLimb@{addLimb}}
\index{addLimb@{addLimb}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{addLimb()}{addLimb()}}
{\footnotesize\ttfamily void i\+Dyn\+Node\+::add\+Limb (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynLimb}{i\+Dyn\+::i\+Dyn\+Limb}} $\ast$}]{limb,  }\item[{const yarp\+::sig\+::\+Matrix \&}]{H,  }\item[{const \mbox{\hyperlink{namespaceiCub_1_1iDyn_a2242db13fd8695c6b4e5c086809f45f1}{Flow\+Type}}}]{kin\+Flow = {\ttfamily \mbox{\hyperlink{namespaceiCub_1_1iDyn_a2242db13fd8695c6b4e5c086809f45f1a2ade845ecc299911bc2906e1e2539064}{RBT\+\_\+\+NODE\+\_\+\+OUT}}},  }\item[{const \mbox{\hyperlink{namespaceiCub_1_1iDyn_a2242db13fd8695c6b4e5c086809f45f1}{Flow\+Type}}}]{wre\+Flow = {\ttfamily \mbox{\hyperlink{namespaceiCub_1_1iDyn_a2242db13fd8695c6b4e5c086809f45f1a733307f2252a4e82441f412c04653a29}{RBT\+\_\+\+NODE\+\_\+\+IN}}},  }\item[{bool}]{has\+Sensor = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Add one limb to the node, defining its \mbox{\hyperlink{classiCub_1_1iDyn_1_1RigidBodyTransformation}{Rigid\+Body\+Transformation}}. 

A new \mbox{\hyperlink{classiCub_1_1iDyn_1_1RigidBodyTransformation}{Rigid\+Body\+Transformation}} is added to the RBT list. 
\begin{DoxyParams}{Parameters}
{\em limb} & pointer to generic limb \\
\hline
{\em H} & a (4x4) roto-\/translational matrix defining the transformation between node and limb base/end \\
\hline
{\em kin\+Flow} & the type of information flow of kinematics variables \\
\hline
{\em wre\+Flow} & the type of information flow of wrench variables \\
\hline
{\em has\+Sensor} & flag for having or not a FT sensor \\
\hline
\end{DoxyParams}


Definition at line 442 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a693d676c499a4356d1696a24692d915c}\label{classiCub_1_1iDyn_1_1iDynNode_a693d676c499a4356d1696a24692d915c}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!compute\_Pn\_HAN@{compute\_Pn\_HAN}}
\index{compute\_Pn\_HAN@{compute\_Pn\_HAN}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{compute\_Pn\_HAN()}{compute\_Pn\_HAN()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::compute\+\_\+\+Pn\+\_\+\+HAN (\begin{DoxyParamCaption}\item[{unsigned int}]{i\+ChainA,  }\item[{\mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}}}]{dirA,  }\item[{unsigned int}]{i\+ChainB,  }\item[{\mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}}}]{dirB,  }\item[{yarp\+::sig\+::\+Matrix \&}]{Pn,  }\item[{yarp\+::sig\+::\+Matrix \&}]{H\+\_\+\+A\+\_\+\+Node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Compute Pn and H\+\_\+\+A\+\_\+\+Node matrices given two chains. 

This function is private, and is used by \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_ac73ef1a6dbf022982665ec558bd84450}{compute\+Jacobian()}} and \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a7eb7948ffb0c9eafb1d9cd9741cc38ca}{compute\+Pose()}} to merely avoid code duplication. \mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_ace1daa891c049fadbede769ad26a6cfa}\label{classiCub_1_1iDyn_1_1iDynNode_ace1daa891c049fadbede769ad26a6cfa}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!compute\_Pn\_HAN@{compute\_Pn\_HAN}}
\index{compute\_Pn\_HAN@{compute\_Pn\_HAN}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{compute\_Pn\_HAN()}{compute\_Pn\_HAN()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::compute\+\_\+\+Pn\+\_\+\+HAN (\begin{DoxyParamCaption}\item[{unsigned int}]{i\+ChainA,  }\item[{\mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}}}]{dirA,  }\item[{unsigned int}]{i\+ChainB,  }\item[{unsigned int}]{i\+LinkB,  }\item[{\mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}}}]{dirB,  }\item[{yarp\+::sig\+::\+Matrix \&}]{Pn,  }\item[{yarp\+::sig\+::\+Matrix \&}]{H\+\_\+\+A\+\_\+\+Node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Compute Pn and H\+\_\+\+A\+\_\+\+Node matrices given two chains. 

This function is private, and is used by \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_ac73ef1a6dbf022982665ec558bd84450}{compute\+Jacobian()}} and \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynNode_a7eb7948ffb0c9eafb1d9cd9741cc38ca}{compute\+Pose()}} to merely avoid code duplication. \mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_adc620c5393e599eed31dba2335b34192}\label{classiCub_1_1iDyn_1_1iDynNode_adc620c5393e599eed31dba2335b34192}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!compute\_Pn\_HAN\_COM@{compute\_Pn\_HAN\_COM}}
\index{compute\_Pn\_HAN\_COM@{compute\_Pn\_HAN\_COM}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{compute\_Pn\_HAN\_COM()}{compute\_Pn\_HAN\_COM()}}
{\footnotesize\ttfamily void i\+Dyn\+Node\+::compute\+\_\+\+Pn\+\_\+\+HAN\+\_\+\+COM (\begin{DoxyParamCaption}\item[{unsigned int}]{i\+ChainA,  }\item[{\mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}}}]{dirA,  }\item[{unsigned int}]{i\+ChainB,  }\item[{unsigned int}]{i\+LinkB,  }\item[{\mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}}}]{dirB,  }\item[{yarp\+::sig\+::\+Matrix \&}]{Pn,  }\item[{yarp\+::sig\+::\+Matrix \&}]{H\+\_\+\+A\+\_\+\+Node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Compute Pn and H\+\_\+\+A\+\_\+\+Node matrices given two chains. 

This function is private, and is used by compute\+COMJacobian() and compute\+COMPose() to merely avoid code duplication. 

Definition at line 1281 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_ac73ef1a6dbf022982665ec558bd84450}\label{classiCub_1_1iDyn_1_1iDynNode_ac73ef1a6dbf022982665ec558bd84450}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!computeJacobian@{computeJacobian}}
\index{computeJacobian@{computeJacobian}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{computeJacobian()}{computeJacobian()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily Matrix i\+Dyn\+Node\+::compute\+Jacobian (\begin{DoxyParamCaption}\item[{unsigned int}]{i\+Chain }\end{DoxyParamCaption})}



Compute the Jacobian of the limb with index i\+Chain in the node, in its default direction (as it would be done by \mbox{\hyperlink{namespaceiCub_1_1iKin}{i\+Kin}}). 


\begin{DoxyParams}{Parameters}
{\em i\+Chain} & the index of the chain (limb) in the node \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Jacobian matrix 
\end{DoxyReturn}


Definition at line 834 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_ab3df54f3b7732d811b7d455254f54943}\label{classiCub_1_1iDyn_1_1iDynNode_ab3df54f3b7732d811b7d455254f54943}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!computeJacobian@{computeJacobian}}
\index{computeJacobian@{computeJacobian}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{computeJacobian()}{computeJacobian()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily Matrix i\+Dyn\+Node\+::compute\+Jacobian (\begin{DoxyParamCaption}\item[{unsigned int}]{i\+Chain,  }\item[{unsigned int}]{i\+Link }\end{DoxyParamCaption})}



Compute the Jacobian of the i-\/th link of the limb with index i\+Chain in the node, in its default direction (as it would be done by \mbox{\hyperlink{namespaceiCub_1_1iKin}{i\+Kin}}). 

If the link index is not correct, a null Jacobian is returned.

Important note\+: since we are specifying the link index in the chain, the Jacobian computation will deal with all the links, even blocked links. The Jacobian size is not 6x(the DOF until i\+Link\+B) but 6xi\+LinkB, where 0$<$i\+LinkB$<$N


\begin{DoxyParams}{Parameters}
{\em i\+Chain} & the index of the chain (limb) in the node \\
\hline
{\em i\+Link} & the index of the limnk in the limb \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Jacobian matrix 
\end{DoxyReturn}


Definition at line 847 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a5010cc99800cced452459d674a21e665}\label{classiCub_1_1iDyn_1_1iDynNode_a5010cc99800cced452459d674a21e665}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!computeJacobian@{computeJacobian}}
\index{computeJacobian@{computeJacobian}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{computeJacobian()}{computeJacobian()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily Matrix i\+Dyn\+Node\+::compute\+Jacobian (\begin{DoxyParamCaption}\item[{unsigned int}]{i\+ChainA,  }\item[{\mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}}}]{dirA,  }\item[{unsigned int}]{i\+ChainB,  }\item[{\mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}}}]{dirB }\end{DoxyParamCaption})}



Compute the Jacobian between two links in two different chains. 

The chains are specified by their index in the list (the progressive number of insertion). The first limb (limb A -\/ index=i\+ChainA) has the base link of the jacobian while the second limb (limb B -\/ index=i\+ChainB) has the final link of the jacobian. Whether the base/final of the Jacobian coincides with the base/end of the chains, depends on the flags dirA,dirB\+: if dirA=JAC\+\_\+\+DIR, then the beginning is at the base of chain, otherwise it is at the end-\/effector; if dirB=JAC\+\_\+\+DIR, the final link of the jacobian is on the end-\/effector of the chain, otherwise on its base. 
\begin{DoxyParams}{Parameters}
{\em i\+ChainA} & the index of the chain (the limb) in the node having the base frame \\
\hline
{\em dirA} & the \textquotesingle{}direction\textquotesingle{} of the chain wrt the jacobian computation \\
\hline
{\em i\+ChainB} & the index of the chain (the limb) in the node having the final frame \\
\hline
{\em dirB} & the \textquotesingle{}direction\textquotesingle{} of the chain wrt the jacobian computation \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Jacobian matrix 
\end{DoxyReturn}


Definition at line 862 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a48fd9aebc74f6bc4b9a57a593c36dfc9}\label{classiCub_1_1iDyn_1_1iDynNode_a48fd9aebc74f6bc4b9a57a593c36dfc9}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!computeJacobian@{computeJacobian}}
\index{computeJacobian@{computeJacobian}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{computeJacobian()}{computeJacobian()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily Matrix i\+Dyn\+Node\+::compute\+Jacobian (\begin{DoxyParamCaption}\item[{unsigned int}]{i\+ChainA,  }\item[{\mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}}}]{dirA,  }\item[{unsigned int}]{i\+ChainB,  }\item[{unsigned int}]{i\+LinkB,  }\item[{\mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}}}]{dirB }\end{DoxyParamCaption})}



Compute the Jacobian between two links in two different chains. 

The chains are specified by their index in the list (the progressive number of insertion). The first limb has the base of the jacobian (base or end-\/effector of the limb, depending on the Jacobian direction JacA) while the second limb (limb B -\/ index=i\+ChainB) has the final link of the jacobian (index=i\+LinkB).

Important note\+: since we are specifying the link index in chain B, the Jacobian computation on chain B will deal with all the links, even blocked links. The Jacobian size is not 6x(DOF\+\_\+A + the DOF until i\+LinkB) but 6x(DOF\+\_\+\+A+i\+LinkB), where 0$<$i\+LinkB$<$N


\begin{DoxyParams}{Parameters}
{\em i\+ChainA} & the index of the chain (the limb) in the node having the base ($<$0$>$) frame \\
\hline
{\em dirA} & the \textquotesingle{}direction\textquotesingle{} of the chain wrt the jacobian computation \\
\hline
{\em i\+ChainB} & the index of the chain (the limb) in the node having the final ($<$\+N$>$) frame \\
\hline
{\em i\+LinkB} & the index of the link, in the index\+ChainN chain, being the final ($<$\+N$>$) frame for the Jacobian computation \\
\hline
{\em dirB} & the \textquotesingle{}direction\textquotesingle{} of the chain wrt the jacobian computation \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Jacobian matrix 
\end{DoxyReturn}


Definition at line 927 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a7eb7948ffb0c9eafb1d9cd9741cc38ca}\label{classiCub_1_1iDyn_1_1iDynNode_a7eb7948ffb0c9eafb1d9cd9741cc38ca}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!computePose@{computePose}}
\index{computePose@{computePose}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{computePose()}{computePose()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily Vector i\+Dyn\+Node\+::compute\+Pose (\begin{DoxyParamCaption}\item[{unsigned int}]{i\+ChainA,  }\item[{\mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}}}]{dirA,  }\item[{unsigned int}]{i\+ChainB,  }\item[{\mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}}}]{dirB,  }\item[{const bool}]{axis\+Rep }\end{DoxyParamCaption})}



Compute the Pose of the end-\/effector, given a \char`\"{}virtual\char`\"{} chain connecting two limbs. 

The chains are specified by their index in the list (the progressive number of insertion). The first limb (limb A -\/ index=i\+ChainA) has the base link of the augmented chain while the second limb (limb B -\/ index=i\+ChainB) has the final link of the augmented chain . Whether the base/end of the augmented chain coincides with the base/end of the single chains, depends on the flags dirA,dirB\+: if dirA=JAC\+\_\+\+DIR, then the beginning is at the base of chain, otherwise it is at the end-\/effector; if dirB=JAC\+\_\+\+DIR, the final link of the augmented chain is on the end-\/effector of the chain, otherwise on its base. This method is useful to compute the end-\/effector pose (i.\+e. computing the arm pose, when the chain torso + arm is considered) in a multi-\/limb chain. 
\begin{DoxyParams}{Parameters}
{\em i\+ChainA} & the index of the chain (the limb) in the node having the base frame \\
\hline
{\em dirA} & the \textquotesingle{}direction\textquotesingle{} of visit of the chain \\
\hline
{\em i\+ChainB} & the index of the chain (the limb) in the node having the final frame \\
\hline
{\em dirB} & the \textquotesingle{}direction\textquotesingle{} of visit of the chain \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Jacobian matrix 
\end{DoxyReturn}


Definition at line 1062 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_aded1c0769eebf83dbfbbea34d078f99e}\label{classiCub_1_1iDyn_1_1iDynNode_aded1c0769eebf83dbfbbea34d078f99e}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!computePose@{computePose}}
\index{computePose@{computePose}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{computePose()}{computePose()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily Vector i\+Dyn\+Node\+::compute\+Pose (\begin{DoxyParamCaption}\item[{unsigned int}]{i\+ChainA,  }\item[{\mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}}}]{dirA,  }\item[{unsigned int}]{i\+ChainB,  }\item[{unsigned int}]{i\+LinkB,  }\item[{\mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}}}]{dirB,  }\item[{const bool}]{axis\+Rep }\end{DoxyParamCaption})}



Compute the Pose of the end-\/effector, given a \char`\"{}virtual\char`\"{} chain connecting two limbs. 

The chains are specified by their index in the list (the progressive number of insertion). The first limb (limb A -\/ index=i\+ChainA) has the base link of the augmented chain while the second limb (limb B -\/ index=i\+ChainB) has the final link of the augmented chain, ending in the link i\+LinkB. Whether the base/end of the augmented chain coincides with the base/end of the single chains, depends on the flags dirA,dirB\+: if dirA=JAC\+\_\+\+DIR, then the beginning is at the base of chain, otherwise it is at the end-\/effector; if dirB=JAC\+\_\+\+DIR, the final link of the augmented chain is on the end-\/effector of the chain, otherwise on its base. This method is useful to compute the end-\/effector pose (i.\+e. computing the elbow pose, when the chain torso + arm is considered) in a multi-\/limb chain. 
\begin{DoxyParams}{Parameters}
{\em i\+ChainA} & the index of the chain (the limb) in the node having the base frame \\
\hline
{\em dirA} & the \textquotesingle{}direction\textquotesingle{} of visit of the chain \\
\hline
{\em i\+ChainB} & the index of the chain (the limb) in the node having the final frame \\
\hline
{\em i\+LinkB} & the index of the link, in the index\+ChainN chain, being the final ($<$\+N$>$) frame for the Jacobian computation \\
\hline
{\em dirB} & the \textquotesingle{}direction\textquotesingle{} of visit of the chain \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Jacobian matrix 
\end{DoxyReturn}


Definition at line 1122 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a3f004d511bde994e2a5ab5108f59cf5d}\label{classiCub_1_1iDyn_1_1iDynNode_a3f004d511bde994e2a5ab5108f59cf5d}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!getAngAcc@{getAngAcc}}
\index{getAngAcc@{getAngAcc}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{getAngAcc()}{getAngAcc()}}
{\footnotesize\ttfamily Vector i\+Dyn\+Node\+::get\+Ang\+Acc (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Return the node angular acceleration. 

\begin{DoxyReturn}{Returns}
the node angular acceleration 
\end{DoxyReturn}


Definition at line 823 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a90aaa82fdf13d57f059a9e2f12af4380}\label{classiCub_1_1iDyn_1_1iDynNode_a90aaa82fdf13d57f059a9e2f12af4380}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!getAngVel@{getAngVel}}
\index{getAngVel@{getAngVel}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{getAngVel()}{getAngVel()}}
{\footnotesize\ttfamily Vector i\+Dyn\+Node\+::get\+Ang\+Vel (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Return the node angular velocity. 

\begin{DoxyReturn}{Returns}
the node angular velocity 
\end{DoxyReturn}


Definition at line 821 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a49993bd267e6b663221d70ed0a3b3f37}\label{classiCub_1_1iDyn_1_1iDynNode_a49993bd267e6b663221d70ed0a3b3f37}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!getForce@{getForce}}
\index{getForce@{getForce}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{getForce()}{getForce()}}
{\footnotesize\ttfamily Vector i\+Dyn\+Node\+::get\+Force (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Return the node force. 

\begin{DoxyReturn}{Returns}
the node force 
\end{DoxyReturn}


Definition at line 817 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_abb96b671aed849b4b815a9552e2c059f}\label{classiCub_1_1iDyn_1_1iDynNode_abb96b671aed849b4b815a9552e2c059f}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!getLinAcc@{getLinAcc}}
\index{getLinAcc@{getLinAcc}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{getLinAcc()}{getLinAcc()}}
{\footnotesize\ttfamily Vector i\+Dyn\+Node\+::get\+Lin\+Acc (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Return the node linear acceleration. 

\begin{DoxyReturn}{Returns}
the node linear acceleration 
\end{DoxyReturn}


Definition at line 825 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a43d1306faec97f30675d668b620c6409}\label{classiCub_1_1iDyn_1_1iDynNode_a43d1306faec97f30675d668b620c6409}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!getMoment@{getMoment}}
\index{getMoment@{getMoment}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{getMoment()}{getMoment()}}
{\footnotesize\ttfamily Vector i\+Dyn\+Node\+::get\+Moment (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Return the node moment. 

\begin{DoxyReturn}{Returns}
the node moment 
\end{DoxyReturn}


Definition at line 819 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a5ea75d75c4a4af88cb908b58cc544fb0}\label{classiCub_1_1iDyn_1_1iDynNode_a5ea75d75c4a4af88cb908b58cc544fb0}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!getRBT@{getRBT}}
\index{getRBT@{getRBT}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{getRBT()}{getRBT()}}
{\footnotesize\ttfamily Matrix i\+Dyn\+Node\+::get\+RBT (\begin{DoxyParamCaption}\item[{unsigned int}]{i\+Limb }\end{DoxyParamCaption}) const}



Return the RBT matrix of a certain limb attached to the node. 


\begin{DoxyParams}{Parameters}
{\em i\+Limb} & the index of the limb -\/ the index is the number of insertion of the limb in the node \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the RBT matrix of that limb, attached to the node 
\end{DoxyReturn}


Definition at line 449 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a3feea80c9d503b766d37afe108be6ce2}\label{classiCub_1_1iDyn_1_1iDynNode_a3feea80c9d503b766d37afe108be6ce2}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!howManyKinematicInputs@{howManyKinematicInputs}}
\index{howManyKinematicInputs@{howManyKinematicInputs}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{howManyKinematicInputs()}{howManyKinematicInputs()}}
{\footnotesize\ttfamily unsigned int i\+Dyn\+Node\+::how\+Many\+Kinematic\+Inputs (\begin{DoxyParamCaption}\item[{bool}]{after\+Attach = {\ttfamily false} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [protected]}}



Return the number of limbs with kinematic input, i.\+e. 

receiving kinematic information from external measurements. 
\begin{DoxyParams}{Parameters}
{\em after\+Attach} & =true only if the limb received kinematic parameters during an attach\+Torso() procedure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of limbs with kinematic input, if after\+Attach=false; if after\+Attach=true, the number is of limbs -\/ 1 
\end{DoxyReturn}


Definition at line 801 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a6609ff72c5f8fdbb48d232a6a4d84d65}\label{classiCub_1_1iDyn_1_1iDynNode_a6609ff72c5f8fdbb48d232a6a4d84d65}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!howManyWrenchInputs@{howManyWrenchInputs}}
\index{howManyWrenchInputs@{howManyWrenchInputs}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{howManyWrenchInputs()}{howManyWrenchInputs()}}
{\footnotesize\ttfamily unsigned int i\+Dyn\+Node\+::how\+Many\+Wrench\+Inputs (\begin{DoxyParamCaption}\item[{bool}]{after\+Attach = {\ttfamily false} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [protected]}}



Return the number of limbs with wrench input, i.\+e. 

receiving wrench information from external measurements. 
\begin{DoxyParams}{Parameters}
{\em after\+Attach} & =true only if the limb received wrench parameters during an attach\+Torso() procedure \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of limbs with wrench input, if after\+Attach=false; if after\+Attach=true, the number is of limbs -\/ 1 
\end{DoxyReturn}


Definition at line 785 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_ac62354060f29d440a9e9c36991bc868a}\label{classiCub_1_1iDyn_1_1iDynNode_ac62354060f29d440a9e9c36991bc868a}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!setKinematicMeasure@{setKinematicMeasure}}
\index{setKinematicMeasure@{setKinematicMeasure}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{setKinematicMeasure()}{setKinematicMeasure()}}
{\footnotesize\ttfamily bool i\+Dyn\+Node\+::set\+Kinematic\+Measure (\begin{DoxyParamCaption}\item[{const yarp\+::sig\+::\+Vector \&}]{w0,  }\item[{const yarp\+::sig\+::\+Vector \&}]{dw0,  }\item[{const yarp\+::sig\+::\+Vector \&}]{ddp0 }\end{DoxyParamCaption})}



Set the kinematic measurement (w,dw,ddp) on the limb where the kinematic flow is of type RBT\+\_\+\+NODE\+\_\+\+IN. 



Definition at line 561 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a7baf9422767d3f38b7d63ce72c246565}\label{classiCub_1_1iDyn_1_1iDynNode_a7baf9422767d3f38b7d63ce72c246565}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!setWrenchMeasure@{setWrenchMeasure}}
\index{setWrenchMeasure@{setWrenchMeasure}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{setWrenchMeasure()}{setWrenchMeasure()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual bool i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::set\+Wrench\+Measure (\begin{DoxyParamCaption}\item[{const yarp\+::sig\+::\+Matrix \&}]{F,  }\item[{const yarp\+::sig\+::\+Matrix \&}]{M }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Set the wrench measure on the limbs with input wrench. 


\begin{DoxyParams}{Parameters}
{\em F} & a (3xN) matrix with forces \\
\hline
{\em M} & a (3xN) matrix with moments \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if succeeds, false otherwise 
\end{DoxyReturn}
\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a3c3bf2f7eaa01c9c1bea5444e52f7ee8}\label{classiCub_1_1iDyn_1_1iDynNode_a3c3bf2f7eaa01c9c1bea5444e52f7ee8}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!setWrenchMeasure@{setWrenchMeasure}}
\index{setWrenchMeasure@{setWrenchMeasure}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{setWrenchMeasure()}{setWrenchMeasure()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual bool i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::set\+Wrench\+Measure (\begin{DoxyParamCaption}\item[{const yarp\+::sig\+::\+Matrix \&}]{FM }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Set the wrench measure on the limbs with input wrench. 


\begin{DoxyParams}{Parameters}
{\em FM} & a (6xN) matrix with forces and moments \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if succeeds, false otherwise 
\end{DoxyReturn}
\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_aa55a020dd4b6cd51c3c586099a38c059}\label{classiCub_1_1iDyn_1_1iDynNode_aa55a020dd4b6cd51c3c586099a38c059}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!solveKinematics@{solveKinematics}}
\index{solveKinematics@{solveKinematics}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{solveKinematics()}{solveKinematics()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool i\+Dyn\+Node\+::solve\+Kinematics (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Main function to manage the exchange of kinematic information among the limbs attached to the node. 

\begin{DoxyReturn}{Returns}
true if succeeds, false otherwise 
\end{DoxyReturn}


Definition at line 462 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a80b3da23a78324dff920a4d90e9050bb}\label{classiCub_1_1iDyn_1_1iDynNode_a80b3da23a78324dff920a4d90e9050bb}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!solveKinematics@{solveKinematics}}
\index{solveKinematics@{solveKinematics}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{solveKinematics()}{solveKinematics()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::solve\+Kinematics (\begin{DoxyParamCaption}\item[{const yarp\+::sig\+::\+Vector \&}]{w0,  }\item[{const yarp\+::sig\+::\+Vector \&}]{dw0,  }\item[{const yarp\+::sig\+::\+Vector \&}]{ddp0 }\end{DoxyParamCaption})}



Main function to manage the exchange of kinematic information among the limbs attached to the node. 

One single limb with kinematic flow of input type must exist\+: this limb is initilized with the kinematic variables w0,dw0,ddp0 (eg the up receives this information from the inertia sensor). The limb itself knows where to init the chain (base/end) depending on how it is attached to the node. Then the first limb kinematics is solved. The kinematic variables are retrieved from the RBT, which applies its roto-\/translation. Then the kinematic variables are sent to the other limbs, having kinematic flow of output type\+: the RBT transformation is applied from node to limb. 
\begin{DoxyParams}{Parameters}
{\em w0} & the initial/measured angular velocity \\
\hline
{\em dw0} & the initial/measured angular acceleration \\
\hline
{\em ddp0} & the initial/measured linear acceleration \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if succeeds, false otherwise 
\end{DoxyReturn}
\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_ad166af36d544d12a2aa6c3780fb06686}\label{classiCub_1_1iDyn_1_1iDynNode_ad166af36d544d12a2aa6c3780fb06686}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!solveWrench@{solveWrench}}
\index{solveWrench@{solveWrench}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{solveWrench()}{solveWrench()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily bool i\+Dyn\+Node\+::solve\+Wrench (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Main function to manage the exchange of wrench information among the limbs attached to the node. 

Multiple limbs with wrench flow of input type can exist, but at least one limb with output type must exist, to compute the wrench balance on the node. The measured/input wrenches to the limbs are here assumed to be set elsewhere\+: eg another class or the main is setting the measured wrenches. Note\+: RBT calls compute\+Wrench\+Newton\+Euler in the limb, meaning that performs a \char`\"{}basic\char`\"{} wrench computation without any sensor, just setting wrenches at the end-\/effector or at the base, and calling recursive wrench computation. \begin{DoxyReturn}{Returns}
true if succeeds, false otherwise 
\end{DoxyReturn}


Reimplemented in \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensorNode_a6c3f09586f4cba4d18446fabbeb7394d}{i\+Cub\+::i\+Dyn\+::i\+Dyn\+Sensor\+Node}}.



Definition at line 590 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_aa277ea9054106efe80d77e4e9c120978}\label{classiCub_1_1iDyn_1_1iDynNode_aa277ea9054106efe80d77e4e9c120978}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!solveWrench@{solveWrench}}
\index{solveWrench@{solveWrench}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{solveWrench()}{solveWrench()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily bool i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::solve\+Wrench (\begin{DoxyParamCaption}\item[{const yarp\+::sig\+::\+Matrix \&}]{F,  }\item[{const yarp\+::sig\+::\+Matrix \&}]{M }\end{DoxyParamCaption})}



This is to manage the exchange of wrench information among the limbs attached to the node. 

Multiple limbs with wrench flow of input type can exist, but at least one limb with output type must exist, to compute the wrench balance on the node. The measured/input wrenches to the limbs are here passed as a big matrix. In this function the input wrench is set in the limb calling init\+Wrench\+Newton\+Euler(), which simply set the measured forces in the base/final link of the limb. Input (eg measured) wrenches are stored in two 3xN matrix\+: each column is a 3x1 vector with force/moment; N is the number of columns, ie the number of measured/input wrenches to the limb the order is assumed coherent with the one built when adding limbs eg\+: adding limbs\+: add\+Limb(limb1), add\+Limb(limb2), add\+Limb(limb3) where limb1, limb3 have wrench flow input passing wrenches\+: Matrix F(3,2), F.\+setcol(0,f1), F.\+setcol(1,f3) and similar for moment

Note\+: RBT calls compute\+Wrench\+Newton\+Euler in the limb, meaning that perform a \char`\"{}basic\char`\"{} wrench computation without any sensor, just setting wrenches at the end-\/effector or at the base, and calling recursive wrench computation.


\begin{DoxyParams}{Parameters}
{\em F} & a (3xN) matrix with forces \\
\hline
{\em M} & a (3xN) matrix with moments \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if succeeds, false otherwise 
\end{DoxyReturn}
\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_af1cebfe81b63f533efd2f8d89300f0a7}\label{classiCub_1_1iDyn_1_1iDynNode_af1cebfe81b63f533efd2f8d89300f0a7}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!solveWrench@{solveWrench}}
\index{solveWrench@{solveWrench}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{solveWrench()}{solveWrench()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily bool i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::solve\+Wrench (\begin{DoxyParamCaption}\item[{const yarp\+::sig\+::\+Matrix \&}]{FM }\end{DoxyParamCaption})}



This is to manage the exchange of wrench information among the limbs attached to the node. 

Multiple limbs with wrench flow of input type can exist, but at least one limb with output type must exist, to compute the wrench balance on the node. The measured/input wrenches to the limbs are here passed as a big matrix. In this function the input wrench is set in the limb calling init\+Wrench\+Newton\+Euler(), which simply set the measured forces in the base/final link of the limb. elsewhere\+: eg another class or the main is setting the measured wrenches. Input (eg measured) wrenches are stored in a 6xN matrix\+: each column is a 6x1 vector with force/moment; N is the number of columns, ie the number of measured/input wrenches to the limb the order is assumed coherent with the one built when adding limbs eg\+: adding limbs\+: add\+Limb(limb1), add\+Limb(limb2), add\+Limb(limb3) where limb1, limb3 have wrench flow input setting wrenches\+: Matrix FM(6,2), FM.\+setcol(0,fm1), FM.\+setcol(1,fm3)

Note\+: RBT calls compute\+Wrench\+Newton\+Euler in the limb, meaning that perform a \char`\"{}basic\char`\"{} wrench computation without any sensor, just setting wrenches at the end-\/effector or at the base, and calling recursive wrench computation.


\begin{DoxyParams}{Parameters}
{\em FM} & a (6xN) matrix with forces and moments \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if succeeds, false otherwise 
\end{DoxyReturn}
\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_aa106c9340f7e2ffd57305868ac5c87a2}\label{classiCub_1_1iDyn_1_1iDynNode_aa106c9340f7e2ffd57305868ac5c87a2}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!TESTING\_computeCOMJacobian@{TESTING\_computeCOMJacobian}}
\index{TESTING\_computeCOMJacobian@{TESTING\_computeCOMJacobian}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{TESTING\_computeCOMJacobian()}{TESTING\_computeCOMJacobian()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily Matrix i\+Dyn\+Node\+::\+TESTING\+\_\+compute\+COMJacobian (\begin{DoxyParamCaption}\item[{unsigned int}]{i\+Chain,  }\item[{unsigned int}]{i\+Link }\end{DoxyParamCaption})}



Compute the Jacobian of the COM of the i-\/th link of the limb with index i\+Chain in the node. 

If the link index is not correct, a null Jacobian is returned. 
\begin{DoxyParams}{Parameters}
{\em i\+Chain} & the index of the chain (limb) in the node \\
\hline
{\em i\+Link} & the index of the limnk in the limb \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Jacobian matrix of the COM 
\end{DoxyReturn}


Definition at line 1194 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a93feed610e2fbfc9c1f254668a3ee6f9}\label{classiCub_1_1iDyn_1_1iDynNode_a93feed610e2fbfc9c1f254668a3ee6f9}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!TESTING\_computeCOMJacobian@{TESTING\_computeCOMJacobian}}
\index{TESTING\_computeCOMJacobian@{TESTING\_computeCOMJacobian}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{TESTING\_computeCOMJacobian()}{TESTING\_computeCOMJacobian()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily Matrix i\+Dyn\+Node\+::\+TESTING\+\_\+compute\+COMJacobian (\begin{DoxyParamCaption}\item[{unsigned int}]{i\+ChainA,  }\item[{\mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}}}]{dirA,  }\item[{unsigned int}]{i\+ChainB,  }\item[{unsigned int}]{i\+LinkB,  }\item[{\mbox{\hyperlink{namespaceiCub_1_1iDyn_af499ebb28864858a6ef02f9cbce82b23}{Jacob\+Type}}}]{dirB }\end{DoxyParamCaption})}



Compute the Jacobian of the COM of link i\+LinkB, in chainB, when two different chains (A and B) are connected. 

The chains are specified by their index in the list (the progressive number of insertion). The first limb has the base of the jacobian (base or end-\/effector of the limb, depending on the Jacobian direction JacA) while the second limb (limb B -\/ index=i\+ChainB) has the final link of the jacobian (index=i\+LinkB). 
\begin{DoxyParams}{Parameters}
{\em i\+ChainA} & the index of the chain (the limb) in the node having the base ($<$0$>$) frame \\
\hline
{\em dirA} & the \textquotesingle{}direction\textquotesingle{} of the chain wrt the jacobian computation \\
\hline
{\em i\+ChainB} & the index of the chain (the limb) in the node having the final ($<$\+N$>$) frame \\
\hline
{\em i\+LinkB} & the index of the link, in the index\+ChainN chain, being the final ($<$\+N$>$) frame for the Jacobian computation \\
\hline
{\em dirB} & the \textquotesingle{}direction\textquotesingle{} of the chain wrt the jacobian computation \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the Jacobian matrix of the COM 
\end{DoxyReturn}


Definition at line 1209 of file i\+Dyn\+Body.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_aea991e45c7d4b8bda29189071dffc5d5}\label{classiCub_1_1iDyn_1_1iDynNode_aea991e45c7d4b8bda29189071dffc5d5}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!zero@{zero}}
\index{zero@{zero}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{zero()}{zero()}}
{\footnotesize\ttfamily void i\+Dyn\+Node\+::zero (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Reset all data to zero. 

The list of limbs is not modified or deleted. 

Definition at line 433 of file i\+Dyn\+Body.\+cpp.



\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_af1ec3966a72191b31f266809403bfd06}\label{classiCub_1_1iDyn_1_1iDynNode_af1ec3966a72191b31f266809403bfd06}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!COM@{COM}}
\index{COM@{COM}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{COM}{COM}}
{\footnotesize\ttfamily yarp\+::sig\+::\+Vector i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::\+COM\hspace{0.3cm}{\ttfamily [protected]}}



COM position of the node. 



Definition at line 558 of file i\+Dyn\+Body.\+h.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a0c97b6d7b00ae9252f0c8b336a60e30c}\label{classiCub_1_1iDyn_1_1iDynNode_a0c97b6d7b00ae9252f0c8b336a60e30c}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!ddp@{ddp}}
\index{ddp@{ddp}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{ddp}{ddp}}
{\footnotesize\ttfamily yarp\+::sig\+::\+Vector i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::ddp\hspace{0.3cm}{\ttfamily [protected]}}



linear acceleration 



Definition at line 552 of file i\+Dyn\+Body.\+h.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_ad03a7e6af6ef82ff22fe36456329d2c8}\label{classiCub_1_1iDyn_1_1iDynNode_ad03a7e6af6ef82ff22fe36456329d2c8}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!dw@{dw}}
\index{dw@{dw}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{dw}{dw}}
{\footnotesize\ttfamily yarp\+::sig\+::\+Vector i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::dw\hspace{0.3cm}{\ttfamily [protected]}}



angular acceleration 



Definition at line 550 of file i\+Dyn\+Body.\+h.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_afbae85fc951a816738e887545dec6d1b}\label{classiCub_1_1iDyn_1_1iDynNode_afbae85fc951a816738e887545dec6d1b}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!F@{F}}
\index{F@{F}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{F}{F}}
{\footnotesize\ttfamily yarp\+::sig\+::\+Vector i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::F\hspace{0.3cm}{\ttfamily [protected]}}



force 



Definition at line 554 of file i\+Dyn\+Body.\+h.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a9c71d184a9385364ca17ac8acb134f99}\label{classiCub_1_1iDyn_1_1iDynNode_a9c71d184a9385364ca17ac8acb134f99}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!info@{info}}
\index{info@{info}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{info}{info}}
{\footnotesize\ttfamily std\+::string i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::info\hspace{0.3cm}{\ttfamily [protected]}}



info or useful notes 



Definition at line 542 of file i\+Dyn\+Body.\+h.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_ad5db3235dc804286712724c035345412}\label{classiCub_1_1iDyn_1_1iDynNode_ad5db3235dc804286712724c035345412}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!mass@{mass}}
\index{mass@{mass}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{mass}{mass}}
{\footnotesize\ttfamily double i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::mass\hspace{0.3cm}{\ttfamily [protected]}}



total mass of the node 



Definition at line 560 of file i\+Dyn\+Body.\+h.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a6a4212761245758347118b0b685b83bf}\label{classiCub_1_1iDyn_1_1iDynNode_a6a4212761245758347118b0b685b83bf}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!mode@{mode}}
\index{mode@{mode}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{mode}{mode}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362}{New\+Eul\+Mode}} i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::mode\hspace{0.3cm}{\ttfamily [protected]}}



STATIC/\+DYNAMIC/\+DYNAMIC\+\_\+\+W\+\_\+\+ROTOR/\+DYNAMIC\+\_\+\+CORIOLIS\+\_\+\+GRAVITY. 



Definition at line 539 of file i\+Dyn\+Body.\+h.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a80d77ab92e63190024ee4b8c8e116637}\label{classiCub_1_1iDyn_1_1iDynNode_a80d77ab92e63190024ee4b8c8e116637}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!Mu@{Mu}}
\index{Mu@{Mu}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{Mu}{Mu}}
{\footnotesize\ttfamily yarp\+::sig\+::\+Vector i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::\+Mu\hspace{0.3cm}{\ttfamily [protected]}}



moment 



Definition at line 556 of file i\+Dyn\+Body.\+h.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_aa2348a39cc0576e4de7624580a6997b9}\label{classiCub_1_1iDyn_1_1iDynNode_aa2348a39cc0576e4de7624580a6997b9}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!rbtList@{rbtList}}
\index{rbtList@{rbtList}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{rbtList}{rbtList}}
{\footnotesize\ttfamily std\+::deque$<$\mbox{\hyperlink{classiCub_1_1iDyn_1_1RigidBodyTransformation}{Rigid\+Body\+Transformation}}$>$ i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::rbt\+List\hspace{0.3cm}{\ttfamily [protected]}}



the list of RBT 



Definition at line 536 of file i\+Dyn\+Body.\+h.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a5fca92c14ebe1efb92463eb77ed67352}\label{classiCub_1_1iDyn_1_1iDynNode_a5fca92c14ebe1efb92463eb77ed67352}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!verbose@{verbose}}
\index{verbose@{verbose}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{verbose}{verbose}}
{\footnotesize\ttfamily unsigned int i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::verbose\hspace{0.3cm}{\ttfamily [protected]}}



verbosity flag 



Definition at line 545 of file i\+Dyn\+Body.\+h.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynNode_a74a74e80b0abb7063546f8b261bf359f}\label{classiCub_1_1iDyn_1_1iDynNode_a74a74e80b0abb7063546f8b261bf359f}} 
\index{iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}!w@{w}}
\index{w@{w}!iCub::iDyn::iDynNode@{iCub::iDyn::iDynNode}}
\doxysubsubsection{\texorpdfstring{w}{w}}
{\footnotesize\ttfamily yarp\+::sig\+::\+Vector i\+Cub\+::i\+Dyn\+::i\+Dyn\+Node\+::w\hspace{0.3cm}{\ttfamily [protected]}}



angular velocity 



Definition at line 548 of file i\+Dyn\+Body.\+h.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
icub-\/main/src/libraries/i\+Dyn/include/i\+Cub/i\+Dyn/\mbox{\hyperlink{iDynBody_8h}{i\+Dyn\+Body.\+h}}\item 
icub-\/main/src/libraries/i\+Dyn/src/\mbox{\hyperlink{iDynBody_8cpp}{i\+Dyn\+Body.\+cpp}}\end{DoxyCompactItemize}
