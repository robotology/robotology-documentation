\hypertarget{classiCub_1_1iDyn_1_1iDynSensor}{}\doxysection{i\+Cub\+::i\+Dyn\+::i\+Dyn\+Sensor Class Reference}
\label{classiCub_1_1iDyn_1_1iDynSensor}\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}


A class for computing forces and torques in a \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynChain}{i\+Dyn\+Chain}}, when a force/torque sensor is placed in the middle of the kinematic chain and it is the only available sensor for measuring forces and moments; the sensor position in the chain must be set; the computation of joint forces, moments and torques is performed by an Inverse Newton-\/\+Euler method.  




{\ttfamily \#include $<$i\+Dyn\+Inv.\+h$>$}



Inheritance diagram for i\+Cub\+::i\+Dyn\+::i\+Dyn\+Sensor\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classiCub_1_1iDyn_1_1iDynSensor__inherit__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_a85ccceff749e34385ab79a8adb01d050}{i\+Dyn\+Sensor}} (\mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynChain}{i\+Dyn\+::i\+Dyn\+Chain}} $\ast$\+\_\+c, std\+::string \+\_\+info, const \mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362}{New\+Eul\+Mode}} \+\_\+mode=\mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3}{DYNAMIC}}, unsigned int verb=\mbox{\hyperlink{namespaceiCub_1_1skinDynLib_a790824a527802db93c40eca73839b72dafa1f0844f596936c2d5af57dfbf9e49f}{i\+Cub\+::skin\+Dyn\+Lib\+::\+NO\+\_\+\+VERBOSE}})
\begin{DoxyCompactList}\small\item\em Constructor without FT sensor\+: the sensor must be set with \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynInvSensor_a7316f2ead7c50d6186d506adb49ebaa4}{set\+Sensor()}} \end{DoxyCompactList}\item 
\mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_a945d3864da08ccb613ce8ece690104f9}{i\+Dyn\+Sensor}} (\mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynChain}{i\+Dyn\+::i\+Dyn\+Chain}} $\ast$\+\_\+c, unsigned int i, const yarp\+::sig\+::\+Matrix \&\+\_\+H, const yarp\+::sig\+::\+Matrix \&\+\_\+\+HC, const double \+\_\+m, const yarp\+::sig\+::\+Matrix \&\+\_\+I, std\+::string \+\_\+info, const \mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362}{New\+Eul\+Mode}} \+\_\+mode=\mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3}{DYNAMIC}}, unsigned int verb=\mbox{\hyperlink{namespaceiCub_1_1skinDynLib_a790824a527802db93c40eca73839b72dafa1f0844f596936c2d5af57dfbf9e49f}{i\+Cub\+::skin\+Dyn\+Lib\+::\+NO\+\_\+\+VERBOSE}})
\begin{DoxyCompactList}\small\item\em Constructor with FT sensor. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_a13390f3a4c9d2b50c40cafbc9c40865e}{set\+Sensor\+Measures}} (const yarp\+::sig\+::\+Vector \&\mbox{\hyperlink{compute__ekf__sym_8m_a1fd406685cbdee605d0a7bebed56fdb0}{F}}, const yarp\+::sig\+::\+Vector \&Mu)
\begin{DoxyCompactList}\small\item\em Set the sensor measured force and moment. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_a1ddaa7d9b6e72575dddd2a8fc9f4a15a}{set\+Sensor\+Measures}} (const yarp\+::sig\+::\+Vector \&FM)
\begin{DoxyCompactList}\small\item\em Set the sensor measured force and moment at once. \end{DoxyCompactList}\item 
virtual bool \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_abbfe893110bc2fbd7b9fdd98d7fc9352}{compute\+From\+Sensor\+Newton\+Euler}} (const yarp\+::sig\+::\+Vector \&\mbox{\hyperlink{compute__ekf__sym_8m_a1fd406685cbdee605d0a7bebed56fdb0}{F}}, const yarp\+::sig\+::\+Vector \&Mu)
\begin{DoxyCompactList}\small\item\em The main computation method\+: given the FT sensor measurements, compute forces moments and torques in the \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynChain}{i\+Dyn\+Chain}}. \end{DoxyCompactList}\item 
virtual bool \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_aaa25462f5cd95efd64d8b84757e1bf18}{compute\+From\+Sensor\+Newton\+Euler}} (const yarp\+::sig\+::\+Vector \&FMu)
\begin{DoxyCompactList}\small\item\em The main computation method\+: given the FT sensor measurements, compute forces moments and torques in the \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynChain}{i\+Dyn\+Chain}}. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_a2dca3b9029fd67896763473e53fe0d77}{compute\+From\+Sensor\+Newton\+Euler}} ()
\begin{DoxyCompactList}\small\item\em The main computation method\+: given the FT sensor measurements, compute forces moments and torques in the \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynChain}{i\+Dyn\+Chain}}. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_a3741a4b9ac6c85086b38429074367ebe}{compute\+Wrench\+From\+Sensor\+Newton\+Euler}} ()
\begin{DoxyCompactList}\small\item\em The main computation method\+: given the FT sensor measurements, compute forces moments and torques in the \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynChain}{i\+Dyn\+Chain}}. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Matrix \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_aa1cb210088a930208c2dcaf8ebbb2931}{get\+Forces}} () const
\begin{DoxyCompactList}\small\item\em Returns the links forces as a matrix, where the i-\/th col is the i-\/th force. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Matrix \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_ac073d0b4b3b0a8116f990cd1e5831a5f}{get\+Moments}} () const
\begin{DoxyCompactList}\small\item\em Returns the links moments as a matrix, where the i-\/th col is the i-\/th moment. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_aea2c5a5e33d78257df9b23e4108b2c41}{get\+Torques}} () const
\begin{DoxyCompactList}\small\item\em Returns the links torque as a vector. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_a451acccaaa8451612cd3f062f9449335}{get\+Force}} (const unsigned int i\+Link) const
\begin{DoxyCompactList}\small\item\em Returns the i-\/th link force. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_a96fac257f5dc281e2f039a1b1d119906}{get\+Moment}} (const unsigned int i\+Link) const
\begin{DoxyCompactList}\small\item\em Returns the i-\/th link moment. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_a6594ae87235632e374eb4b901096238c}{get\+Torque}} (const unsigned int i\+Link) const
\begin{DoxyCompactList}\small\item\em Returns the i-\/th link torque. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Matrix \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_a8f36418c60d943edc49f2ccadd5bae06}{get\+Forces\+Newton\+Euler}} () const
\begin{DoxyCompactList}\small\item\em Returns the links forces as a matrix, where the i-\/th col is the i-\/th force. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Matrix \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_a51e5938f495f94ae04b6a800592ce38c}{get\+Moments\+Newton\+Euler}} () const
\begin{DoxyCompactList}\small\item\em Returns the links moments as a matrix, where the i-\/th col is the i-\/th moment. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_a6a7003d265c9fe2137a3a58b8e7dd896}{get\+Torques\+Newton\+Euler}} () const
\begin{DoxyCompactList}\small\item\em Returns the links torque as a vector. \end{DoxyCompactList}\item 
virtual yarp\+::sig\+::\+Vector \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_ad8169d7da1e8eb5e0758a06f4d964b95}{get\+Force\+Moment\+End\+Eff}} () const
\begin{DoxyCompactList}\small\item\em Returns the end-\/effector force-\/moment as a single (6x1) vector. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
A class for computing forces and torques in a \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynChain}{i\+Dyn\+Chain}}, when a force/torque sensor is placed in the middle of the kinematic chain and it is the only available sensor for measuring forces and moments; the sensor position in the chain must be set; the computation of joint forces, moments and torques is performed by an Inverse Newton-\/\+Euler method. 

Definition at line 1577 of file i\+Dyn\+Inv.\+h.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_a85ccceff749e34385ab79a8adb01d050}\label{classiCub_1_1iDyn_1_1iDynSensor_a85ccceff749e34385ab79a8adb01d050}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!iDynSensor@{iDynSensor}}
\index{iDynSensor@{iDynSensor}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{iDynSensor()}{iDynSensor()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily i\+Dyn\+Sensor\+::i\+Dyn\+Sensor (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynChain}{i\+Dyn\+::i\+Dyn\+Chain}} $\ast$}]{\+\_\+c,  }\item[{std\+::string}]{\+\_\+info,  }\item[{const \mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362}{New\+Eul\+Mode}}}]{\+\_\+mode = {\ttfamily \mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3}{DYNAMIC}}},  }\item[{unsigned int}]{verb = {\ttfamily \mbox{\hyperlink{namespaceiCub_1_1skinDynLib_a790824a527802db93c40eca73839b72dafa1f0844f596936c2d5af57dfbf9e49f}{i\+Cub\+::skin\+Dyn\+Lib\+::\+NO\+\_\+\+VERBOSE}}} }\end{DoxyParamCaption})}



Constructor without FT sensor\+: the sensor must be set with \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynInvSensor_a7316f2ead7c50d6186d506adb49ebaa4}{set\+Sensor()}} 


\begin{DoxyParams}{Parameters}
{\em \+\_\+c} & a pointer to the \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynChain}{i\+Dyn\+Chain}} where the sensor is placed on \\
\hline
{\em \+\_\+info} & a string with information \\
\hline
{\em \+\_\+mode} & the analysis mode (static/dynamic) \\
\hline
{\em verb} & flag for verbosity \\
\hline
\end{DoxyParams}


Definition at line 2574 of file i\+Dyn\+Inv.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_a945d3864da08ccb613ce8ece690104f9}\label{classiCub_1_1iDyn_1_1iDynSensor_a945d3864da08ccb613ce8ece690104f9}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!iDynSensor@{iDynSensor}}
\index{iDynSensor@{iDynSensor}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{iDynSensor()}{iDynSensor()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily i\+Cub\+::i\+Dyn\+::i\+Dyn\+Sensor\+::i\+Dyn\+Sensor (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynChain}{i\+Dyn\+::i\+Dyn\+Chain}} $\ast$}]{\+\_\+c,  }\item[{unsigned int}]{i,  }\item[{const yarp\+::sig\+::\+Matrix \&}]{\+\_\+H,  }\item[{const yarp\+::sig\+::\+Matrix \&}]{\+\_\+\+HC,  }\item[{const double}]{\+\_\+m,  }\item[{const yarp\+::sig\+::\+Matrix \&}]{\+\_\+I,  }\item[{std\+::string}]{\+\_\+info,  }\item[{const \mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362}{New\+Eul\+Mode}}}]{\+\_\+mode = {\ttfamily \mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3}{DYNAMIC}}},  }\item[{unsigned int}]{verb = {\ttfamily \mbox{\hyperlink{namespaceiCub_1_1skinDynLib_a790824a527802db93c40eca73839b72dafa1f0844f596936c2d5af57dfbf9e49f}{i\+Cub\+::skin\+Dyn\+Lib\+::\+NO\+\_\+\+VERBOSE}}} }\end{DoxyParamCaption})}



Constructor with FT sensor. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+c} & a pointer to the \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynChain}{i\+Dyn\+Chain}} where the sensor is placed on \\
\hline
{\em i} & the i-\/th link to whom the sensor is attached \\
\hline
{\em \+\_\+H} & the roto-\/traslational matrix from the reference frame of the i-\/th link to the sensor \\
\hline
{\em \+\_\+\+HC} & the roto-\/traslational matrix of the center of mass of the semi-\/link defined by the sensor in the i-\/th link \\
\hline
{\em \+\_\+m} & the mass of the semi-\/link \\
\hline
{\em \+\_\+I} & the inertia of the semi-\/link \\
\hline
{\em \+\_\+info} & a string with information \\
\hline
{\em \+\_\+mode} & the analysis mode (static/dynamic) \\
\hline
{\em verb} & flag for verbosity \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_a2dca3b9029fd67896763473e53fe0d77}\label{classiCub_1_1iDyn_1_1iDynSensor_a2dca3b9029fd67896763473e53fe0d77}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!computeFromSensorNewtonEuler@{computeFromSensorNewtonEuler}}
\index{computeFromSensorNewtonEuler@{computeFromSensorNewtonEuler}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{computeFromSensorNewtonEuler()}{computeFromSensorNewtonEuler()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void i\+Dyn\+Sensor\+::compute\+From\+Sensor\+Newton\+Euler (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



The main computation method\+: given the FT sensor measurements, compute forces moments and torques in the \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynChain}{i\+Dyn\+Chain}}. 

A forward pass of the classical Newton-\/\+Euler method is run, to retrieve angular and linear accelerations. Then, from sensor to end-\/effector the inverse Newton-\/\+Euler formula is applied to retrieve joint forces and torques, while from sensor to base the classical backward pass is run. This method only perform the computations\+: the force and moment measured on the sensor must be set before calling this method using \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_a13390f3a4c9d2b50c40cafbc9c40865e}{set\+Sensor\+Measures()}} 

Definition at line 2611 of file i\+Dyn\+Inv.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_abbfe893110bc2fbd7b9fdd98d7fc9352}\label{classiCub_1_1iDyn_1_1iDynSensor_abbfe893110bc2fbd7b9fdd98d7fc9352}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!computeFromSensorNewtonEuler@{computeFromSensorNewtonEuler}}
\index{computeFromSensorNewtonEuler@{computeFromSensorNewtonEuler}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{computeFromSensorNewtonEuler()}{computeFromSensorNewtonEuler()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily virtual bool i\+Cub\+::i\+Dyn\+::i\+Dyn\+Sensor\+::compute\+From\+Sensor\+Newton\+Euler (\begin{DoxyParamCaption}\item[{const yarp\+::sig\+::\+Vector \&}]{F,  }\item[{const yarp\+::sig\+::\+Vector \&}]{Mu }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



The main computation method\+: given the FT sensor measurements, compute forces moments and torques in the \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynChain}{i\+Dyn\+Chain}}. 

A forward pass of the classical Newton-\/\+Euler method is run, to retrieve angular and linear accelerations. Then, from sensor to end-\/effector the inverse Newton-\/\+Euler formula is applied to retrieve joint forces and torques, while from sensor to base the classical backward pass is run. 
\begin{DoxyParams}{Parameters}
{\em F} & the sensor force (3x1) \\
\hline
{\em Mu} & the sensor moment (3x1) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the operation is successful, false otherwise (ie wrong vector size) 
\end{DoxyReturn}
\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_aaa25462f5cd95efd64d8b84757e1bf18}\label{classiCub_1_1iDyn_1_1iDynSensor_aaa25462f5cd95efd64d8b84757e1bf18}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!computeFromSensorNewtonEuler@{computeFromSensorNewtonEuler}}
\index{computeFromSensorNewtonEuler@{computeFromSensorNewtonEuler}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{computeFromSensorNewtonEuler()}{computeFromSensorNewtonEuler()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily virtual bool i\+Cub\+::i\+Dyn\+::i\+Dyn\+Sensor\+::compute\+From\+Sensor\+Newton\+Euler (\begin{DoxyParamCaption}\item[{const yarp\+::sig\+::\+Vector \&}]{FMu }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



The main computation method\+: given the FT sensor measurements, compute forces moments and torques in the \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynChain}{i\+Dyn\+Chain}}. 

A forward pass of the classical Newton-\/\+Euler method is run, to retrieve angular and linear accelerations. Then, from sensor to end-\/effector the inverse Newton-\/\+Euler formula is applied to retrieve joint forces and torques, while from sensor to base the classical backward pass is run. 
\begin{DoxyParams}{Parameters}
{\em FMu} & the sensor force and moment (6x1) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the operation is successful, false otherwise (ie wrong vector size) 
\end{DoxyReturn}
\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_a3741a4b9ac6c85086b38429074367ebe}\label{classiCub_1_1iDyn_1_1iDynSensor_a3741a4b9ac6c85086b38429074367ebe}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!computeWrenchFromSensorNewtonEuler@{computeWrenchFromSensorNewtonEuler}}
\index{computeWrenchFromSensorNewtonEuler@{computeWrenchFromSensorNewtonEuler}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{computeWrenchFromSensorNewtonEuler()}{computeWrenchFromSensorNewtonEuler()}}
{\footnotesize\ttfamily void i\+Dyn\+Sensor\+::compute\+Wrench\+From\+Sensor\+Newton\+Euler (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



The main computation method\+: given the FT sensor measurements, compute forces moments and torques in the \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynChain}{i\+Dyn\+Chain}}. 

The kinematic pass is already performed. Only the wrench computation are performed here\+: from sensor to end-\/effector the inverse Newton-\/\+Euler formula is applied to retrieve joint forces and torques, while from sensor to base the classical backward pass is run. This method only perform the computations\+: the force and moment measured on the sensor must be set before calling this method using \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensor_a13390f3a4c9d2b50c40cafbc9c40865e}{set\+Sensor\+Measures()}} This method is called by \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynSensorNode}{i\+Dyn\+Sensor\+Node}}. 

Reimplemented in \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynContactSolver_a8f8d87314fe65b5d3026653b516ed7f9}{i\+Cub\+::i\+Dyn\+::i\+Dyn\+Contact\+Solver}}.



Definition at line 2634 of file i\+Dyn\+Inv.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_a451acccaaa8451612cd3f062f9449335}\label{classiCub_1_1iDyn_1_1iDynSensor_a451acccaaa8451612cd3f062f9449335}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!getForce@{getForce}}
\index{getForce@{getForce}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{getForce()}{getForce()}}
{\footnotesize\ttfamily Vector i\+Dyn\+Sensor\+::get\+Force (\begin{DoxyParamCaption}\item[{const unsigned int}]{i\+Link }\end{DoxyParamCaption}) const}



Returns the i-\/th link force. 

\begin{DoxyReturn}{Returns}
the i-\/th link force 
\end{DoxyReturn}


Definition at line 2684 of file i\+Dyn\+Inv.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_ad8169d7da1e8eb5e0758a06f4d964b95}\label{classiCub_1_1iDyn_1_1iDynSensor_ad8169d7da1e8eb5e0758a06f4d964b95}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!getForceMomentEndEff@{getForceMomentEndEff}}
\index{getForceMomentEndEff@{getForceMomentEndEff}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{getForceMomentEndEff()}{getForceMomentEndEff()}}
{\footnotesize\ttfamily Vector i\+Dyn\+Sensor\+::get\+Force\+Moment\+End\+Eff (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}



Returns the end-\/effector force-\/moment as a single (6x1) vector. 

\begin{DoxyReturn}{Returns}
a 6x1 vector with the the end-\/effector force-\/moment 
\end{DoxyReturn}


Reimplemented in \mbox{\hyperlink{classiCub_1_1iDyn_1_1iDynContactSolver_a48f8b7c0c0e15c6105c970f3c21bf757}{i\+Cub\+::i\+Dyn\+::i\+Dyn\+Contact\+Solver}}.



Definition at line 2696 of file i\+Dyn\+Inv.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_aa1cb210088a930208c2dcaf8ebbb2931}\label{classiCub_1_1iDyn_1_1iDynSensor_aa1cb210088a930208c2dcaf8ebbb2931}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!getForces@{getForces}}
\index{getForces@{getForces}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{getForces()}{getForces()}}
{\footnotesize\ttfamily Matrix i\+Dyn\+Sensor\+::get\+Forces (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Returns the links forces as a matrix, where the i-\/th col is the i-\/th force. 

\begin{DoxyReturn}{Returns}
a 3xN matrix with forces, in the form\+: i-\/th col = F\+\_\+i 
\end{DoxyReturn}


Definition at line 2678 of file i\+Dyn\+Inv.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_a8f36418c60d943edc49f2ccadd5bae06}\label{classiCub_1_1iDyn_1_1iDynSensor_a8f36418c60d943edc49f2ccadd5bae06}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!getForcesNewtonEuler@{getForcesNewtonEuler}}
\index{getForcesNewtonEuler@{getForcesNewtonEuler}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{getForcesNewtonEuler()}{getForcesNewtonEuler()}}
{\footnotesize\ttfamily Matrix i\+Dyn\+Sensor\+::get\+Forces\+Newton\+Euler (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Returns the links forces as a matrix, where the i-\/th col is the i-\/th force. 

\begin{DoxyReturn}{Returns}
a 3x(N+2) matrix with forces, in the form\+: i-\/th col = F\+\_\+i 
\end{DoxyReturn}


Definition at line 2690 of file i\+Dyn\+Inv.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_a96fac257f5dc281e2f039a1b1d119906}\label{classiCub_1_1iDyn_1_1iDynSensor_a96fac257f5dc281e2f039a1b1d119906}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!getMoment@{getMoment}}
\index{getMoment@{getMoment}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{getMoment()}{getMoment()}}
{\footnotesize\ttfamily Vector i\+Dyn\+Sensor\+::get\+Moment (\begin{DoxyParamCaption}\item[{const unsigned int}]{i\+Link }\end{DoxyParamCaption}) const}



Returns the i-\/th link moment. 

\begin{DoxyReturn}{Returns}
the i-\/th link moment 
\end{DoxyReturn}


Definition at line 2686 of file i\+Dyn\+Inv.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_ac073d0b4b3b0a8116f990cd1e5831a5f}\label{classiCub_1_1iDyn_1_1iDynSensor_ac073d0b4b3b0a8116f990cd1e5831a5f}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!getMoments@{getMoments}}
\index{getMoments@{getMoments}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{getMoments()}{getMoments()}}
{\footnotesize\ttfamily Matrix i\+Dyn\+Sensor\+::get\+Moments (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Returns the links moments as a matrix, where the i-\/th col is the i-\/th moment. 

\begin{DoxyReturn}{Returns}
a 3xN matrix with moments, in the form\+: i-\/th col = Mu\+\_\+i 
\end{DoxyReturn}


Definition at line 2680 of file i\+Dyn\+Inv.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_a51e5938f495f94ae04b6a800592ce38c}\label{classiCub_1_1iDyn_1_1iDynSensor_a51e5938f495f94ae04b6a800592ce38c}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!getMomentsNewtonEuler@{getMomentsNewtonEuler}}
\index{getMomentsNewtonEuler@{getMomentsNewtonEuler}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{getMomentsNewtonEuler()}{getMomentsNewtonEuler()}}
{\footnotesize\ttfamily Matrix i\+Dyn\+Sensor\+::get\+Moments\+Newton\+Euler (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Returns the links moments as a matrix, where the i-\/th col is the i-\/th moment. 

\begin{DoxyReturn}{Returns}
a 3x(N+2) matrix with moments, in the form\+: i-\/th col = Mu\+\_\+i 
\end{DoxyReturn}


Definition at line 2692 of file i\+Dyn\+Inv.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_a6594ae87235632e374eb4b901096238c}\label{classiCub_1_1iDyn_1_1iDynSensor_a6594ae87235632e374eb4b901096238c}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!getTorque@{getTorque}}
\index{getTorque@{getTorque}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{getTorque()}{getTorque()}}
{\footnotesize\ttfamily double i\+Dyn\+Sensor\+::get\+Torque (\begin{DoxyParamCaption}\item[{const unsigned int}]{i\+Link }\end{DoxyParamCaption}) const}



Returns the i-\/th link torque. 

\begin{DoxyReturn}{Returns}
the i-\/th link torque 
\end{DoxyReturn}


Definition at line 2688 of file i\+Dyn\+Inv.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_aea2c5a5e33d78257df9b23e4108b2c41}\label{classiCub_1_1iDyn_1_1iDynSensor_aea2c5a5e33d78257df9b23e4108b2c41}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!getTorques@{getTorques}}
\index{getTorques@{getTorques}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{getTorques()}{getTorques()}}
{\footnotesize\ttfamily Vector i\+Dyn\+Sensor\+::get\+Torques (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Returns the links torque as a vector. 

\begin{DoxyReturn}{Returns}
a Nx1 vector with the torques 
\end{DoxyReturn}


Definition at line 2682 of file i\+Dyn\+Inv.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_a6a7003d265c9fe2137a3a58b8e7dd896}\label{classiCub_1_1iDyn_1_1iDynSensor_a6a7003d265c9fe2137a3a58b8e7dd896}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!getTorquesNewtonEuler@{getTorquesNewtonEuler}}
\index{getTorquesNewtonEuler@{getTorquesNewtonEuler}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{getTorquesNewtonEuler()}{getTorquesNewtonEuler()}}
{\footnotesize\ttfamily Vector i\+Dyn\+Sensor\+::get\+Torques\+Newton\+Euler (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}



Returns the links torque as a vector. 

\begin{DoxyReturn}{Returns}
a Nx1 vector with the torques 
\end{DoxyReturn}


Definition at line 2694 of file i\+Dyn\+Inv.\+cpp.

\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_a13390f3a4c9d2b50c40cafbc9c40865e}\label{classiCub_1_1iDyn_1_1iDynSensor_a13390f3a4c9d2b50c40cafbc9c40865e}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!setSensorMeasures@{setSensorMeasures}}
\index{setSensorMeasures@{setSensorMeasures}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{setSensorMeasures()}{setSensorMeasures()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool i\+Cub\+::i\+Dyn\+::i\+Dyn\+Sensor\+::set\+Sensor\+Measures (\begin{DoxyParamCaption}\item[{const yarp\+::sig\+::\+Vector \&}]{F,  }\item[{const yarp\+::sig\+::\+Vector \&}]{Mu }\end{DoxyParamCaption})}



Set the sensor measured force and moment. 


\begin{DoxyParams}{Parameters}
{\em F} & the sensor force (3x1) \\
\hline
{\em Mu} & the sensor moment (3x1) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the operation is successful, false otherwise (ie wrong vector size) 
\end{DoxyReturn}
\mbox{\Hypertarget{classiCub_1_1iDyn_1_1iDynSensor_a1ddaa7d9b6e72575dddd2a8fc9f4a15a}\label{classiCub_1_1iDyn_1_1iDynSensor_a1ddaa7d9b6e72575dddd2a8fc9f4a15a}} 
\index{iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}!setSensorMeasures@{setSensorMeasures}}
\index{setSensorMeasures@{setSensorMeasures}!iCub::iDyn::iDynSensor@{iCub::iDyn::iDynSensor}}
\doxysubsubsection{\texorpdfstring{setSensorMeasures()}{setSensorMeasures()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool i\+Cub\+::i\+Dyn\+::i\+Dyn\+Sensor\+::set\+Sensor\+Measures (\begin{DoxyParamCaption}\item[{const yarp\+::sig\+::\+Vector \&}]{FM }\end{DoxyParamCaption})}



Set the sensor measured force and moment at once. 

The measure vector (6x1) is made of 0\+:2=force 3\+:5=moment 
\begin{DoxyParams}{Parameters}
{\em FM} & the sensor force and moment (6x1) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the operation is successful, false otherwise (ie wrong vector size) 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
icub-\/main/src/libraries/i\+Dyn/include/i\+Cub/i\+Dyn/\mbox{\hyperlink{iDynInv_8h}{i\+Dyn\+Inv.\+h}}\item 
icub-\/main/src/libraries/i\+Dyn/src/\mbox{\hyperlink{iDynInv_8cpp}{i\+Dyn\+Inv.\+cpp}}\end{DoxyCompactItemize}
