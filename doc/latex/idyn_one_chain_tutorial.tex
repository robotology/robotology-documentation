In this tutorial we show how to compute the joint torques in a single kinematic chain, using the i\+Dyn library.

Before you read this tutorial you should at least get accustomed with the i\+Dyn library, and the basic of Newton-\/\+Euler algorithm (reading the \mbox{\hyperlink{idyn_introduction}{short introduction to i\+Dyn}} might be useful).

Remember to include YARP and \mbox{\hyperlink{namespaceiCub}{i\+Cub}} as packages, and to link i\+Dyn library in CMake\+Lists.\+txt\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{FIND\_PACKAGE(YARP)}
\DoxyCodeLine{FIND\_PACKAGE(ICUB)}
\DoxyCodeLine{...                                                                     }
\DoxyCodeLine{TARGET\_LINK\_LIBRARIES(\$\{PROJECTNAME\} iDyn \$\{YARP\_LIBRARIES\})}

\end{DoxyCode}
 note that in this case we need to look for the packages because we are developing a tutorial which is outside \mbox{\hyperlink{namespaceiCub}{i\+Cub}} project.

Using i\+Dyn classes, vectors and matrices are used all the times. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <yarp/sig/Vector.h>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <yarp/sig/Matrix.h>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <\mbox{\hyperlink{iDyn_8h}{iCub/iDyn/iDyn.h}}>}}
\DoxyCodeLine{...}
\DoxyCodeLine{using \textcolor{keyword}{namespace }yarp::sig;}
\DoxyCodeLine{\textcolor{keyword}{using namespace }\mbox{\hyperlink{namespaceiCub_1_1iDyn}{iCub::iDyn}};}

\end{DoxyCode}


We start creating a i\+Dyn\+::i\+Cub\+Arm\+Dyn, that is a chain with arm and torso links. If you are familiar with i\+Kin, it is exactly the same limb type, with the same kinematic properties of a i\+Cub\+Arm. Of course, i\+Cub\+Arm\+Dyn is more complete, since it basically inherits the kinematics and provides the dynamics. 
\begin{DoxyCode}{0}
\DoxyCodeLine{iCubArmDyn armTorsoDyn(\textcolor{stringliteral}{"{}right"{}});}

\end{DoxyCode}


By default in i\+Cub\+Arm\+Dyn the torso is blocked, as it is in its corresponding i\+Kin limb, i\+Cub\+Arm; we unblock it, so we can also use the torso links. Note that releasing the links we have N==DOF (i.\+e. the number of links equal to the number of degrees of freedom). 
\begin{DoxyCode}{0}
\DoxyCodeLine{armTorsoDyn.releaseLink(0);}
\DoxyCodeLine{armTorsoDyn.releaseLink(1);}
\DoxyCodeLine{armTorsoDyn.releaseLink(2);}

\end{DoxyCode}


Before any computation, we must prepare the necessary variables and put them in the chain model. First of all, we must set the joint angles in the limb model\+: in dynamics, we need joint positions, velocities and accelerations.


\begin{DoxyCode}{0}
\DoxyCodeLine{Vector q(armTorsoDyn.getN()); q.zero();}
\DoxyCodeLine{Vector dq(q); Vector ddq(q);}

\end{DoxyCode}


In \mbox{\hyperlink{namespaceiCub}{i\+Cub}} we only have position measurements from the encoders, so in order to avoid noisy values on velocity and acceleration, we suggest to apply at least a linear filter on the velocity data computed by differentiation, and a quadratic filter on the acceleration data. As a suggestion, look for adapt\+Win\+Poly\+Estimator in the ctrl\+Lib, or have a look at the module Whole\+Body\+Torque\+Observer. Note that if the joint angles exceed the joint limits, their value is saturated to their min/max value automatically (as in i\+Kin). At the moment there\textquotesingle{}s not such a limitation for velocities and accelerations. It must be reminded that the joint limits could be different in the real robot, so it is always a good practice, when using the robot, to call the {\itshape align\+Joints\+Bound} method, which queries the robot for the real joints limits.


\begin{DoxyCode}{0}
\DoxyCodeLine{armTorsoDyn.setAng(q);}
\DoxyCodeLine{armTorsoDyn.setDAng(dq);}
\DoxyCodeLine{armTorsoDyn.setD2Ang(ddq);}

\end{DoxyCode}


In order to initialize the kinematic phase of Newton-\/\+Euler algorithm, we need the kinematic informations to be set in the base of the chain, where the base is intended to be the first link (first w.\+r.\+t the Denavit Hartenberg convention for describing the links, so the torso base in i\+Cub\+Arm\+Dyn). If the robot is fixed and not moving, everything can be simply set to zero\+: but remember to provide the gravity information!


\begin{DoxyCode}{0}
\DoxyCodeLine{Vector w0(3); Vector dw0(3); Vector ddp0(3);}
\DoxyCodeLine{w0=dw0=ddp0=0.0; ddp0[2]=9.81;}

\end{DoxyCode}


The end-\/effector external wrench (force/moment), is necessary to initialize the wrench phase of the Newton-\/\+Euler algorithm. If the robot is not touching anything, the external wrench is zero by default. If there\textquotesingle{}s contact... look at the Wrench\+Observer module.


\begin{DoxyCode}{0}
\DoxyCodeLine{Vector Fend(3); Fend.zero();}
\DoxyCodeLine{Vector Muend(Fend);}

\end{DoxyCode}


We can now start using i\+Dyn. In order to perform the kinematic and wrench computation in a chain, we must first tell the limb that we want to use the i\+Dyn\+::\+Recursive\+Newton\+Euler library, by calling a \char`\"{}prepare\char`\"{} method. In fact, before using our method, a new chain, parallel to the i\+Dyn\+Chain, is built\+: it is a One\+Chain\+Newton\+Euler, and it is made of One\+Link\+Newton\+Euler virtual links, each having its \char`\"{}real\char`\"{} corresponding i\+Dyn\+Link; in addition, a Base\+Link and a Final\+Link elements are added to the chain, defining the entry points for the kinematic and wrench phases of Newton-\/\+Euler computations.

The reason of the existence of the {\itshape prepare\+Newton\+Euler} method is twofold\+:
\begin{DoxyEnumerate}
\item one can use a i\+Dyn\+Limb without dynamics, since it includes the kinematics of i\+Kin for example one may only want to set joint angles and compute the jacobian
\item one may prefer to use its own dynamic library to compute internal forces/torques, and not necessarily the Newton-\/\+Euler one we provide.
\end{DoxyEnumerate}

When calling {\itshape prepare\+Newton\+Euler()}, we must specify the type of computations we want to perform, which are basically\+:


\begin{DoxyItemize}
\item STATIC\+: we only need q (joints positions)
\item DYNAMIC\+: we need q,dq,ddq (joints position, velocity, acceleration) -\/-\/$>$ default
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{armTorsoDyn.prepareNewtonEuler(\mbox{\hyperlink{namespaceiCub_1_1iDyn_a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3}{DYNAMIC}});}

\end{DoxyCode}


Finally we perform the computations, by calling a single function which performs autonomously\+:
\begin{DoxyEnumerate}
\item Initialization of both phases
\item Kinematic Phase
\item Wrench Phase
\end{DoxyEnumerate}


\begin{DoxyCode}{0}
\DoxyCodeLine{armTorsoDyn.computeNewtonEuler(w0,dw0,ddp0,Fend,Muend);}

\end{DoxyCode}


We can now retrieve the results\+: forces, moments and joint torques. In particular, F and M are 3xN matrices, where the i-\/th column is the i-\/th force/moment (each having 3 components), whereas Tau is a 1xN vector, since the joint torque is a scalar number.


\begin{DoxyCode}{0}
\DoxyCodeLine{Matrix \mbox{\hyperlink{compute__ekf__fast_8m_a1fd406685cbdee605d0a7bebed56fdb0}{F}} = armTorsoDyn.getForces();}
\DoxyCodeLine{Matrix Mu = armTorsoDyn.getMoments();}
\DoxyCodeLine{Vector Tau = armTorsoDyn.getTorques();}

\end{DoxyCode}


Full working code of this tutorial is available here\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{icub-\/tutorials/src/iDyn/oneChainDynamics/\mbox{\hyperlink{icub-main_2src_2core_2emotionInterface_2main_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main}}.cpp}

\end{DoxyCode}


\begin{DoxyAuthor}{Author}
Serena Ivaldi 
\end{DoxyAuthor}
