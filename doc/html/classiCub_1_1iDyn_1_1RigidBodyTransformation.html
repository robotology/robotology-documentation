<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iCub-main: iCub::iDyn::RigidBodyTransformation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iCub-main
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceiCub.html">iCub</a></li><li class="navelem"><a class="el" href="namespaceiCub_1_1iDyn.html">iDyn</a></li><li class="navelem"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html">RigidBodyTransformation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classiCub_1_1iDyn_1_1RigidBodyTransformation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">iCub::iDyn::RigidBodyTransformation Class Reference<div class="ingroups"><a class="el" href="group__icub__modules__all.html">Software</a> &raquo; <a class="el" href="group__icub__libraries.html">Libraries</a> &raquo; <a class="el" href="group__iDyn.html">iDyn</a> &raquo; <a class="el" href="group__iDynBody.html">iDynBody</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for setting a rigid body transformation between <a class="el" href="classiCub_1_1iDyn_1_1iDynLimb.html" title="A class for defining a generic Limb within the iDyn framework.">iDynLimb</a> and <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html" title="A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between l...">iDynNode</a>.  
 <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a95f03fa5b0fb644aff65c9e9130ed92b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a95f03fa5b0fb644aff65c9e9130ed92b">RigidBodyTransformation</a> (<a class="el" href="classiCub_1_1iDyn_1_1iDynLimb.html">iDyn::iDynLimb</a> *_limb, const yarp::sig::Matrix &amp;_H, const std::string &amp;_info, bool _hasSensor=false, const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a> kin=<a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a2ade845ecc299911bc2906e1e2539064">RBT_NODE_OUT</a>, const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a> wre=<a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a733307f2252a4e82441f412c04653a29">RBT_NODE_IN</a>, const <a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a> _mode=<a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3">DYNAMIC</a>, unsigned int verb=<a class="el" href="namespaceiCub_1_1skinDynLib.html#a790824a527802db93c40eca73839b72da16220311c35a0345c00855ea2032c695">iCub::skinDynLib::VERBOSE</a>)</td></tr>
<tr class="memdesc:a95f03fa5b0fb644aff65c9e9130ed92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, defining the limb attached to the node.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a95f03fa5b0fb644aff65c9e9130ed92b">More...</a><br /></td></tr>
<tr class="separator:a95f03fa5b0fb644aff65c9e9130ed92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa113bf7d5f80d2616340ba970470e561"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#aa113bf7d5f80d2616340ba970470e561">~RigidBodyTransformation</a> ()</td></tr>
<tr class="memdesc:aa113bf7d5f80d2616340ba970470e561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#aa113bf7d5f80d2616340ba970470e561">More...</a><br /></td></tr>
<tr class="separator:aa113bf7d5f80d2616340ba970470e561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d18283bf99c6cdb2196408213c663d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a0d18283bf99c6cdb2196408213c663d0">setRBT</a> (const yarp::sig::Matrix &amp;_H)</td></tr>
<tr class="memdesc:a0d18283bf99c6cdb2196408213c663d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the roto-translational matrix between the limb and the node, defining the rigid body transformation.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a0d18283bf99c6cdb2196408213c663d0">More...</a><br /></td></tr>
<tr class="separator:a0d18283bf99c6cdb2196408213c663d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79709f8d1a4f08a3967bc9f84d385099"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a79709f8d1a4f08a3967bc9f84d385099">setKinematic</a> (const yarp::sig::Vector &amp;w0, const yarp::sig::Vector &amp;dw0, const yarp::sig::Vector &amp;ddp0)</td></tr>
<tr class="memdesc:a79709f8d1a4f08a3967bc9f84d385099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the kinematic variables (w,dw,ddp) of the limb.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a79709f8d1a4f08a3967bc9f84d385099">More...</a><br /></td></tr>
<tr class="separator:a79709f8d1a4f08a3967bc9f84d385099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad193e52b6df7ca1a93e0323c3aff7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a9ad193e52b6df7ca1a93e0323c3aff7e">setKinematicMeasure</a> (const yarp::sig::Vector &amp;w0, const yarp::sig::Vector &amp;dw0, const yarp::sig::Vector &amp;ddp0)</td></tr>
<tr class="memdesc:a9ad193e52b6df7ca1a93e0323c3aff7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the kinematic variables (w,dw,ddp) of the limb, coming from external measurements (ie a sensor).  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a9ad193e52b6df7ca1a93e0323c3aff7e">More...</a><br /></td></tr>
<tr class="separator:a9ad193e52b6df7ca1a93e0323c3aff7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446842ff27342ac0b7038431d1962af9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a446842ff27342ac0b7038431d1962af9">setWrench</a> (const yarp::sig::Vector &amp;F0, const yarp::sig::Vector &amp;Mu0)</td></tr>
<tr class="memdesc:a446842ff27342ac0b7038431d1962af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wrench variables (F,Mu) of the limb.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a446842ff27342ac0b7038431d1962af9">More...</a><br /></td></tr>
<tr class="separator:a446842ff27342ac0b7038431d1962af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac618875f5ab8078cc0b6b57cde811a63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#ac618875f5ab8078cc0b6b57cde811a63">setWrenchMeasure</a> (const yarp::sig::Vector &amp;F0, const yarp::sig::Vector &amp;Mu0)</td></tr>
<tr class="memdesc:ac618875f5ab8078cc0b6b57cde811a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wrench variables (F,Mu) of the limb.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#ac618875f5ab8078cc0b6b57cde811a63">More...</a><br /></td></tr>
<tr class="separator:ac618875f5ab8078cc0b6b57cde811a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082f6a7879a585dfb94ecdfd15a469fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a082f6a7879a585dfb94ecdfd15a469fd">setWrenchMeasure</a> (<a class="el" href="classiCub_1_1iDyn_1_1iDynSensor.html">iDyn::iDynSensor</a> *sensor, const yarp::sig::Vector &amp;Fsens, const yarp::sig::Vector &amp;Musens)</td></tr>
<tr class="memdesc:a082f6a7879a585dfb94ecdfd15a469fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wrench variables in the sensor.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a082f6a7879a585dfb94ecdfd15a469fd">More...</a><br /></td></tr>
<tr class="separator:a082f6a7879a585dfb94ecdfd15a469fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0669b5ae83a5279fec00b147d6bf16"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a0d0669b5ae83a5279fec00b147d6bf16">getRBT</a> () const</td></tr>
<tr class="memdesc:a0d0669b5ae83a5279fec00b147d6bf16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the the (4x4) roto-translational matrix defining the rigid body transformation.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a0d0669b5ae83a5279fec00b147d6bf16">More...</a><br /></td></tr>
<tr class="separator:a0d0669b5ae83a5279fec00b147d6bf16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaee4f1a1a0faec8bd92e4650ab1be29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#aaaee4f1a1a0faec8bd92e4650ab1be29">getKinematic</a> (yarp::sig::Vector &amp;wNode, yarp::sig::Vector &amp;dwNode, yarp::sig::Vector &amp;ddpNode)</td></tr>
<tr class="memdesc:aaaee4f1a1a0faec8bd92e4650ab1be29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the kinematic variables (w,dw,ddp) of the limb, applies the RBT transformation and compute the kinematic variables of the node.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#aaaee4f1a1a0faec8bd92e4650ab1be29">More...</a><br /></td></tr>
<tr class="separator:aaaee4f1a1a0faec8bd92e4650ab1be29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddedfcbad2353f559fd20d4c91d8c26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a2ddedfcbad2353f559fd20d4c91d8c26">getWrench</a> (yarp::sig::Vector &amp;FNode, yarp::sig::Vector &amp;MuNode)</td></tr>
<tr class="memdesc:a2ddedfcbad2353f559fd20d4c91d8c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the wrench variables (F,Mu) of the limb, transform it according to the RBT and add it to the node wrench.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a2ddedfcbad2353f559fd20d4c91d8c26">More...</a><br /></td></tr>
<tr class="separator:a2ddedfcbad2353f559fd20d4c91d8c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde160f50b68418e78fa1c80e7be862d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#acde160f50b68418e78fa1c80e7be862d">setInfoFlow</a> (const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a> kin, const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a> wre)</td></tr>
<tr class="memdesc:acde160f50b68418e78fa1c80e7be862d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flow of kinematic/wrench information: input to node or output from node.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#acde160f50b68418e78fa1c80e7be862d">More...</a><br /></td></tr>
<tr class="separator:acde160f50b68418e78fa1c80e7be862d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4b00e8e88f4fe7a688e9eef6a883d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#aec4b00e8e88f4fe7a688e9eef6a883d3">getKinematicFlow</a> () const</td></tr>
<tr class="memdesc:aec4b00e8e88f4fe7a688e9eef6a883d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the kinematic flow type.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#aec4b00e8e88f4fe7a688e9eef6a883d3">More...</a><br /></td></tr>
<tr class="separator:aec4b00e8e88f4fe7a688e9eef6a883d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d388ef8190f1b4ce47e5a01cd3cb7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a03d388ef8190f1b4ce47e5a01cd3cb7d">getWrenchFlow</a> () const</td></tr>
<tr class="memdesc:a03d388ef8190f1b4ce47e5a01cd3cb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the wrench flow type  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a03d388ef8190f1b4ce47e5a01cd3cb7d">More...</a><br /></td></tr>
<tr class="separator:a03d388ef8190f1b4ce47e5a01cd3cb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8878df6b0dfa644d6e46bb24c7b25bdb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a8878df6b0dfa644d6e46bb24c7b25bdb">toString</a> () const</td></tr>
<tr class="memdesc:a8878df6b0dfa644d6e46bb24c7b25bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return some information.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a8878df6b0dfa644d6e46bb24c7b25bdb">More...</a><br /></td></tr>
<tr class="separator:a8878df6b0dfa644d6e46bb24c7b25bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77d074631ef29a085b0b1b96782cb2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#ac77d074631ef29a085b0b1b96782cb2f">isSensorized</a> () const</td></tr>
<tr class="memdesc:ac77d074631ef29a085b0b1b96782cb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean, depending if the limb attached to the RBT has a FT sensor or not.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#ac77d074631ef29a085b0b1b96782cb2f">More...</a><br /></td></tr>
<tr class="separator:ac77d074631ef29a085b0b1b96782cb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60387902fbaed00957b928c7374ef731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a60387902fbaed00957b928c7374ef731">computeLimbKinematic</a> ()</td></tr>
<tr class="memdesc:a60387902fbaed00957b928c7374ef731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the compute kinematic of the limb.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a60387902fbaed00957b928c7374ef731">More...</a><br /></td></tr>
<tr class="separator:a60387902fbaed00957b928c7374ef731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510b8466eb8b8ddefe6d8ebb9e3e22d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a510b8466eb8b8ddefe6d8ebb9e3e22d0">computeLimbWrench</a> ()</td></tr>
<tr class="memdesc:a510b8466eb8b8ddefe6d8ebb9e3e22d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the compute wrench of the limb.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a510b8466eb8b8ddefe6d8ebb9e3e22d0">More...</a><br /></td></tr>
<tr class="separator:a510b8466eb8b8ddefe6d8ebb9e3e22d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d0c3e6e09e0aff9cca1c475ec4f8a4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#ae5d0c3e6e09e0aff9cca1c475ec4f8a4">getNLinks</a> () const</td></tr>
<tr class="memdesc:ae5d0c3e6e09e0aff9cca1c475ec4f8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of links of the limb (N)  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#ae5d0c3e6e09e0aff9cca1c475ec4f8a4">More...</a><br /></td></tr>
<tr class="separator:ae5d0c3e6e09e0aff9cca1c475ec4f8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4857ec5e8c4d9d5dc40deb64638f69"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a9d4857ec5e8c4d9d5dc40deb64638f69">getDOF</a> () const</td></tr>
<tr class="memdesc:a9d4857ec5e8c4d9d5dc40deb64638f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of DOF of the limb (DOF &lt;= N)  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a9d4857ec5e8c4d9d5dc40deb64638f69">More...</a><br /></td></tr>
<tr class="separator:a9d4857ec5e8c4d9d5dc40deb64638f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d18b707dbcbc278c05c21b766087f2"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a44d18b707dbcbc278c05c21b766087f2">getH</a> (const unsigned int i, const bool allLink=false)</td></tr>
<tr class="memdesc:a44d18b707dbcbc278c05c21b766087f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i-th roto-translational matrix of the chain.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a44d18b707dbcbc278c05c21b766087f2">More...</a><br /></td></tr>
<tr class="separator:a44d18b707dbcbc278c05c21b766087f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34571a561fce0a0d612d557de21a221e"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a34571a561fce0a0d612d557de21a221e">getH</a> ()</td></tr>
<tr class="memdesc:a34571a561fce0a0d612d557de21a221e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the end-effector roto-translational matrix of the end-effector H of the end-effector.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a34571a561fce0a0d612d557de21a221e">More...</a><br /></td></tr>
<tr class="separator:a34571a561fce0a0d612d557de21a221e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dfa5ce66d4ed1a41a57ab95469ce92"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a09dfa5ce66d4ed1a41a57ab95469ce92">getEndEffPose</a> (const bool axisRep=true)</td></tr>
<tr class="memdesc:a09dfa5ce66d4ed1a41a57ab95469ce92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the end-effector pose: x-y-z Cartesian position and 3/4 angles of orientation.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a09dfa5ce66d4ed1a41a57ab95469ce92">More...</a><br /></td></tr>
<tr class="separator:a09dfa5ce66d4ed1a41a57ab95469ce92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466fd214c5e8f43eb1ae1c03f789bcff"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a466fd214c5e8f43eb1ae1c03f789bcff">computeGeoJacobian</a> (const unsigned int iLink, const yarp::sig::Matrix &amp;Pn, bool rbtRoto=false)</td></tr>
<tr class="memdesc:a466fd214c5e8f43eb1ae1c03f789bcff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to compute the Jacobian between two links in two different chains (eg from link 4 in chain_A to link 3 in chain_B.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a466fd214c5e8f43eb1ae1c03f789bcff">More...</a><br /></td></tr>
<tr class="separator:a466fd214c5e8f43eb1ae1c03f789bcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777a2037b5bafecca3b8cb9bc4b7db48"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a777a2037b5bafecca3b8cb9bc4b7db48">computeGeoJacobian</a> (const unsigned int iLink, const yarp::sig::Matrix &amp;Pn, const yarp::sig::Matrix &amp;H0, bool rbtRoto=false)</td></tr>
<tr class="memdesc:a777a2037b5bafecca3b8cb9bc4b7db48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to compute the Jacobian between two links in two different chains.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a777a2037b5bafecca3b8cb9bc4b7db48">More...</a><br /></td></tr>
<tr class="separator:a777a2037b5bafecca3b8cb9bc4b7db48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1b697ce90bab1671c8b9494cb211cd"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a4f1b697ce90bab1671c8b9494cb211cd">computeGeoJacobian</a> (const yarp::sig::Matrix &amp;Pn, bool rbtRoto=false)</td></tr>
<tr class="memdesc:a4f1b697ce90bab1671c8b9494cb211cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to compute the Jacobian between two links in two different chains: in this case it returns the jacobian matrix of the whole chain (from base to end-effector) when Pn is an external vector.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a4f1b697ce90bab1671c8b9494cb211cd">More...</a><br /></td></tr>
<tr class="separator:a4f1b697ce90bab1671c8b9494cb211cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6152545d4dbe90b56f3da72babab2f85"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a6152545d4dbe90b56f3da72babab2f85">computeGeoJacobian</a> (const yarp::sig::Matrix &amp;Pn, const yarp::sig::Matrix &amp;H0, bool rbtRoto=false)</td></tr>
<tr class="memdesc:a6152545d4dbe90b56f3da72babab2f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used to compute the Jacobian between two links in two different chains: in this case it returns the jacobian matrix of the whole chain (from base to end-effector) when Pn is an external vector, and H0 is an external matrix.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a6152545d4dbe90b56f3da72babab2f85">More...</a><br /></td></tr>
<tr class="separator:a6152545d4dbe90b56f3da72babab2f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15c45b5cac81fd7d1021bbe6e9437fd"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#ad15c45b5cac81fd7d1021bbe6e9437fd">computeGeoJacobian</a> (bool rbtRoto=false)</td></tr>
<tr class="separator:ad15c45b5cac81fd7d1021bbe6e9437fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4ad48c3b09c2dd848e3d4fa2b228bb"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a6b4ad48c3b09c2dd848e3d4fa2b228bb">computeGeoJacobian</a> (const unsigned int iLink, bool rbtRoto=false)</td></tr>
<tr class="memdesc:a6b4ad48c3b09c2dd848e3d4fa2b228bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Jacobian matrix of the limb until the link whose index is iLink in the chain.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a6b4ad48c3b09c2dd848e3d4fa2b228bb">More...</a><br /></td></tr>
<tr class="separator:a6b4ad48c3b09c2dd848e3d4fa2b228bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579bae70aac32bb3c7c4f86055fd90d3"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a579bae70aac32bb3c7c4f86055fd90d3">getR6</a> () const</td></tr>
<tr class="memdesc:a579bae70aac32bb3c7c4f86055fd90d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 6x6 diagonal matrix with the rotational matrix of the RBT.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a579bae70aac32bb3c7c4f86055fd90d3">More...</a><br /></td></tr>
<tr class="separator:a579bae70aac32bb3c7c4f86055fd90d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9788253b025ba3d0bf4d126a3600ae8e"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a9788253b025ba3d0bf4d126a3600ae8e">getH0</a> () const</td></tr>
<tr class="memdesc:a9788253b025ba3d0bf4d126a3600ae8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the H0 matrix of the limb attached to the RBT.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a9788253b025ba3d0bf4d126a3600ae8e">More...</a><br /></td></tr>
<tr class="separator:a9788253b025ba3d0bf4d126a3600ae8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb87e7d550cc7673991642b2d9da1296"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#aeb87e7d550cc7673991642b2d9da1296">setH0</a> (const yarp::sig::Matrix &amp;_H0)</td></tr>
<tr class="memdesc:aeb87e7d550cc7673991642b2d9da1296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new H0 matrix in the limb attached to the RBT.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#aeb87e7d550cc7673991642b2d9da1296">More...</a><br /></td></tr>
<tr class="separator:aeb87e7d550cc7673991642b2d9da1296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06377b1a58d8b36cb3959f5ffbf3098"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#aa06377b1a58d8b36cb3959f5ffbf3098">TESTING_computeCOMJacobian</a> (const unsigned int iLink, bool rbtRoto=false)</td></tr>
<tr class="memdesc:aa06377b1a58d8b36cb3959f5ffbf3098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Jacobian matrix of the COM of the selected link (index = iLink) in the chain.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#aa06377b1a58d8b36cb3959f5ffbf3098">More...</a><br /></td></tr>
<tr class="separator:aa06377b1a58d8b36cb3959f5ffbf3098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d41231ec6a47503a3455e17364f9d69"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a0d41231ec6a47503a3455e17364f9d69">TESTING_computeCOMJacobian</a> (const unsigned int iLink, const yarp::sig::Matrix &amp;Pn, bool rbtRoto=false)</td></tr>
<tr class="memdesc:a0d41231ec6a47503a3455e17364f9d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Jacobian matrix of the COM of the selected link (index = iLink) in the chain: in this case Pn is an external vector, that happens when multiple limbs are connected.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a0d41231ec6a47503a3455e17364f9d69">More...</a><br /></td></tr>
<tr class="separator:a0d41231ec6a47503a3455e17364f9d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7458f6f33cff0d650730edba1ce1121"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#ae7458f6f33cff0d650730edba1ce1121">TESTING_computeCOMJacobian</a> (const unsigned int iLink, const yarp::sig::Matrix &amp;Pn, const yarp::sig::Matrix &amp;_H0, bool rbtRoto=false)</td></tr>
<tr class="memdesc:ae7458f6f33cff0d650730edba1ce1121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Jacobian matrix of the COM of the selected link (index = iLink) in the chain: in this case Pn is an external vector, that happens when multiple limbs are connected.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#ae7458f6f33cff0d650730edba1ce1121">More...</a><br /></td></tr>
<tr class="separator:ae7458f6f33cff0d650730edba1ce1121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bff0a662e3869684609409f32758c1"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a54bff0a662e3869684609409f32758c1">getHCOM</a> (unsigned int iLink)</td></tr>
<tr class="memdesc:a54bff0a662e3869684609409f32758c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the COM matrix of the selected link (index = iLink) in the chain.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a54bff0a662e3869684609409f32758c1">More...</a><br /></td></tr>
<tr class="separator:a54bff0a662e3869684609409f32758c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9134eff749e497f6ba5667c5b6cd1e82"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a9134eff749e497f6ba5667c5b6cd1e82">getR</a> ()</td></tr>
<tr class="memdesc:a9134eff749e497f6ba5667c5b6cd1e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the rotational 3x3 matrix of the RBT.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a9134eff749e497f6ba5667c5b6cd1e82">More...</a><br /></td></tr>
<tr class="separator:a9134eff749e497f6ba5667c5b6cd1e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64732759f877cd1269dfb2801542668d"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a64732759f877cd1269dfb2801542668d">getr</a> (bool proj=false)</td></tr>
<tr class="memdesc:a64732759f877cd1269dfb2801542668d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the translational part of the RBT matrix.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a64732759f877cd1269dfb2801542668d">More...</a><br /></td></tr>
<tr class="separator:a64732759f877cd1269dfb2801542668d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb767b90993edac1cd25cc5c10ebcea2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#aeb767b90993edac1cd25cc5c10ebcea2">computeKinematic</a> ()</td></tr>
<tr class="memdesc:aeb767b90993edac1cd25cc5c10ebcea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic computations for applying RBT on kinematic variables.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#aeb767b90993edac1cd25cc5c10ebcea2">More...</a><br /></td></tr>
<tr class="separator:aeb767b90993edac1cd25cc5c10ebcea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd1a40f4c0d82fe7d85fd04cd5672eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a7bd1a40f4c0d82fe7d85fd04cd5672eb">computeWrench</a> ()</td></tr>
<tr class="memdesc:a7bd1a40f4c0d82fe7d85fd04cd5672eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic computations for applying RBT on wrench variables.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a7bd1a40f4c0d82fe7d85fd04cd5672eb">More...</a><br /></td></tr>
<tr class="separator:a7bd1a40f4c0d82fe7d85fd04cd5672eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2dde2d3c67543ba964671deb5c43bb65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classiCub_1_1iDyn_1_1iDynLimb.html">iDyn::iDynLimb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a2dde2d3c67543ba964671deb5c43bb65">limb</a></td></tr>
<tr class="memdesc:a2dde2d3c67543ba964671deb5c43bb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">the limb attached to the <a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html" title="A class for setting a rigid body transformation between iDynLimb and iDynNode.">RigidBodyTransformation</a>  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a2dde2d3c67543ba964671deb5c43bb65">More...</a><br /></td></tr>
<tr class="separator:a2dde2d3c67543ba964671deb5c43bb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bd8812748a8e66e8131d82fd150f13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a24bd8812748a8e66e8131d82fd150f13">kinFlow</a></td></tr>
<tr class="memdesc:a24bd8812748a8e66e8131d82fd150f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">kinematic flow: in-to/out-from node (RBT_NODE_IN/RBT_NODE_OUT)  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a24bd8812748a8e66e8131d82fd150f13">More...</a><br /></td></tr>
<tr class="separator:a24bd8812748a8e66e8131d82fd150f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e8a741b3c683e87aa3f8b5e391be81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a66e8a741b3c683e87aa3f8b5e391be81">wreFlow</a></td></tr>
<tr class="memdesc:a66e8a741b3c683e87aa3f8b5e391be81"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrench flow: in-to/out-from node (RBT_NODE_IN/RBT_NODE_OUT)  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a66e8a741b3c683e87aa3f8b5e391be81">More...</a><br /></td></tr>
<tr class="separator:a66e8a741b3c683e87aa3f8b5e391be81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29201c4b2592828a197e3028541bf664"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a29201c4b2592828a197e3028541bf664">H</a></td></tr>
<tr class="memdesc:a29201c4b2592828a197e3028541bf664"><td class="mdescLeft">&#160;</td><td class="mdescRight">the roto-translation between the limb and the node  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a29201c4b2592828a197e3028541bf664">More...</a><br /></td></tr>
<tr class="separator:a29201c4b2592828a197e3028541bf664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b28de4940603b5a0dd08a2bab85655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a05b28de4940603b5a0dd08a2bab85655">mode</a></td></tr>
<tr class="memdesc:a05b28de4940603b5a0dd08a2bab85655"><td class="mdescLeft">&#160;</td><td class="mdescRight">STATIC/DYNAMIC/DYNAMIC_W_ROTOR/DYNAMIC_CORIOLIS_GRAVITY.  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a05b28de4940603b5a0dd08a2bab85655">More...</a><br /></td></tr>
<tr class="separator:a05b28de4940603b5a0dd08a2bab85655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad40ce607c44de7f6c73995066b62116"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#aad40ce607c44de7f6c73995066b62116">info</a></td></tr>
<tr class="memdesc:aad40ce607c44de7f6c73995066b62116"><td class="mdescLeft">&#160;</td><td class="mdescRight">info or useful notes  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#aad40ce607c44de7f6c73995066b62116">More...</a><br /></td></tr>
<tr class="separator:aad40ce607c44de7f6c73995066b62116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e004d4923c2e7a9e910119947816189"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a8e004d4923c2e7a9e910119947816189">verbose</a></td></tr>
<tr class="memdesc:a8e004d4923c2e7a9e910119947816189"><td class="mdescLeft">&#160;</td><td class="mdescRight">verbosity flag  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a8e004d4923c2e7a9e910119947816189">More...</a><br /></td></tr>
<tr class="separator:a8e004d4923c2e7a9e910119947816189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedce5df05fbe534364870f4a21bc1b9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#aedce5df05fbe534364870f4a21bc1b9c">hasSensor</a></td></tr>
<tr class="memdesc:aedce5df05fbe534364870f4a21bc1b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for sensor or not - only used for setWrenchMeasures()  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#aedce5df05fbe534364870f4a21bc1b9c">More...</a><br /></td></tr>
<tr class="separator:aedce5df05fbe534364870f4a21bc1b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f467c5e26858e176afe11c793ab0ba"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a90f467c5e26858e176afe11c793ab0ba">w</a></td></tr>
<tr class="memdesc:a90f467c5e26858e176afe11c793ab0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">angular velocity  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a90f467c5e26858e176afe11c793ab0ba">More...</a><br /></td></tr>
<tr class="separator:a90f467c5e26858e176afe11c793ab0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63125929644ba5c382abbdfc2214ce5"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#ab63125929644ba5c382abbdfc2214ce5">dw</a></td></tr>
<tr class="memdesc:ab63125929644ba5c382abbdfc2214ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">angular acceleration  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#ab63125929644ba5c382abbdfc2214ce5">More...</a><br /></td></tr>
<tr class="separator:ab63125929644ba5c382abbdfc2214ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074db03771f7a46286d56cbf72e064e4"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a074db03771f7a46286d56cbf72e064e4">ddp</a></td></tr>
<tr class="memdesc:a074db03771f7a46286d56cbf72e064e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear acceleration  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a074db03771f7a46286d56cbf72e064e4">More...</a><br /></td></tr>
<tr class="separator:a074db03771f7a46286d56cbf72e064e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d800b1fc1df3f2e245a3d713695351"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a39d800b1fc1df3f2e245a3d713695351">F</a></td></tr>
<tr class="memdesc:a39d800b1fc1df3f2e245a3d713695351"><td class="mdescLeft">&#160;</td><td class="mdescRight">force  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a39d800b1fc1df3f2e245a3d713695351">More...</a><br /></td></tr>
<tr class="separator:a39d800b1fc1df3f2e245a3d713695351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922866e0f889ea54732300e9c4e6e164"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a922866e0f889ea54732300e9c4e6e164">Mu</a></td></tr>
<tr class="memdesc:a922866e0f889ea54732300e9c4e6e164"><td class="mdescLeft">&#160;</td><td class="mdescRight">moment  <a href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html#a922866e0f889ea54732300e9c4e6e164">More...</a><br /></td></tr>
<tr class="separator:a922866e0f889ea54732300e9c4e6e164"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for setting a rigid body transformation between <a class="el" href="classiCub_1_1iDyn_1_1iDynLimb.html" title="A class for defining a generic Limb within the iDyn framework.">iDynLimb</a> and <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html" title="A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between l...">iDynNode</a>. </p>
<p>This class is used by <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html" title="A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between l...">iDynNode</a> to connect two or mutiple limbs and exchanging kinematic and wrench information between limbs. </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00131">131</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a95f03fa5b0fb644aff65c9e9130ed92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f03fa5b0fb644aff65c9e9130ed92b">&#9670;&nbsp;</a></span>RigidBodyTransformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RigidBodyTransformation::RigidBodyTransformation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiCub_1_1iDyn_1_1iDynLimb.html">iDyn::iDynLimb</a> *&#160;</td>
          <td class="paramname"><em>_limb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>_H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_hasSensor</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a>&#160;</td>
          <td class="paramname"><em>kin</em> = <code><a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a2ade845ecc299911bc2906e1e2539064">RBT_NODE_OUT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a>&#160;</td>
          <td class="paramname"><em>wre</em> = <code><a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a733307f2252a4e82441f412c04653a29">RBT_NODE_IN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a>&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3">DYNAMIC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>verb</em> = <code><a class="el" href="namespaceiCub_1_1skinDynLib.html#a790824a527802db93c40eca73839b72da16220311c35a0345c00855ea2032c695">iCub::skinDynLib::VERBOSE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor, defining the limb attached to the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_limb</td><td>pointer to a <a class="el" href="classiCub_1_1iDyn_1_1iDynLimb.html" title="A class for defining a generic Limb within the iDyn framework.">iDynLimb</a> </td></tr>
    <tr><td class="paramname">_H</td><td>a (4x4) roto-translational matrix defining the rigid body transformation </td></tr>
    <tr><td class="paramname">_info</td><td>a string with information </td></tr>
    <tr><td class="paramname">kin</td><td>the kinematic flow </td></tr>
    <tr><td class="paramname">wre</td><td>the wrench flow </td></tr>
    <tr><td class="paramname">_mode</td><td>the NewEulMode for computations </td></tr>
    <tr><td class="paramname">verb</td><td>verbosity flag </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00044">44</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="aa113bf7d5f80d2616340ba970470e561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa113bf7d5f80d2616340ba970470e561">&#9670;&nbsp;</a></span>~RigidBodyTransformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RigidBodyTransformation::~RigidBodyTransformation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00061">61</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad15c45b5cac81fd7d1021bbe6e9437fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15c45b5cac81fd7d1021bbe6e9437fd">&#9670;&nbsp;</a></span>computeGeoJacobian() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix RigidBodyTransformation::computeGeoJacobian </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rbtRoto</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rbtRoto</td><td>if false, simply return Jacobian; if true return T * Jacobian, where T is a 6x6 diagonal matrix with the rotational part of the RBT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix of the chain </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00345">345</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a6b4ad48c3b09c2dd848e3d4fa2b228bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4ad48c3b09c2dd848e3d4fa2b228bb">&#9670;&nbsp;</a></span>computeGeoJacobian() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix RigidBodyTransformation::computeGeoJacobian </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>iLink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rbtRoto</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Jacobian matrix of the limb until the link whose index is iLink in the chain. </p>
<p>This method basically calls GeoJacobian(iLink) in the <a class="el" href="classiCub_1_1iDyn_1_1iDynChain.html" title="A Base class for defining a Serial Link Chain, using dynamics and kinematics.">iDynChain</a> of the limb. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iLink</td><td>the index of the link, in the chain </td></tr>
    <tr><td class="paramname">rbtRoto</td><td>if false, simply return Jacobian; if true return T * Jacobian, where T is a 6x6 diagonal matrix with the rotational part of the RBT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix of the chain - from the base to the i-th link </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00353">353</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a466fd214c5e8f43eb1ae1c03f789bcff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466fd214c5e8f43eb1ae1c03f789bcff">&#9670;&nbsp;</a></span>computeGeoJacobian() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Matrix iCub::iDyn::RigidBodyTransformation::computeGeoJacobian </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>iLink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>Pn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rbtRoto</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is used to compute the Jacobian between two links in two different chains (eg from link 4 in chain_A to link 3 in chain_B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iLink</td><td>the index of the link, in the chain, being the base frame for the Jacobian computation </td></tr>
    <tr><td class="paramname">Pn</td><td>the matrix describing the roto-translational matrix between base and end-effector (in two different limbs) </td></tr>
    <tr><td class="paramname">rbtRoto</td><td>if false, simply return Jacobian; if true return T * Jacobian, where T is a 6x6 diagonal matrix with the rotational part of the RBT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix from the base of the chain until the iLink (e.g. from link 0 to 4) </dd></dl>

</div>
</div>
<a id="a777a2037b5bafecca3b8cb9bc4b7db48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777a2037b5bafecca3b8cb9bc4b7db48">&#9670;&nbsp;</a></span>computeGeoJacobian() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Matrix iCub::iDyn::RigidBodyTransformation::computeGeoJacobian </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>iLink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>Pn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>H0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rbtRoto</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is used to compute the Jacobian between two links in two different chains. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iLink</td><td>the index of the link, in the chain, being the base frame for the Jacobian computation </td></tr>
    <tr><td class="paramname">Pn</td><td>the matrix describing the roto-translational matrix between base and end-effector (in two different limbs) </td></tr>
    <tr><td class="paramname">H0</td><td>the H0 matrix of the base to be used for the Jacobian computation </td></tr>
    <tr><td class="paramname">rbtRoto</td><td>if false, simply return Jacobian; if true return T * Jacobian, where T is a 6x6 diagonal matrix with the rotational part of the RBT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix from the iLink of the chain until the base of the chain (ie from link 4 to 0) </dd></dl>

</div>
</div>
<a id="a4f1b697ce90bab1671c8b9494cb211cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1b697ce90bab1671c8b9494cb211cd">&#9670;&nbsp;</a></span>computeGeoJacobian() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Matrix iCub::iDyn::RigidBodyTransformation::computeGeoJacobian </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>Pn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rbtRoto</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is used to compute the Jacobian between two links in two different chains: in this case it returns the jacobian matrix of the whole chain (from base to end-effector) when Pn is an external vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Pn</td><td>the matrix describing the roto-translational matrix between base and end-effector (in two different limbs) </td></tr>
    <tr><td class="paramname">rbtRoto</td><td>if false, simply return Jacobian; if true return T * Jacobian, where T is a 6x6 diagonal matrix with the rotational part of the RBT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix of the chain </dd></dl>

</div>
</div>
<a id="a6152545d4dbe90b56f3da72babab2f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6152545d4dbe90b56f3da72babab2f85">&#9670;&nbsp;</a></span>computeGeoJacobian() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Matrix iCub::iDyn::RigidBodyTransformation::computeGeoJacobian </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>Pn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>H0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rbtRoto</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is used to compute the Jacobian between two links in two different chains: in this case it returns the jacobian matrix of the whole chain (from base to end-effector) when Pn is an external vector, and H0 is an external matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Pn</td><td>the matrix describing the roto-translational matrix between base and end-effector (in two different limbs) </td></tr>
    <tr><td class="paramname">H0</td><td>the H0 matrix of the base to be used for the Jacobian computation </td></tr>
    <tr><td class="paramname">rbtRoto</td><td>if false, simply return Jacobian; if true return T * Jacobian, where T is a 6x6 diagonal matrix with the rotational part of the RBT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix of the chain </dd></dl>

</div>
</div>
<a id="aeb767b90993edac1cd25cc5c10ebcea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb767b90993edac1cd25cc5c10ebcea2">&#9670;&nbsp;</a></span>computeKinematic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RigidBodyTransformation::computeKinematic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Basic computations for applying RBT on kinematic variables. </p>
<p>The computations are similar to the Forward/Backward ones in <a class="el" href="classiCub_1_1iDyn_1_1OneLinkNewtonEuler.html" title="A base class for computing forces and torques in a serial link chain.">OneLinkNewtonEuler</a>: compute AngVel/AngAcc/LinAcc. Here they are fastened and adapted to the RBT. <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00195">195</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a60387902fbaed00957b928c7374ef731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60387902fbaed00957b928c7374ef731">&#9670;&nbsp;</a></span>computeLimbKinematic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RigidBodyTransformation::computeLimbKinematic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the compute kinematic of the limb. </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00278">278</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a510b8466eb8b8ddefe6d8ebb9e3e22d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510b8466eb8b8ddefe6d8ebb9e3e22d0">&#9670;&nbsp;</a></span>computeLimbWrench()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RigidBodyTransformation::computeLimbWrench </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the compute wrench of the limb. </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00283">283</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a7bd1a40f4c0d82fe7d85fd04cd5672eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd1a40f4c0d82fe7d85fd04cd5672eb">&#9670;&nbsp;</a></span>computeWrench()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RigidBodyTransformation::computeWrench </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Basic computations for applying RBT on wrench variables. </p>
<p>The computations are similar to the Forward/Backward ones in <a class="el" href="classiCub_1_1iDyn_1_1OneLinkNewtonEuler.html" title="A base class for computing forces and torques in a serial link chain.">OneLinkNewtonEuler</a>: compute Force/Moment. Here they are fastened and adapted to the RBT. </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00246">246</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a9d4857ec5e8c4d9d5dc40deb64638f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4857ec5e8c4d9d5dc40deb64638f69">&#9670;&nbsp;</a></span>getDOF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int RigidBodyTransformation::getDOF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of DOF of the limb (DOF &lt;= N) </p>
<dl class="section return"><dt>Returns</dt><dd>the number of DOF in the limb </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00293">293</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a09dfa5ce66d4ed1a41a57ab95469ce92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09dfa5ce66d4ed1a41a57ab95469ce92">&#9670;&nbsp;</a></span>getEndEffPose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector RigidBodyTransformation::getEndEffPose </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>axisRep</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the end-effector pose: x-y-z Cartesian position and 3/4 angles of orientation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axisRep</td><td>a flag for the axis representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the end effector pose </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00308">308</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a34571a561fce0a0d612d557de21a221e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34571a561fce0a0d612d557de21a221e">&#9670;&nbsp;</a></span>getH() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix RigidBodyTransformation::getH </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the end-effector roto-translational matrix of the end-effector H of the end-effector. </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00303">303</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a44d18b707dbcbc278c05c21b766087f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d18b707dbcbc278c05c21b766087f2">&#9670;&nbsp;</a></span>getH() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix RigidBodyTransformation::getH </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allLink</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the i-th roto-translational matrix of the chain. </p>
<p>This method basically calls iKinChain::getH(i,allLink). the boolean allLink specifies if all the links are considered, or only the unblocked ones (DOF) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the link index in the chain (0&lt;=i&lt;N) </td></tr>
    <tr><td class="paramname">allLink</td><td>if all the links are considered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>H of the i-th link </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00298">298</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a9788253b025ba3d0bf4d126a3600ae8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9788253b025ba3d0bf4d126a3600ae8e">&#9670;&nbsp;</a></span>getH0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix RigidBodyTransformation::getH0 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the H0 matrix of the limb attached to the RBT. </p>
<dl class="section return"><dt>Returns</dt><dd>the H0 matrix of the limb attached to the RBT </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00361">361</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a54bff0a662e3869684609409f32758c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bff0a662e3869684609409f32758c1">&#9670;&nbsp;</a></span>getHCOM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix RigidBodyTransformation::getHCOM </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iLink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the COM matrix of the selected link (index = iLink) in the chain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iLink</td><td>the index of the link, in the chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the roto-translational matrix of the selected link COM </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00401">401</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="aaaee4f1a1a0faec8bd92e4650ab1be29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaee4f1a1a0faec8bd92e4650ab1be29">&#9670;&nbsp;</a></span>getKinematic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RigidBodyTransformation::getKinematic </td>
          <td>(</td>
          <td class="paramtype">yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>wNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>dwNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>ddpNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the kinematic variables (w,dw,ddp) of the limb, applies the RBT transformation and compute the kinematic variables of the node. </p>
<p>The variables are stored into the param vectors, which are accessible. This method calls getKinematicNewtonEuler() in the limb, and the limb itself knows whether to get this information in the base or in the end- effector, depending on its iteration mode for kinematics. This method is used by <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html" title="A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between l...">iDynNode</a> to connect two or multiple limbs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wNode</td><td>the angular velocity of the Node - it is modified! </td></tr>
    <tr><td class="paramname">dwNode</td><td>the angular acceleration of the Node - it is modified! </td></tr>
    <tr><td class="paramname">ddpNode</td><td>the linear acceleration of the Node - it is modified! </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00152">152</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="aec4b00e8e88f4fe7a688e9eef6a883d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4b00e8e88f4fe7a688e9eef6a883d3">&#9670;&nbsp;</a></span>getKinematicFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a> RigidBodyTransformation::getKinematicFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the kinematic flow type. </p>
<dl class="section return"><dt>Returns</dt><dd>the kinematic flow </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00185">185</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="ae5d0c3e6e09e0aff9cca1c475ec4f8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d0c3e6e09e0aff9cca1c475ec4f8a4">&#9670;&nbsp;</a></span>getNLinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int RigidBodyTransformation::getNLinks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of links of the limb (N) </p>
<dl class="section return"><dt>Returns</dt><dd>the number of links in the limb </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00288">288</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a9134eff749e497f6ba5667c5b6cd1e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9134eff749e497f6ba5667c5b6cd1e82">&#9670;&nbsp;</a></span>getR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix RigidBodyTransformation::getR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the rotational 3x3 matrix of the RBT. </p>
<dl class="section return"><dt>Returns</dt><dd>the rotational matrix of the RBT </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00126">126</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a64732759f877cd1269dfb2801542668d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64732759f877cd1269dfb2801542668d">&#9670;&nbsp;</a></span>getr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector RigidBodyTransformation::getr </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>proj</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the translational part of the RBT matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proj=true/false</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance vector of the RBT </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00145">145</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a579bae70aac32bb3c7c4f86055fd90d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579bae70aac32bb3c7c4f86055fd90d3">&#9670;&nbsp;</a></span>getR6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix RigidBodyTransformation::getR6 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a 6x6 diagonal matrix with the rotational matrix of the RBT. </p>
<dl class="section return"><dt>Returns</dt><dd>a 6x6 diagonal matrix with the rotational matrix of the RBT </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00131">131</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a0d0669b5ae83a5279fec00b147d6bf16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0669b5ae83a5279fec00b147d6bf16">&#9670;&nbsp;</a></span>getRBT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix RigidBodyTransformation::getRBT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the the (4x4) roto-translational matrix defining the rigid body transformation. </p>
<dl class="section return"><dt>Returns</dt><dd>H, the 4x4 matrix of the RBT </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00121">121</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a2ddedfcbad2353f559fd20d4c91d8c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddedfcbad2353f559fd20d4c91d8c26">&#9670;&nbsp;</a></span>getWrench()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RigidBodyTransformation::getWrench </td>
          <td>(</td>
          <td class="paramtype">yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>FNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>MuNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the wrench variables (F,Mu) of the limb, transform it according to the RBT and add it to the node wrench. </p>
<p>The variables are stored into the param vectors, which are accessible. This method calls getWrenchNewtonEuler() in the limb, and the limb itself knows whether to get this information in the base ot in the end-effector, depending on its iteration mode for wrenches. This method is used by <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html" title="A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between l...">iDynNode</a> to connect two or multiple limbs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FNode</td><td>the <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html" title="A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between l...">iDynNode</a> force - it is modified! </td></tr>
    <tr><td class="paramname">MuNode</td><td>the <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html" title="A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between l...">iDynNode</a> moment - it is modified! </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00166">166</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a03d388ef8190f1b4ce47e5a01cd3cb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d388ef8190f1b4ce47e5a01cd3cb7d">&#9670;&nbsp;</a></span>getWrenchFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a> RigidBodyTransformation::getWrenchFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the wrench flow type </p>
<dl class="section return"><dt>Returns</dt><dd>the wrench flow </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00190">190</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="ac77d074631ef29a085b0b1b96782cb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77d074631ef29a085b0b1b96782cb2f">&#9670;&nbsp;</a></span>isSensorized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RigidBodyTransformation::isSensorized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean, depending if the limb attached to the RBT has a FT sensor or not. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the limb has a FT sensor, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00273">273</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="aeb87e7d550cc7673991642b2d9da1296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb87e7d550cc7673991642b2d9da1296">&#9670;&nbsp;</a></span>setH0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RigidBodyTransformation::setH0 </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>_H0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new H0 matrix in the limb attached to the RBT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_H0</td><td>the new H0 matrix of the limb attached to the RBT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeed, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00366">366</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="acde160f50b68418e78fa1c80e7be862d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde160f50b68418e78fa1c80e7be862d">&#9670;&nbsp;</a></span>setInfoFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RigidBodyTransformation::setInfoFlow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a>&#160;</td>
          <td class="paramname"><em>kin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a>&#160;</td>
          <td class="paramname"><em>wre</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the flow of kinematic/wrench information: input to node or output from node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kin</td><td>the kinematic flow </td></tr>
    <tr><td class="paramname">wre</td><td>the wrench flow </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00179">179</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a79709f8d1a4f08a3967bc9f84d385099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79709f8d1a4f08a3967bc9f84d385099">&#9670;&nbsp;</a></span>setKinematic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RigidBodyTransformation::setKinematic </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>w0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>dw0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>ddp0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the kinematic variables (w,dw,ddp) of the limb. </p>
<p>This method calls initKinematicNewtonEuler() in the limb, and the limb itself knows whether to set this information in the base or in the end- effector, depending on its iteration mode for kinematics. This method is used by <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html" title="A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between l...">iDynNode</a> to connect two or multiple limbs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w0</td><td>the angular velocity </td></tr>
    <tr><td class="paramname">dw0</td><td>the angular acceleration </td></tr>
    <tr><td class="paramname">ddp0</td><td>the linear acceleration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeds, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00083">83</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a9ad193e52b6df7ca1a93e0323c3aff7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad193e52b6df7ca1a93e0323c3aff7e">&#9670;&nbsp;</a></span>setKinematicMeasure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RigidBodyTransformation::setKinematicMeasure </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>w0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>dw0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>ddp0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the kinematic variables (w,dw,ddp) of the limb, coming from external measurements (ie a sensor). </p>
<p>This method calls initKinematicNewtonEuler() in the limb, and the limb itself knows whether to set this information in the base or in the end- effector, depending on its iteration mode for kinematics. This method is used by <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html" title="A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between l...">iDynNode</a> to connect two or multiple limbs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w0</td><td>the angular velocity </td></tr>
    <tr><td class="paramname">dw0</td><td>the angular acceleration </td></tr>
    <tr><td class="paramname">ddp0</td><td>the linear acceleration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeds, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00095">95</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a0d18283bf99c6cdb2196408213c663d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d18283bf99c6cdb2196408213c663d0">&#9670;&nbsp;</a></span>setRBT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RigidBodyTransformation::setRBT </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>_H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the roto-translational matrix between the limb and the node, defining the rigid body transformation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_H</td><td>a (4x4) roto-translational matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeds, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00067">67</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a446842ff27342ac0b7038431d1962af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446842ff27342ac0b7038431d1962af9">&#9670;&nbsp;</a></span>setWrench()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RigidBodyTransformation::setWrench </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>F0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>Mu0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the wrench variables (F,Mu) of the limb. </p>
<p>This method calls initWrenchNewtonEuler() in the limb, and the limb itself knows whether to set this information in the base ot in the end-effector, depending on its iteration mode for wrenches. This method is used by <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html" title="A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between l...">iDynNode</a> to connect two or multiple limbs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F0</td><td>the force </td></tr>
    <tr><td class="paramname">Mu0</td><td>the moment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeds, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00100">100</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="ac618875f5ab8078cc0b6b57cde811a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac618875f5ab8078cc0b6b57cde811a63">&#9670;&nbsp;</a></span>setWrenchMeasure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iCub::iDyn::RigidBodyTransformation::setWrenchMeasure </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>F0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>Mu0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the wrench variables (F,Mu) of the limb. </p>
<p>This method calls initWrenchNewtonEuler() in the limb, and the limb itself knows whether to set this information in the base ot in the end-effector, depending on its iteration mode for wrenches. This method is used by <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html" title="A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between l...">iDynNode</a> to connect two or multiple limbs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F0</td><td>the force </td></tr>
    <tr><td class="paramname">Mu0</td><td>the moment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeds, false otherwise </dd></dl>

</div>
</div>
<a id="a082f6a7879a585dfb94ecdfd15a469fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082f6a7879a585dfb94ecdfd15a469fd">&#9670;&nbsp;</a></span>setWrenchMeasure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iCub::iDyn::RigidBodyTransformation::setWrenchMeasure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiCub_1_1iDyn_1_1iDynSensor.html">iDyn::iDynSensor</a> *&#160;</td>
          <td class="paramname"><em>sensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>Fsens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>Musens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the wrench variables in the sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensor</td><td>the sensor attached to the limb </td></tr>
    <tr><td class="paramname">Fsens</td><td>the force </td></tr>
    <tr><td class="paramname">Musens</td><td>the moment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeds, false otherwise </dd></dl>

</div>
</div>
<a id="aa06377b1a58d8b36cb3959f5ffbf3098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06377b1a58d8b36cb3959f5ffbf3098">&#9670;&nbsp;</a></span>TESTING_computeCOMJacobian() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix RigidBodyTransformation::TESTING_computeCOMJacobian </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>iLink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rbtRoto</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Jacobian matrix of the COM of the selected link (index = iLink) in the chain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iLink</td><td>the index of the link, in the chain </td></tr>
    <tr><td class="paramname">rbtRoto</td><td>if false, simply return Jacobian; if true return T * Jacobian, where T is a 6x6 diagonal matrix with the rotational part of the RBT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix of the selected link COM </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00377">377</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a0d41231ec6a47503a3455e17364f9d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d41231ec6a47503a3455e17364f9d69">&#9670;&nbsp;</a></span>TESTING_computeCOMJacobian() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Matrix iCub::iDyn::RigidBodyTransformation::TESTING_computeCOMJacobian </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>iLink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>Pn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rbtRoto</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Jacobian matrix of the COM of the selected link (index = iLink) in the chain: in this case Pn is an external vector, that happens when multiple limbs are connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Pn</td><td>the matrix describing the roto-translational matrix between base and end-effector (in two different limbs) </td></tr>
    <tr><td class="paramname">iLink</td><td>the index of the link, in the chain </td></tr>
    <tr><td class="paramname">rbtRoto</td><td>if false, simply return Jacobian; if true return T * Jacobian, where T is a 6x6 diagonal matrix with the rotational part of the RBT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix of the selected link COM </dd></dl>

</div>
</div>
<a id="ae7458f6f33cff0d650730edba1ce1121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7458f6f33cff0d650730edba1ce1121">&#9670;&nbsp;</a></span>TESTING_computeCOMJacobian() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Matrix iCub::iDyn::RigidBodyTransformation::TESTING_computeCOMJacobian </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>iLink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>Pn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>_H0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rbtRoto</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Jacobian matrix of the COM of the selected link (index = iLink) in the chain: in this case Pn is an external vector, that happens when multiple limbs are connected. </p>
<p>The H0 matrix used to initialize the Jacobian computation is external too. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Pn</td><td>the matrix describing the roto-translational matrix between base and end-effector (in two different limbs) </td></tr>
    <tr><td class="paramname">H0</td><td>the H0 matrix of the base to be used for the Jacobian computation </td></tr>
    <tr><td class="paramname">iLink</td><td>the index of the link, in the chain </td></tr>
    <tr><td class="paramname">rbtRoto</td><td>if false, simply return Jacobian; if true return T * Jacobian, where T is a 6x6 diagonal matrix with the rotational part of the RBT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix of the selected link COM </dd></dl>

</div>
</div>
<a id="a8878df6b0dfa644d6e46bb24c7b25bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8878df6b0dfa644d6e46bb24c7b25bdb">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string iCub::iDyn::RigidBodyTransformation::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return some information. </p>
<dl class="section return"><dt>Returns</dt><dd>a string with information </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a074db03771f7a46286d56cbf72e064e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074db03771f7a46286d56cbf72e064e4">&#9670;&nbsp;</a></span>ddp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Vector iCub::iDyn::RigidBodyTransformation::ddp</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>linear acceleration </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00167">167</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="ab63125929644ba5c382abbdfc2214ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63125929644ba5c382abbdfc2214ce5">&#9670;&nbsp;</a></span>dw</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Vector iCub::iDyn::RigidBodyTransformation::dw</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>angular acceleration </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00165">165</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="a39d800b1fc1df3f2e245a3d713695351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d800b1fc1df3f2e245a3d713695351">&#9670;&nbsp;</a></span>F</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Vector iCub::iDyn::RigidBodyTransformation::F</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>force </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00169">169</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="a29201c4b2592828a197e3028541bf664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29201c4b2592828a197e3028541bf664">&#9670;&nbsp;</a></span>H</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Matrix iCub::iDyn::RigidBodyTransformation::H</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the roto-translation between the limb and the node </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00145">145</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="aedce5df05fbe534364870f4a21bc1b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedce5df05fbe534364870f4a21bc1b9c">&#9670;&nbsp;</a></span>hasSensor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iCub::iDyn::RigidBodyTransformation::hasSensor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>flag for sensor or not - only used for setWrenchMeasures() </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00157">157</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="aad40ce607c44de7f6c73995066b62116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad40ce607c44de7f6c73995066b62116">&#9670;&nbsp;</a></span>info</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string iCub::iDyn::RigidBodyTransformation::info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>info or useful notes </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00151">151</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="a24bd8812748a8e66e8131d82fd150f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bd8812748a8e66e8131d82fd150f13">&#9670;&nbsp;</a></span>kinFlow</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a> iCub::iDyn::RigidBodyTransformation::kinFlow</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>kinematic flow: in-to/out-from node (RBT_NODE_IN/RBT_NODE_OUT) </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00139">139</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="a2dde2d3c67543ba964671deb5c43bb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dde2d3c67543ba964671deb5c43bb65">&#9670;&nbsp;</a></span>limb</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiCub_1_1iDyn_1_1iDynLimb.html">iDyn::iDynLimb</a>* iCub::iDyn::RigidBodyTransformation::limb</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the limb attached to the <a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html" title="A class for setting a rigid body transformation between iDynLimb and iDynNode.">RigidBodyTransformation</a> </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00136">136</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="a05b28de4940603b5a0dd08a2bab85655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b28de4940603b5a0dd08a2bab85655">&#9670;&nbsp;</a></span>mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a> iCub::iDyn::RigidBodyTransformation::mode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STATIC/DYNAMIC/DYNAMIC_W_ROTOR/DYNAMIC_CORIOLIS_GRAVITY. </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00148">148</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="a922866e0f889ea54732300e9c4e6e164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922866e0f889ea54732300e9c4e6e164">&#9670;&nbsp;</a></span>Mu</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Vector iCub::iDyn::RigidBodyTransformation::Mu</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>moment </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00171">171</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="a8e004d4923c2e7a9e910119947816189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e004d4923c2e7a9e910119947816189">&#9670;&nbsp;</a></span>verbose</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int iCub::iDyn::RigidBodyTransformation::verbose</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>verbosity flag </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00154">154</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="a90f467c5e26858e176afe11c793ab0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f467c5e26858e176afe11c793ab0ba">&#9670;&nbsp;</a></span>w</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Vector iCub::iDyn::RigidBodyTransformation::w</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>angular velocity </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00163">163</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="a66e8a741b3c683e87aa3f8b5e391be81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e8a741b3c683e87aa3f8b5e391be81">&#9670;&nbsp;</a></span>wreFlow</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a> iCub::iDyn::RigidBodyTransformation::wreFlow</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wrench flow: in-to/out-from node (RBT_NODE_IN/RBT_NODE_OUT) </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00142">142</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>icub-main/src/libraries/iDyn/include/iCub/iDyn/<a class="el" href="iDynBody_8h_source.html">iDynBody.h</a></li>
<li>icub-main/src/libraries/iDyn/src/<a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 26 2024 16:02:21 for iCub-main by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
