<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iCub-main: The Gaze Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iCub-main
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The Gaze Interface </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sec_gaze_intro">Introduction</a></li>
<li class="level1"><a href="#sec_gaze_dependencies">Dependencies</a></li>
<li class="level1"><a href="#sec_gaze_runningserver">Running the Gaze Server</a></li>
<li class="level1"><a href="#sec_gaze_opencloseinterface">Opening and Closing the Gaze Interface</a></li>
<li class="level1"><a href="#sec_gaze_useinterface">Using the Gaze Interface</a><ul><li class="level2"><a href="#subsec_gaze_cartcoorsystem">Expressing the fixation point in Cartesian Coordinates</a></li>
<li class="level2"><a href="#subsec_gaze_absangcoorsystem">Expressing the fixation point in Absolute Angular Coordinate System</a></li>
<li class="level2"><a href="#subsec_gaze_relangcoorsystem">Expressing the fixation point in Relative Angular Coordinate System</a></li>
<li class="level2"><a href="#subsec_gaze_monopixelcoorsystem">Expressing the fixation point in pixel coordinates (monocular approach)</a></li>
<li class="level2"><a href="#subsec_gaze_stereopixelcoorsystem">Expressing the fixation point in pixel coordinates (stereo approach)</a></li>
<li class="level2"><a href="#subsec_gaze_geometrypixels">Geometry of pixels</a></li>
<li class="level2"><a href="#subsec_gaze_fastsaccadicmode">Fast Saccadic Mode</a></li>
<li class="level2"><a href="#subsec_gaze_stabilization">Gaze Stabilization</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_gaze_contextswitch">Context Switch</a></li>
<li class="level1"><a href="#sec_gaze_eventscallbacks">Events Callbacks</a></li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Ugo Pattacini</dd></dl>
<h1><a class="anchor" id="sec_gaze_intro"></a>
Introduction</h1>
<p>The YARP <b>Gaze Interface</b> provides an abstract layer to control the <a class="el" href="namespaceiCub.html" title="This file contains the definition of unique IDs for the body parts and the skin parts of the robot.">iCub</a> gaze in a bio-plausible way, moving the neck and the eyes independently and performing saccades, pursuit, vergence, OCR (oculo-collic reflex), VOR (vestibulo-ocular reflex) and gaze stabilization relying on inertial data.</p>
<p>Essentially, the interface exports all the functionalities given by the <a class="el" href="group__iKinGazeCtrl.html">iKinGazeCtrl</a> module directly from within the code without having to be concerned with the communication protocol done via YARP ports. Thus, the user is warmly invited to visit the <a class="el" href="group__iKinGazeCtrl.html">iKinGazeCtrl page</a> where more detailed descriptions can be found.</p>
<dl class="section note"><dt>Note</dt><dd><b>If you're going to use this controller for your work, please quote it within any resulting publication</b>: Roncone A., Pattacini U., Metta G. &amp; Natale L., "A Cartesian 6-DoF Gaze Controller for Humanoid Robots", <em>Proceedings of Robotics: Science and Systems</em>, Ann Arbor, MI, June 18-22, 2016.</dd></dl>
<h1><a class="anchor" id="sec_gaze_dependencies"></a>
Dependencies</h1>
<p>In order to use the Gaze Interface, make sure that the following steps are done:</p>
<ol type="1">
<li>Install the required <a href="https://icub-tech-iit.github.io/documentation/sw_installation/">software dependencies</a>.</li>
<li>Compile the <a class="el" href="namespaceiCub.html" title="This file contains the definition of unique IDs for the body parts and the skin parts of the robot.">iCub</a> repository with the switch <b>ENABLE_icubmod_gazecontrollerclient</b> enabled: this will make the client part of the interface available. The server part is represented by the module <a class="el" href="group__iKinGazeCtrl.html">iKinGazeCtrl</a> itself.</li>
</ol>
<h1><a class="anchor" id="sec_gaze_runningserver"></a>
Running the Gaze Server</h1>
<p>Launch: </p><div class="fragment"><div class="line">iKinGazeCtrl</div>
</div><!-- fragment --><p>The server will load its parameters from the default configuration file (which can be overridden by the <em>context</em> and the <em>from</em> command-line options) containing information on the camera intrinsic parameters which are required to use some of the methods provided by the Gaze Interface, and specifically the <em>lookAtMonoPixel()</em> and <em>lookAtStereoPixel()</em> method. <br  />
Furthermore, by using the installed copy of <em>$ICUB_ROOT/main/app/iCubStartup/scripts/iCubStartup.xml</em> application the user is also able to launch the gaze server contextually with the iCubInterface module.</p>
<h1><a class="anchor" id="sec_gaze_opencloseinterface"></a>
Opening and Closing the Gaze Interface</h1>
<p>The Gaze Interface can be opened as a normal YARP interface resorting to the <em>PolyDriver</em> class: </p><div class="fragment"><div class="line">Property option;</div>
<div class="line">option.put(<span class="stringliteral">&quot;device&quot;</span>,<span class="stringliteral">&quot;gazecontrollerclient&quot;</span>);</div>
<div class="line">option.put(<span class="stringliteral">&quot;remote&quot;</span>,<span class="stringliteral">&quot;/iKinGazeCtrl&quot;</span>);</div>
<div class="line">option.put(<span class="stringliteral">&quot;local&quot;</span>,<span class="stringliteral">&quot;/client/gaze&quot;</span>);</div>
<div class="line"> </div>
<div class="line">PolyDriver clientGazeCtrl(option);</div>
<div class="line"> </div>
<div class="line">IGazeControl *igaze=NULL;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (clientGazeCtrl.isValid()) {</div>
<div class="line">   clientGazeCtrl.view(igaze);</div>
<div class="line">}</div>
</div><!-- fragment --><p>When you are done with controlling the robot you can explicitly close the device (or just let the destructor do it for you): </p><div class="fragment"><div class="line">clientGazeCtrl.close();</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_gaze_useinterface"></a>
Using the Gaze Interface</h1>
<p>The YARP documentation contains a full description of <b><a href="https://yarp.it/latest/classyarp_1_1dev_1_1IGazeControl.html">Gaze Interface</a></b>. It makes use of three different coordinate systems that enable the user to control the robot's gaze as detailed hereafter.</p>
<h2><a class="anchor" id="subsec_gaze_cartcoorsystem"></a>
Expressing the fixation point in Cartesian Coordinates</h2>
<p>This coordinate system is the same as the one the <a class="el" href="icub_cartesian_interface.html">Cartesian Interface</a> relies on and complies with the <a href="https://icub-tech-iit.github.io/documentation/icub_kinematics/icub-forward-kinematics/icub-forward-kinematics">documentation</a>; it lets the user to give the target location where to gaze at with respect to the root reference frame attached to the robot's waist.</p>
<p>The following snippet of code shows how to command the gaze in the Cartesian space and to retrieve the current configuration.</p>
<div class="fragment"><div class="line">Vector <a class="code" href="pcap__wrapper__linux_8cpp.html#ae44275d34c468c2018022eafb08b7179">fp</a>(3);</div>
<div class="line"><a class="code" href="pcap__wrapper__linux_8cpp.html#ae44275d34c468c2018022eafb08b7179">fp</a>[0]=-0.50;                                    <span class="comment">// x-component [m]</span></div>
<div class="line"><a class="code" href="pcap__wrapper__linux_8cpp.html#ae44275d34c468c2018022eafb08b7179">fp</a>[1]=+0.00;                                    <span class="comment">// y-component [m]</span></div>
<div class="line"><a class="code" href="pcap__wrapper__linux_8cpp.html#ae44275d34c468c2018022eafb08b7179">fp</a>[2]=+0.35;                                    <span class="comment">// z-component [m]</span></div>
<div class="line"> </div>
<div class="line">igaze-&gt;lookAtFixationPointSync(<a class="code" href="pcap__wrapper__linux_8cpp.html#ae44275d34c468c2018022eafb08b7179">fp</a>);             <span class="comment">// request to gaze at the desired fixation point and wait for reply (sync method)</span></div>
<div class="line">igaze-&gt;waitMotionDone();                        <span class="comment">// wait until the operation is done</span></div>
<div class="line"> </div>
<div class="line">Vector <a class="code" href="compute__ekf__sym_8m.html#abe119338ba11d7fd166333a3941bc2c4">x</a>;</div>
<div class="line">igaze-&gt;getFixationPoint(<a class="code" href="compute__ekf__sym_8m.html#abe119338ba11d7fd166333a3941bc2c4">x</a>);                     <span class="comment">// retrieve the current fixation point</span></div>
<div class="line"> </div>
<div class="line">cout&lt;&lt;<span class="stringliteral">&quot;final error = &quot;</span>&lt;&lt;<a class="code" href="group__Maths.html#ga791f0548018b3597da95e70a3b226806">norm</a>(<a class="code" href="pcap__wrapper__linux_8cpp.html#ae44275d34c468c2018022eafb08b7179">fp</a>-<a class="code" href="compute__ekf__sym_8m.html#abe119338ba11d7fd166333a3941bc2c4">x</a>)&lt;&lt;endl;       <span class="comment">// return a measure of the displacement error</span></div>
<div class="ttc" id="acompute__ekf__sym_8m_html_abe119338ba11d7fd166333a3941bc2c4"><div class="ttname"><a href="compute__ekf__sym_8m.html#abe119338ba11d7fd166333a3941bc2c4">x</a></div><div class="ttdeci">x</div><div class="ttdef"><b>Definition:</b> <a href="compute__ekf__sym_8m_source.html#l00021">compute_ekf_sym.m:21</a></div></div>
<div class="ttc" id="agroup__Maths_html_ga791f0548018b3597da95e70a3b226806"><div class="ttname"><a href="group__Maths.html#ga791f0548018b3597da95e70a3b226806">iCub::ctrl::norm</a></div><div class="ttdeci">double norm(const yarp::sig::Matrix &amp;M, int col)</div><div class="ttdoc">Returns the norm of the vector given in the form: matrix(:,col).</div></div>
<div class="ttc" id="apcap__wrapper__linux_8cpp_html_ae44275d34c468c2018022eafb08b7179"><div class="ttname"><a href="pcap__wrapper__linux_8cpp.html#ae44275d34c468c2018022eafb08b7179">fp</a></div><div class="ttdeci">static struct bpf_program fp</div><div class="ttdef"><b>Definition:</b> <a href="pcap__wrapper__linux_8cpp_source.html#l00088">pcap_wrapper_linux.cpp:89</a></div></div>
</div><!-- fragment --><p>We have also here <b>sync</b> and <b>non-sync</b> methods for yielding gazing movements, therefore we refer the reader to the <a class="el" href="icub_cartesian_interface.html">Cartesian Interface</a> to get insights on their peculiarities.</p>
<h2><a class="anchor" id="subsec_gaze_absangcoorsystem"></a>
Expressing the fixation point in Absolute Angular Coordinate System</h2>
<p>This coordinate system is an absolute head-centered angular reference frame as explained below:</p><ul>
<li><em>Angular</em> means that it makes use of the azimuth, elevation and vergence that are angular quantities.</li>
<li><em>Head-Centered</em> means that the frame is attached at the middle point between the two cameras owning the same set of three axes.</li>
<li><em>Absolute</em> indicates that it remains still irrespective of the robot motion and it refers to the position of the head when the robot is in rest configuration (i.e. torso and head angles zeroed).</li>
</ul>
<p>For instance, to specify a desired location where to look at in this coordinate system, one can write: </p><div class="fragment"><div class="line">Vector ang(3);</div>
<div class="line">ang[0]=+10.0;                   <span class="comment">// azimuth-component [deg]</span></div>
<div class="line">ang[1]=-05.0;                   <span class="comment">// elevation-component [deg]</span></div>
<div class="line">ang[2]=+20.0;                   <span class="comment">// vergence-component [deg]</span></div>
<div class="line"> </div>
<div class="line">igaze-&gt;lookAtAbsAngles(ang);    <span class="comment">// move the gaze</span></div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">igaze-&gt;getAngles(ang);          <span class="comment">// get the current angular configuration</span></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_gaze_relangcoorsystem"></a>
Expressing the fixation point in Relative Angular Coordinate System</h2>
<p>Also the relative angular coordinate system is available which is basically the same as the absolute one but refers to the current configuration of the head-centered frame. Hence we can use: </p><div class="fragment"><div class="line">Vector ang(3);</div>
<div class="line">ang[0]=+10.0;   <span class="comment">// azimuth-relative component wrt the current configuration [deg]</span></div>
<div class="line">ang[1]=-05.0;   <span class="comment">// elevation-relative component wrt the current configuration [deg]</span></div>
<div class="line">ang[2]=+20.0;   <span class="comment">// vergence-relative component wrt the current configuration [deg]</span></div>
<div class="line"> </div>
<div class="line">igaze-&gt;lookAtRelAngles(ang);    <span class="comment">// move the gaze wrt the current configuration</span></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_gaze_monopixelcoorsystem"></a>
Expressing the fixation point in pixel coordinates (monocular approach)</h2>
<p>The user can also command the gaze by specifying a location within the image plane of one camera as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> camSel=0;   <span class="comment">// select the image plane: 0 (left), 1 (right)</span></div>
<div class="line"> </div>
<div class="line">Vector px(2);   <span class="comment">// specify the pixel where to look</span></div>
<div class="line">px[0]=160.0;</div>
<div class="line">px[1]=120.0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="show__eyes__axes_8m.html#a25ed1bcb423b0b7200f485fc5ff71c8e">z</a>=1.0;   <span class="comment">// distance [m] of the object from the image plane (extended to infinity): yes, you probably need to guess, but it works pretty robustly</span></div>
<div class="line"> </div>
<div class="line">igaze-&gt;lookAtMonoPixel(camSel,px,<a class="code" href="show__eyes__axes_8m.html#a25ed1bcb423b0b7200f485fc5ff71c8e">z</a>);    <span class="comment">// look!</span></div>
<div class="ttc" id="ashow__eyes__axes_8m_html_a25ed1bcb423b0b7200f485fc5ff71c8e"><div class="ttname"><a href="show__eyes__axes_8m.html#a25ed1bcb423b0b7200f485fc5ff71c8e">z</a></div><div class="ttdeci">z</div><div class="ttdef"><b>Definition:</b> <a href="show__eyes__axes_8m_source.html#l00022">show_eyes_axes.m:22</a></div></div>
</div><!-- fragment --><p> What the interface will internally execute is to retrieve the corresponding 3D point through a call to <em>get3DPoint()</em> to then use this result to command an equivalent Cartesian displacement as in the following: </p><div class="fragment"><div class="line">Vector <a class="code" href="compute__ekf__sym_8m.html#abe119338ba11d7fd166333a3941bc2c4">x</a>;</div>
<div class="line">igaze-&gt;get3DPoint(camSel,px,<a class="code" href="show__eyes__axes_8m.html#a25ed1bcb423b0b7200f485fc5ff71c8e">z</a>,<a class="code" href="compute__ekf__sym_8m.html#abe119338ba11d7fd166333a3941bc2c4">x</a>);</div>
<div class="line">igaze-&gt;lookAtFixationPoint(<a class="code" href="compute__ekf__sym_8m.html#abe119338ba11d7fd166333a3941bc2c4">x</a>);</div>
</div><!-- fragment --><p> The benefit of <em>lookAtMonoPixel()</em> method is clearly that the time for the rpc communication is saved, hence it is particularly designed for control in streaming mode; on the other hand, the knowledge of the Cartesian point remains hidden to the user, unless it is retrieved at the end of the motion through a call to <em>getFixationPoint()</em>. <br  />
Alternatively, one can think to rely on the vergence angle given in degrees in place of the the component z, accounting for a different way of expressing distances from the eyes. To this end, the user can call the proper method <em>lookAtMonoPixelWithVergence(camSel,px,ver)</em>.</p>
<h2><a class="anchor" id="subsec_gaze_stereopixelcoorsystem"></a>
Expressing the fixation point in pixel coordinates (stereo approach)</h2>
<p>The same thing can be achieved also by exploiting the stereo vision: </p><div class="fragment"><div class="line">Vector c(2), pxl(2), pxr(2);</div>
<div class="line">c[0]=160.0;     <span class="comment">// center of image plane</span></div>
<div class="line">c[1]=120.0;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> converged=<span class="keyword">false</span>;</div>
<div class="line"><span class="keywordflow">while</span> (!converged)</div>
<div class="line">{</div>
<div class="line">    pxl[0]=...;         <span class="comment">// specify somehow the pixel within the left image plane</span></div>
<div class="line">    pxl[1]=...;</div>
<div class="line"> </div>
<div class="line">    pxr[0]=...;         <span class="comment">// specify somehow the pixel within the right image plane</span></div>
<div class="line">    pxr[1]=...;</div>
<div class="line"> </div>
<div class="line">    igaze-&gt;lookAtStereoPixels(pxl,pxr);                 <span class="comment">// look!</span></div>
<div class="line"> </div>
<div class="line">    converged=(0.5*(<a class="code" href="group__Maths.html#ga791f0548018b3597da95e70a3b226806">norm</a>(c-pxl)+<a class="code" href="group__Maths.html#ga791f0548018b3597da95e70a3b226806">norm</a>(c-pxr))&lt;5);        <span class="comment">// recompute somehow the convergence status</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> Of course, the matching problem between pixels of different image planes is left to the user, who has also to provide a continuous visual feedback while converging to the target.</p>
<h2><a class="anchor" id="subsec_gaze_geometrypixels"></a>
Geometry of pixels</h2>
<p>It might be useful sometimes to perform an homography in order to retrieve the projection of a pixel into a plane specified in the 3D space: let's think for instance to the context of the robot presented with a number of objects that all lie on a table. The table introduces a constraint that allows determining the component z of the point in case the monocular approach is used. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> camSel=0;   <span class="comment">// select the image plane: 0 (left), 1 (right)</span></div>
<div class="line"> </div>
<div class="line">Vector px(2);   <span class="comment">// specify the pixel where to look</span></div>
<div class="line">px[0]=160.0;</div>
<div class="line">px[1]=120.0;</div>
<div class="line"> </div>
<div class="line">Vector plane(4);  <span class="comment">// specify the plane in the root reference frame as ax+by+cz+d=0; z=-0.12 in this case</span></div>
<div class="line">plane[0]=0.0;     <span class="comment">// a</span></div>
<div class="line">plane[1]=0.0;     <span class="comment">// b</span></div>
<div class="line">plane[2]=1.0;     <span class="comment">// c</span></div>
<div class="line">plane[3]=0.12;    <span class="comment">// d</span></div>
<div class="line"> </div>
<div class="line">Vector <a class="code" href="compute__ekf__sym_8m.html#abe119338ba11d7fd166333a3941bc2c4">x</a>;</div>
<div class="line">igaze-&gt;get3DPointOnPlane(camSel,px,plane,<a class="code" href="compute__ekf__sym_8m.html#abe119338ba11d7fd166333a3941bc2c4">x</a>);    <span class="comment">// get the projection</span></div>
</div><!-- fragment --><p> It is possible to execute a triangulation to find from the pixels in the images the corresponding 3D point in the space. This problem is solved through a least-squares minimization. </p><div class="fragment"><div class="line">Vector pxl(2), pxr(2);</div>
<div class="line">pxl[0]=...;         <span class="comment">// specify somehow the pixel within the left image plane</span></div>
<div class="line">pxl[1]=...;</div>
<div class="line"> </div>
<div class="line">pxr[0]=...;         <span class="comment">// specify somehow the pixel within the right image plane</span></div>
<div class="line">pxr[1]=...;</div>
<div class="line"> </div>
<div class="line">Vector <a class="code" href="compute__ekf__sym_8m.html#abe119338ba11d7fd166333a3941bc2c4">x</a>;</div>
<div class="line">igaze-&gt;triangulate3DPoint(pxl,pxr,<a class="code" href="compute__ekf__sym_8m.html#abe119338ba11d7fd166333a3941bc2c4">x</a>);</div>
</div><!-- fragment --><p> Importantly, the triangulation is strongly affected by uncertainties in the cameras alignment, so that, unless these unknowns are perfectly compensated, to fixate in stereo mode it is advisable to rely on the method <em>lookAtStereoPixels()</em>.</p>
<h2><a class="anchor" id="subsec_gaze_fastsaccadicmode"></a>
Fast Saccadic Mode</h2>
<p>The user has the possibility to enable the fast saccadic mode that employs the low level position control in order to generate very fast saccadic movements of the eyes. To achieve that, one can simply do the following: </p><div class="fragment"><div class="line">igaze-&gt;setSaccadesMode(<span class="keyword">true</span>);</div>
</div><!-- fragment --><p> After a saccade is executed, the next saccadic movement can be performed only after a given inhibition period of time, that in turn can be retrieved and/or tuned relying on specific methods (i.e. <em>get/setSaccadesInhibitionPeriod()</em>). <br  />
The controller chooses to perform a saccade only if the angular distance of the target from the straight-ahead line overcomes a given threshold the user might profitable tune relying on dedicated methods (i.e. <em>get/setSaccadesActivationAngle()</em>). <br  />
 <br  />
<em>Caveat</em>: vision processing algorithms that assume the continuity of the images flow might be heavily affected by saccades.</p>
<h2><a class="anchor" id="subsec_gaze_stabilization"></a>
Gaze Stabilization</h2>
<p>The controller can be instructed to do its best in order to keep the fixation point unvaried under the effect of external disturbances/movements. The gaze stabilization makes use of inertial data to accomplish the job and entails that corrections will be sent to the eyes too (therefore, it is not a mere head stabilization). To enable the gaze stabilization, call the following method: </p><div class="fragment"><div class="line">igaze-&gt;setStabilizationMode(<span class="keyword">true</span>);</div>
</div><!-- fragment --><p> The stabilization is always active also during point-to-point motion or while tracking a moving reference, regardless of the current setting for the above mode and unless the stabilization has been purposely disabled (via command-line option), so that any disturbance occurring during that motion will be compesated for. In this respect, the difference between the <em>stabilization mode</em> and the <em>tracking mode</em> is that in the former modality the fixation point is stabilized in the "world" coordinate system, thus this mode turns to be particularly suitable for robot balancing and walking, while in the latter modality the fixation point will be always tracked in the robot's root reference frame, which might be moving with respect to the world as well. <br  />
When the stabilization is active and the robot is purely compensating for external disturbances, the neck and eyes limits customized by the user are not taken into account, thus spanning their whole admittable range. </p><dl class="section note"><dt>Note</dt><dd>For further details about gaze stabilization refer to: Roncone A., Pattacini U., Metta G. &amp; Natale L., "Gaze Stabilization for Humanoid Robots: a Comprehensive Framework", <em>IEEE-RAS International Conference on Humanoid Robots</em>, Madrid, Spain, November 18-20, 2014.</dd></dl>
<h1><a class="anchor" id="sec_gaze_contextswitch"></a>
Context Switch</h1>
<p>We define here the <em>context</em> as the configuration in which the controller operates: therefore the context includes the current tracking mode, the eyes and neck trajectory execution time and so on. Obviously the controller performs the same action differently depending on the current context. A way to easily switch among contexts is to rely on <em>storeContext()</em> and <em>restoreContext()</em> methods as follows: </p><div class="fragment"><div class="line">igaze-&gt;setEyesTrajTime(0.5);            <span class="comment">// here the user prepares the context</span></div>
<div class="line">igaze-&gt;setTrackingMode(<span class="keyword">true</span>);</div>
<div class="line">igaze-&gt;bindNeckPitch();</div>
<div class="line">...</div>
<div class="line">int context_0;</div>
<div class="line">igaze-&gt;storeContext(&amp;context_0);        <span class="comment">// latch the context</span></div>
<div class="line"> </div>
<div class="line">igaze-&gt;setNeckTrajTime(1.5);            <span class="comment">// at certain point the user may want the controller to</span></div>
<div class="line">igaze-&gt;clearNeckPitch();                <span class="comment">// perform some actions with different configuration</span></div>
<div class="line">igaze-&gt;lookAtFixationPoint(<a class="code" href="pcap__wrapper__linux_8cpp.html#ae44275d34c468c2018022eafb08b7179">fp</a>);</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">igaze-&gt;restoreContext(context_0);       <span class="comment">// ... and then retrieve the stored context_0</span></div>
<div class="line">igaze-&gt;lookAtFixationPoint(<a class="code" href="pcap__wrapper__linux_8cpp.html#ae44275d34c468c2018022eafb08b7179">fp</a>);         <span class="comment">// now the controller performs the same action but within the context_0</span></div>
</div><!-- fragment --><p> Unless the user needs the interface just for logging purposes, it's a good rule to store the context at the initialization of his module in order to then restore it at releasing time to preserve the controller configuration. <br  />
Note that the special context tagged with the id 0 is reserved by the system to let the user restore the start-up configuration of the controller at any time.</p>
<h1><a class="anchor" id="sec_gaze_eventscallbacks"></a>
Events Callbacks</h1>
<p>The Gaze Interface provides also an easy way to register events callbacks. For example, an event might be represented by the onset of the movement when the controller gets activated by receiving a new target or the end of the movement itself. The user can then attach a callback to any event generated by the interface. <br  />
It is required to inherit from the specific class <em>GazeEvent</em> that handles events and overrides the <em>gazeEventCallback()</em> method. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MotionDoneEvent : <span class="keyword">public</span> GazeEvent</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">   MotionDoneEvent()</div>
<div class="line">   {</div>
<div class="line">      gazeEventParameters.type=<span class="stringliteral">&quot;motion-done&quot;</span>;      <span class="comment">// select here the event type we want to listen to</span></div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">void</span> gazeEventCallback()</div>
<div class="line">   {</div>
<div class="line">      cout&lt;&lt;<span class="stringliteral">&quot;motion complete&quot;</span>&lt;&lt;endl;</div>
<div class="line">   }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MotionDoneEvent event;</div>
<div class="line">igaze-&gt;registerEvent(event);                       <span class="comment">// the tag &quot;motion-done&quot; identifies the event to be notified</span></div>
<div class="line">igaze-&gt;lookAtFixationPoint(<a class="code" href="pcap__wrapper__linux_8cpp.html#ae44275d34c468c2018022eafb08b7179">fp</a>);                    <span class="comment">// as soon as the motion is complete, the callback will print out the message</span></div>
</div><!-- fragment --><p>To know which events are available for notification, the user can do: </p><div class="fragment"><div class="line">Bottle <a class="code" href="namespaceiCub_1_1action_1_1log.html#a4ba5ea132464d0ea49d618130163c769a432470a52cfded222c35744229d1069e">info</a>;</div>
<div class="line">igaze-&gt;getInfo(<a class="code" href="namespaceiCub_1_1action_1_1log.html#a4ba5ea132464d0ea49d618130163c769a432470a52cfded222c35744229d1069e">info</a>);</div>
<div class="line">cout&lt;&lt;<a class="code" href="namespaceiCub_1_1action_1_1log.html#a4ba5ea132464d0ea49d618130163c769a432470a52cfded222c35744229d1069e">info</a>.find(<span class="stringliteral">&quot;events&quot;</span>).asList()-&gt;toString().c_str()&lt;&lt;endl;</div>
<div class="ttc" id="anamespaceiCub_1_1action_1_1log_html_a4ba5ea132464d0ea49d618130163c769a432470a52cfded222c35744229d1069e"><div class="ttname"><a href="namespaceiCub_1_1action_1_1log.html#a4ba5ea132464d0ea49d618130163c769a432470a52cfded222c35744229d1069e">iCub::action::log::info</a></div><div class="ttdeci">@ info</div><div class="ttdef"><b>Definition:</b> <a href="actionPrimitives_8cpp_source.html#l00066">actionPrimitives.cpp:66</a></div></div>
</div><!-- fragment --><p>The class <em>GazeEvent</em> contains two structures: the <em>gazeEventParameters</em> and the <em>gazeEventVariables</em>. The former has to be filled by the user to set up the event details, whereas the latter is filled directly by the event handler in order to provide information to the callback. <br  />
For instance, to raise a callback at the middle point of the path, one can do: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MotionMiddleEvent : <span class="keyword">public</span> GazeEvent</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">   MotionMiddleEvent()</div>
<div class="line">   {</div>
<div class="line">      gazeEventParameters.type=<span class="stringliteral">&quot;motion-ongoing&quot;</span>;</div>
<div class="line">      gazeEventParameters.motionOngoingCheckPoint=0.5;   <span class="comment">// middle point is at 50% of the path</span></div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">void</span> gazeEventCallback()</div>
<div class="line">   {</div>
<div class="line">      cout&lt;&lt;<span class="stringliteral">&quot;attained the &quot;</span>&lt;&lt;100.0*gazeEventVariables.motionOngoingCheckPoint;</div>
<div class="line">      cout&lt;&lt;<span class="stringliteral">&quot;% of the path&quot;</span>&lt;&lt;endl;</div>
<div class="line">   }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The special wildcard "*" can be used to assign a callback to any event, regardless of its type, as done below. </p><div class="fragment"><div class="line"><span class="keyword">class </span>GeneralEvent : <span class="keyword">public</span> GazeEvent</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">   GeneralEvent()</div>
<div class="line">   {</div>
<div class="line">      gazeEventParameters.type=<span class="stringliteral">&quot;*&quot;</span>;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">void</span> gazeEventCallback()</div>
<div class="line">   {</div>
<div class="line">      cout&lt;&lt;<span class="stringliteral">&quot;event of type: &quot;</span>&lt;&lt;gazeEventVariables.type.c_str()&lt;&lt;endl;</div>
<div class="line">      cout&lt;&lt;<span class="stringliteral">&quot;happened at:   &quot;</span>&lt;&lt;gazeEventVariables.time&lt;&lt; <span class="stringliteral">&quot;[s] (source time)&quot;</span>&lt;&lt;endl;</div>
<div class="line">   }</div>
<div class="line">};</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 26 2024 16:02:19 for iCub-main by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
