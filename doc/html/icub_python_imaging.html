<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iCub-main: Handling YARP images in Python</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iCub-main
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Handling YARP images in Python </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Marek Rucinski</dd></dl>
<h1><a class="anchor" id="sec_goal"></a>
Goal</h1>
<p>This tutorial shows how to handle YARP images in Python. The most important issue is fast two-way conversion between image data structures from YARP and those native for Python.</p>
<p>We assume that you have already compiled or installed the Python bindings. Moreover this tutorial assumes basic knowledge of how YARP works in C++ as well as of the referenced python libraries (especially the NumPy-SciPy-Matplotlib trinity).</p>
<h1><a class="anchor" id="sec_there-and-back-again"></a>
Conversion between YARP image types and Python types (and back)</h1>
<p>The key to obtain high performance in any image processing software is to avoid copying the data back and forth whenever possible. Ideally, having received an image through a YARP port, we would modify it <em>in place</em> and then pass the very same image to the output port. To facilitate this, <code>yarp::sig::Image</code> class implements a method called <code>setExternal()</code> which allows an Image object to "wrap around" an already existing data buffer. Therefore the key element of image processing in Python is creating a YARP image object that wraps around a data structure native to Python, which then can be then conveniently manipulated using Python-specific means. Due to its popularity and mature stage of development, in this tutorial we consider NumPy arrays as the substrate for image processing within Python (see for instance <a href="http://docs.scipy.org/doc/scipy/reference/ndimage.html"><code>scipy.ndimage</code> </a> or <a href="http://scikit-image.org/"><code>scikit-image</code> </a> modules for off-the-shelf image processing routines operating on NumPy arrays). However, the concepts presented here may be applied to other Python frameworks as well (e.g. PIL, PyQt), provided certain requirements discussed below are fulfilled.</p>
<h1><a class="anchor" id="sec_python_to_yarp"></a>
Sending data from Python to YARP</h1>
<p>If you're using Python 3.x and the data structure you want to receive the image data into supports the Python <a href="http://docs.python.org/2/c-api/buffer.html">buffer protocol</a> (which is the case for NumPy arrays), all you have to do is to call the <code>setExternal</code> method of an YARP image object, specifying your python object as its first argument.</p>
<p>In the following example, a NumPy array with random contents is created, a YARP image is wrapped around it and sent to a YARP port. It is assumed that there is an instance of <code>yarpview</code> running with associated port name <code>"/view01"</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> numpy</div>
<div class="line"><span class="keyword">import</span> yarp</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Initialise YARP</span></div>
<div class="line">yarp.Network.init()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create the array with random data</span></div>
<div class="line">img_array = numpy.random.uniform(0., 255., (240, 320)).astype(numpy.float32)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create the yarp image and wrap it around the array  </span></div>
<div class="line">yarp_image = yarp.ImageFloat()</div>
<div class="line">yarp_image.setExternal(img_array, img_array.shape[1], img_array.shape[0])</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create the yarp port, connect it to the running instance of yarpview and send the image</span></div>
<div class="line">output_port = yarp.Port()</div>
<div class="line">output_port.open(<span class="stringliteral">&quot;/python-image-port&quot;</span>)</div>
<div class="line">yarp.Network.connect(<span class="stringliteral">&quot;/python-image-port&quot;</span>, <span class="stringliteral">&quot;/view01&quot;</span>)</div>
<div class="line">output_port.write(yarp_image)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Cleanup</span></div>
<div class="line">output_port.close()</div>
</div><!-- fragment --><p>There is a number of crucial things that need to be kept in mind:</p>
<ol type="1">
<li><p class="startli"><em>NumPy array shape, data type and value range must be compatible with the type of YARP image to be wrapped around it</em>. Below is the list of YARP image types exposed by YARP bindings and corresponding requirements for the underlying NumPy array:</p><ul>
<li><code>yarp.ImageMono</code> - array data type: <code>uint8</code>, shape: (&lt;image-height&gt;, &lt;image-width&gt;), values range: 0 to 255</li>
<li><code>yarp.ImageFloat</code> - array data type: <code>float32</code>, shape: (&lt;image-height&gt;, &lt;image-width&gt;), values range: 0. to 255. (Note: this is <em>different</em> from 0. to 1. range, assumed by default e.g. by <code>scipy.ndimage</code> routines!)</li>
<li><code>yarp.ImageRgb</code> - array data type: <code>uint8</code>, shape: (&lt;image-height&gt;, &lt;image-width&gt;, 3), values range: 0 to 255</li>
<li><code>yarp.ImageRgbFloat</code> - array data type: <code>float32</code>, shape: (&lt;image-height&gt;, &lt;image-width&gt;, 3), values range: 0. to 255.</li>
<li><code>yarp.ImageRgba</code> - array data type: <code>uint8</code>, shape: (&lt;image-height&gt;, &lt;image-width&gt;, 4), values range: 0 to 255</li>
</ul>
<p class="startli">In the example above the result of calling numpy.random.uniform() had to be explicitly cast to <code>float32</code>, since by default it returned <code>float64</code>. This may very well be architecture-dependent, so it's best to specify the array data type explicitly (tip: most NumPy array creation routines accept the <code>dtype</code> parameter).</p>
</li>
<li><em>NumPy array being wrapped around must be contiguous in the memory</em>. This is usually the case for newly created arrays, but if the array you want to send is a result of some computation process (especially one involving operations like transposing, slicing, etc.), make sure to call <code>numpy.ascontiguousarray()</code> before passing the array to <code>setExternal()</code>.</li>
<li><em>Image dimensions specified in <code>setExternal</code> call must match actual dimensions of the array</em>. Using the array's shape attribute as in the example above is the most fool-proof way to go, but note the order in which the array dimensions are specified in this attribute. Rows (corresponding to image height) come first, then columns (image width).</li>
<li><em>Underlying array must outlive the Image object wrapping around it</em>. Make sure the array exists as long as the image object is being used. It may be a good practice to delete the image object explicitly (tip: Python <code>del</code> statement) as soon as it is no longer needed.</li>
</ol>
<h1><a class="anchor" id="sec_yarp_to_python"></a>
Receiving data from YARP to Python</h1>
<p>The idea is pretty much the same as when sending an image to the port. In order to minimize the number of copy operations, we wrap the YARP image around a NumPy array before reading an image from the port. The example below assumes that <a class="el" href="namespaceiCub.html" title="This file contains the definition of unique IDs for the body parts and the skin parts of the robot.">iCub</a> simulator is running and that the world camera is available at port <code>"/icubSim/cam"</code> </p>
<div class="fragment"><div class="line"><span class="keyword">import</span> numpy</div>
<div class="line"><span class="keyword">import</span> yarp</div>
<div class="line"><span class="keyword">import</span> matplotlib.pylab</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Initialise YARP</span></div>
<div class="line">yarp.Network.init()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a port and connect it to the iCub simulator virtual camera</span></div>
<div class="line">input_port = yarp.Port()</div>
<div class="line">input_port.open(<span class="stringliteral">&quot;/python-image-port&quot;</span>)</div>
<div class="line">yarp.Network.connect(<span class="stringliteral">&quot;/icubSim/cam&quot;</span>, <span class="stringliteral">&quot;/python-image-port&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create numpy array to receive the image and the YARP image wrapped around it</span></div>
<div class="line">img_array = numpy.zeros((240, 320, 3), dtype=numpy.uint8)</div>
<div class="line">yarp_image = yarp.ImageRgb()</div>
<div class="line">yarp_image.resize(320, 240)</div>
<div class="line">yarp_image.setExternal(img_array, img_array.shape[1], img_array.shape[0])</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Read the data from the port into the image</span></div>
<div class="line">input_port.read(yarp_image)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># display the image that has been read</span></div>
<div class="line">matplotlib.pylab.imshow(img_array)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Cleanup</span></div>
<div class="line">input_port.close()</div>
</div><!-- fragment --><p>All remarks mentioned in section <a class="el" href="icub_python_imaging.html#sec_python_to_yarp">Sending data from Python to YARP</a> are also valid here.</p>
<p>The method above minimizes the number of performed copy operations however it comes with a serious limitation: the exact size and type of the incoming image must be known beforehand. If the image coming through the port does not match the dimensions, pixel type or quantum of the prepared <code>yarp_image</code>, the latter will be automatically re-allocated when <code><a class="el" href="namespaceeth_1_1parser.html#a8ec58da625146082584ad1a365bdd0e5">read()</a></code> is called and association with <code>img_array</code> will be covertly lost. Note that before calling <code>setExternal()</code> we call <code>resize()</code> on the <code>yarp_image</code>. This is required because just calling <code>setExternal</code> will not set internal variables of the image class properly (namely the pixel size and the quantum), and the <code>yarp_image's</code> buffer will also be re-allocated by <code><a class="el" href="namespaceeth_1_1parser.html#a8ec58da625146082584ad1a365bdd0e5">read()</a></code>.</p>
<p>If the size and type of the incoming image is not known or when greater flexibility is required, we won't get away without copying the image, at least when a frame with new size or format is retrieved. One must detect such situation, adjust the receiving array accordingly and copy the image contents.</p>
<p>As an alternative to using the bare <code>yarp.Port</code> class, one can also use one of the specialized instantiations of the of the <code>BufferedPort</code> template exposed by the YARP bindings, e.g. <code>BufferedPortImageRgb</code>. The <code><a class="el" href="namespaceeth_1_1parser.html#a8ec58da625146082584ad1a365bdd0e5">read()</a></code> method of this class returns a yarp image of an appropriate type, which then must be copied to another yarp image, associated with a NumPy array. Although this introduces one additional copy operation, this facilitates adjusting the receiving NumPy array to potentially changing image size, as discussed in the previous paragraph.</p>
<h1><a class="anchor" id="array_interface"></a>
YARP images with Python 2.x / array interface</h1>
<p>As noted at the beginning, <code>setExternal()</code> can be called for any Python object which supports the buffer protocol <em>if</em> you're using Python version 3.0 or greater. If you are using an older version of Python you must try another approach. YARP bindings export another variant of the <code>setExternal</code> method which accepts <code>long</code> value (as well as <code>long</code> <code>long</code> for 64-bit systems), which is then explicitly cast to <code>void*</code> before being passed to the default <code>setExternal</code> implementation. Thus, if your Python object enables you to obtain the physical value of the pointer to the buffer you want the image data to be written to, the requirement of supporting the buffer protocol can be circumnavigated.</p>
<p>For example, NumPy arrays implement what is called an <a href="http://docs.scipy.org/doc/numpy/reference/arrays.interface.html">array interface</a>. It is essentially a dictionary which contains a bunch of information about the underlying buffer, one of them being a raw value of the pointer to the data. This value can be used in an alternative call to <code>setExternal:</code> </p>
<div class="fragment"><div class="line">yarp_image.setExternal(img_array.__array_interface__[<span class="stringliteral">&#39;data&#39;</span>][0], img_array.shape[1], img_array.shape[0])</div>
</div><!-- fragment --><p>Obviously, since this means playing around with memory addresses, a great deal of caution is advised. If supported, buffer protocol should be preferred.</p>
<p>Array interface can also be used to easily detect whether the image has been, for whatever reason, re-allocated behind the scenes, e.g. by the <code><a class="el" href="namespaceeth_1_1parser.html#a8ec58da625146082584ad1a365bdd0e5">Port.read()</a></code> method (see section <a class="el" href="icub_python_imaging.html#sec_yarp_to_python">Receiving data from YARP to Python</a>). In the example below it is assumed that <code>yarp_image</code> has been associated with <code>img_array</code> via <code>setExternal()</code> before <code><a class="el" href="namespaceeth_1_1parser.html#a8ec58da625146082584ad1a365bdd0e5">Port.read()</a></code> is called:</p>
<div class="fragment"><div class="line">input_port.read(yarp_image)</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> yarp_image.getRawImage().__long__() &lt;&gt; img_array.__array_interface__[<span class="stringliteral">&#39;data&#39;</span>][0]:</div>
<div class="line">    <span class="keywordflow">print</span> <span class="stringliteral">&quot;read() reallocated my yarp_image!&quot;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="final_example"></a>
Real-world example</h1>
<p>Code used in this tutorial can be found at <a class="el" href="python__imaging_8py.html">python/python_imaging.py</a> In addition, the file contains a class implementing a simple image filter, which retrieves images through one YARP port, computes a Sobel operator, and sends the result to another port. To run this example, make sure you have the <a class="el" href="namespaceiCub.html" title="This file contains the definition of unique IDs for the body parts and the skin parts of the robot.">iCub</a> simulator and yarpview instance running as in examples above, and simply execute the <code>python_image.py</code> module as a regular python program.</p>
<p>This file can be edited at <a class="el" href="python-imaging_8dox.html">doc/python-imaging.dox</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 26 2024 16:02:19 for iCub-main by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
