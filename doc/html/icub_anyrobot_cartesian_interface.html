<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iCub-main: Customizing the Cartesian Interface for a Generic Robot</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iCub-main
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Customizing the Cartesian Interface for a Generic Robot </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sec_customcart_intro">Introduction</a></li>
<li class="level1"><a href="#sec_customcart_architecture">The Architecture</a></li>
<li class="level1"><a href="#sec_customcart_dependencies">Dependencies</a></li>
<li class="level1"><a href="#sec_customcart_custom_example">Example of Customization</a></li>
<li class="level1"><a href="#sec_customcart_solver_configuration">Configuring the Solver</a><ul><li class="level2"><a href="#subsec_customcart_solver_confparams">1. Retrieving Configuration Parameters</a></li>
<li class="level2"><a href="#subsec_customcart_solver_initdevices">2. Initializing Motor Devices</a></li>
<li class="level2"><a href="#subsec_customcart_solver_kininfo">3. Retrieving Kinematics Info</a></li>
<li class="level2"><a href="#subsec_customcart_solver_filldesc">4. Filling the Descriptor</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_customcart_server_configuration">Configuring the Server</a><ul><li class="level2"><a href="#subsec_customcart_server_plantident">Plant Identification (Advanced)</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_customcart_client_configuration">Configuring the Client</a></li>
<li class="level1"><a href="#sec_customcart_compile_run_example">Compiling and Running the Example</a></li>
<li class="level1"><a href="#sec_customcart_succ_stories">Success Stories</a></li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Ugo Pattacini</dd></dl>
<h1><a class="anchor" id="sec_customcart_intro"></a>
Introduction</h1>
<p>This tutorial will guide the user through the steps required to run all the components of the Cartesian Interface with the purpose of controlling a generic yarp-compatible robot limb in its operational space. Therefore, this is a somewhat advanced topic which might be of interest just for developers who want to adopt this interface for their platforms, or for those of you who are really geek inside :). <br  />
For "normal" people - who have only <a class="el" href="namespaceiCub.html" title="This file contains the definition of unique IDs for the body parts and the skin parts of the robot.">iCub</a> in their work life - the tutorial on the <a class="el" href="icub_cartesian_interface.html">Cartesian Interface</a> is extensive enough; it is also a prerequisite for proceeding further.</p>
<h1><a class="anchor" id="sec_customcart_architecture"></a>
The Architecture</h1>
<p>The architecture of the Cartesian Interface is sketched out below.</p>
<div class="image">
<img src="cartIFArchitecture.jpg" alt=""/>
<div class="caption">
The components of Cartesian Interface</div></div>
<p>We already know there is a <b>solver</b> in charge of inverting the kinematics, a <b>server</b> controlling the robot limb and finally a <b>client</b> enabling the user to forward requests for cartesian movements directly from within the code through typical calls to C++ methods. <br  />
However, the diagram is more informative than that: it tells us about how these three components are arranged in the <a class="el" href="namespaceiCub.html" title="This file contains the definition of unique IDs for the body parts and the skin parts of the robot.">iCub</a> network, an allocation that should be preserved also for your robot's architecture to achieve fast and reliable performances. Here follow the details. <br  />
</p><ul>
<li>The solver is the most computational demanding tool; for this reason it should be launched on a powerful machine belonging to the cluster of PCs connected to the robot network. It employs Ipopt for nonlinear optimization and should not be a burden to any critical routine that has to control the robot in real-time. <br  />
 Nonetheless, running on a powerful computer, the solver can tackle the inverse kinematics problem with a large number of degrees-of-freedom in near real-time (something like ~30 ms). This level of performance lets the robot do tracking pretty nicely.</li>
<li>The server is a canonical controller responsible for sending commands to the robot with the purpose of achieving the joints configuration as found by the solver by moving the limb in a human-like fashion. It is a light-weight program so that it can run directly onboard the robot hub; it collects the requests coming from all the clients, it asks the solver to do its job and feeds back clients with useful information such as the current end-effector pose.<br  />
 The main reason why the server should be running on the hub is that the lag due to the communication must be reduced as much as possible since a lag in the control loop will inevitably cause for instance unwanted overshoots in the response. As final suggestion, consider placing the server physically close to the robot, that is where fast ethernet link ends (and yarp too) and the internal robot bus begins (e.g. CAN); for <a class="el" href="namespaceiCub.html" title="This file contains the definition of unique IDs for the body parts and the skin parts of the robot.">iCub</a> indeed, the server runs aboard the icub-head.</li>
<li>The client simply lives inside the user code, making queries to the server through yarp ports, thus it never speaks to the solver. There are no special needs for it: the location of the client depends only on the requirements of the user code; a program that opens up a client may run on a shuffle PC so as on a powerful machine or even aboard the robot hub.</li>
</ul>
<h1><a class="anchor" id="sec_customcart_dependencies"></a>
Dependencies</h1>
<p>Besides the "classical" dependecies you need to have in order to compile all the components (Ipopt, yarp, icub-main, iKin, servercartesiancontroller, clientcartesiancontroller; you should know them very well by now :), you are required to accomplish a preliminary job: it can be tedious (I realize it when I had to write the "fake" stuff :) but is mandatory. You have to provide some low-level yarp motor interfaces that are necessary for the cartesian components to start and operate correctly. They are only three: <b>IControlLimits</b>, <b>IEncoders</b>, <b>IVelocityControl</b>. The former two serve to get the number of joints, their actual range along with current joints configuration which is fed back to the controller; the latter is obviously employed to send velocity commands to the robot. <br  />
Alternatively, user might consider implementing the newest <b>IEncodersTimed</b> motor interface in place of <b>IEncoders</b>, providing also information about the time stamps of the encoders that in turn will be attached to the pose information for synchronization purpose. At startup, the cartesian server will check accordingly the availability of the most suitable encoders interface. <br  />
Moreover, as enhanced option, the server is also capable of automatically detecting the availability of the <b>IPositionDirect</b> interface, through which the low-level velocity control is replaced by the faster and more accurate streaming position control. In this latter modality, also the standard <b>IPositionControl</b> interface is required to be implemented. <br  />
This is not the right place where to tell about how to deal with these interfaces, but please find out more on the topic of <a href="https://www.yarp.it/latest/group__note__devices.html">making a new device in yarp</a>.</p>
<h1><a class="anchor" id="sec_customcart_custom_example"></a>
Example of Customization</h1>
<p>Let's explain how to configure all the components for your robot through an example, whose code is available under </p><div class="fragment"><div class="line">src/anyRobotCartesianInterface.</div>
</div><!-- fragment --><p> Imagine you're done with coding the basic motor interfaces for your robot, which is not as cute as <a class="el" href="namespaceiCub.html" title="This file contains the definition of unique IDs for the body parts and the skin parts of the robot.">iCub</a>: it is equipped indeed with just three degrees-of-freedom represented by three joints controlled by three independent motors. You'll probably end up having something similar to the library <em>fakeMotorDevice</em> I wrote for our artifact. It contains the server and client implementations of such motor interfaces: again, the IControlLimits, the IEncoders and the IVelocityControl. Of course we would need now a program that simulates our fake manipulator together with the server layer that exposes a yarp access to it. Here it is: it's called <em>fakeRobot</em> and instantiates three motors that are embodied as pure integrators that give back joints positions once fed with joints velocities. <br  />
The relevant code snippet of this instantiation is located within the file <em><a class="el" href="fakeMotorDeviceServer_8cpp.html">fakeMotorDeviceServer.cpp</a></em> and resumed here for your convenience: </p><div class="fragment"><div class="line">Matrix lim(3,2);</div>
<div class="line">lim(0,0)=-180.0; lim(0,1)=180.0;                <span class="comment">// joint 0 bounds [deg]</span></div>
<div class="line">lim(1,0)=-90.0;  lim(1,1)=90.0;                 <span class="comment">// joint 1 bounds [deg]</span></div>
<div class="line">lim(2,0)=-45.0;  lim(2,1)=45.0;                 <span class="comment">// joint 2 bounds [deg]</span></div>
<div class="line"> </div>
<div class="line">Vector q0;                                      <span class="comment">// create a starting configuration q0</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;lim.rows(); i++)</div>
<div class="line">    q0.push_back((lim(i,0)+lim(i,1))/2.0);</div>
<div class="line"> </div>
<div class="line">motors=<span class="keyword">new</span> Integrator(Ts,q0,lim);               <span class="comment">// Ts is the period expressed in [s]</span></div>
</div><!-- fragment --><p> Aside from the details of the <em>Integrator</em> class (it is provided by the <a class="el" href="group__ctrlLib.html">ctrlLib</a> library), it is worth noticing here how the joints have bounds defined by the matrix <em>lim</em>.</p>
<p>Now, since you're so motivated, you've already got the kinematic description of the manipulator from your colleague who's hooked on mechanics. You have to provide the conventional Denavit-Hartenberg table of links properties as done for the fake robot in the file <em>app/conf/kinematics.ini</em>: </p><div class="fragment"><div class="line">numLinks 3      <span class="comment">// number of revolute links: currently, iKin does not handle prismatic links</span></div>
<div class="line"> </div>
<div class="line">link_0 (<a class="code" href="sine_8m.html#a3b98e2dffc6cb06a89dcb0d5c60a0206">A</a> 1.0) (D 0.0) (alpha 0.0) (<a class="code" href="sine_8m.html#aaaa5252a687ef2d373ec966bbbf630ff">offset</a> 0.0) (<a class="code" href="namespacestrain_1_1dsp_1_1fsc.html#a746ce6f9a14034939607ccead53e3fd6">min</a> -180.0) (<a class="code" href="namespacestrain_1_1dsp_1_1fsc.html#a65804363dbaa9346e53442cb1bb9d73f">max</a> 180.0)</div>
<div class="line">link_1 (<a class="code" href="sine_8m.html#a3b98e2dffc6cb06a89dcb0d5c60a0206">A</a> 1.0) (D 0.0) (alpha 0.0) (<a class="code" href="sine_8m.html#aaaa5252a687ef2d373ec966bbbf630ff">offset</a> 0.0) (<a class="code" href="namespacestrain_1_1dsp_1_1fsc.html#a746ce6f9a14034939607ccead53e3fd6">min</a> -180.0) (<a class="code" href="namespacestrain_1_1dsp_1_1fsc.html#a65804363dbaa9346e53442cb1bb9d73f">max</a> 180.0)</div>
<div class="line">link_2 (<a class="code" href="sine_8m.html#a3b98e2dffc6cb06a89dcb0d5c60a0206">A</a> 1.0) (D 0.0) (alpha 0.0) (<a class="code" href="sine_8m.html#aaaa5252a687ef2d373ec966bbbf630ff">offset</a> 0.0) (<a class="code" href="namespacestrain_1_1dsp_1_1fsc.html#a746ce6f9a14034939607ccead53e3fd6">min</a> -180.0) (<a class="code" href="namespacestrain_1_1dsp_1_1fsc.html#a65804363dbaa9346e53442cb1bb9d73f">max</a> 180.0)</div>
<div class="ttc" id="anamespacestrain_1_1dsp_1_1fsc_html_a65804363dbaa9346e53442cb1bb9d73f"><div class="ttname"><a href="namespacestrain_1_1dsp_1_1fsc.html#a65804363dbaa9346e53442cb1bb9d73f">strain::dsp::fsc::max</a></div><div class="ttdeci">const FSC max</div><div class="ttdef"><b>Definition:</b> <a href="strain_8h_source.html#l00048">strain.h:48</a></div></div>
<div class="ttc" id="anamespacestrain_1_1dsp_1_1fsc_html_a746ce6f9a14034939607ccead53e3fd6"><div class="ttname"><a href="namespacestrain_1_1dsp_1_1fsc.html#a746ce6f9a14034939607ccead53e3fd6">strain::dsp::fsc::min</a></div><div class="ttdeci">const FSC min</div><div class="ttdef"><b>Definition:</b> <a href="strain_8h_source.html#l00049">strain.h:49</a></div></div>
<div class="ttc" id="asine_8m_html_a3b98e2dffc6cb06a89dcb0d5c60a0206"><div class="ttname"><a href="sine_8m.html#a3b98e2dffc6cb06a89dcb0d5c60a0206">A</a></div><div class="ttdeci">A</div><div class="ttdef"><b>Definition:</b> <a href="sine_8m_source.html#l00016">sine.m:16</a></div></div>
<div class="ttc" id="asine_8m_html_aaaa5252a687ef2d373ec966bbbf630ff"><div class="ttname"><a href="sine_8m.html#aaaa5252a687ef2d373ec966bbbf630ff">offset</a></div><div class="ttdeci">degrees offset</div><div class="ttdef"><b>Definition:</b> <a href="sine_8m_source.html#l00004">sine.m:4</a></div></div>
</div><!-- fragment --><p> The meaning of these parameters is described in the iKinLink class; at any rate they are easily recognized as the link length (<em>A</em> in [m]), the link offset (<em>D</em> in [m]), the link twist (<em>alpha</em> in [rad]) and so on: please visit the <a href="https://icub-tech-iit.github.io/documentation/icub_kinematics/icub-forward-kinematics/icub-forward-kinematics">documentation</a> on kinematics for a deeper insight. <br  />
A careful reader should have not missed the expression for the joints limits, which here can definitely take whatever values for all the three joints, much different from the bounds assigned to the real joints and hard-coded within the fake motor device. Do not worry about that: at start-up the solver will query the low-level interface (namely <em>IControlLimits</em>) about the actual joints range and will update the kinematic structure accordingly. Later on, the server will get upgraded with a similar request to the solver. <br  />
 At this stage we are happy with the kinematics, so let's continue with the components configuration.</p>
<h1><a class="anchor" id="sec_customcart_solver_configuration"></a>
Configuring the Solver</h1>
<p>What is required here is only to inherit a new class from the iKin superclass <b>CartesianSolver</b> and then override the method <em>getPartDesc()</em> which is responsible for describing all the parts used by the solver. <br  />
Essentially, you have to do the following four things: <br  />
</p><ol type="1">
<li>Retrieve the configuration parameters;</li>
<li>Initialize the devices to access the motors;</li>
<li>Retrieve information about the kinematics;</li>
<li>Fill a descriptor to be returned to the superclass.</li>
</ol>
<h2><a class="anchor" id="subsec_customcart_solver_confparams"></a>
1. Retrieving Configuration Parameters</h2>
<p>The parameter of the <em>getPartDesc()</em> method is a <em>Searchable</em> object that should contain the initial configuration of the solver as provided for instance through the file <em>solver.ini</em> whose content is listed just below. However, these values can be easily modified at run-time through calls to the cartesian interface methods. </p><div class="fragment"><div class="line">robot          fake_robot               <span class="comment">// the name of the robot to connect to</span></div>
<div class="line">name           solver                   <span class="comment">// the name of the solver as seen in yarp network</span></div>
<div class="line">period         30                       <span class="comment">// the period of the solver in [ms]</span></div>
<div class="line">dof            (1 1 1)                  <span class="comment">// the list of links status as they&#39;ll start off: if blocked(0) or dofs(1) - see iKin doc</span></div>
<div class="line">rest_pos       (0.0 0.0 0.0)            <span class="comment">// the joints resting positions as secondary task for the solver</span></div>
<div class="line">rest_weights   (0.0 0.0 0.0)            <span class="comment">// the weights of resting positions (0.0 means do not take that joint into account)</span></div>
<div class="line">pose           full                     <span class="comment">// [full] or [xyz] for position+orientation or just position</span></div>
<div class="line">mode           shot                     <span class="comment">// [shot] or [cont] for tracking mode off/on</span></div>
<div class="line"><a class="code" href="icub-main_2src_2tools_2FirmwareUpdater_2main_8cpp.html#a1bdcfae3209cbd96db35a2ae356fa15e">verbosity</a>      off                      <span class="comment">// self-explaining :)</span></div>
<div class="line">maxIter        200                      <span class="comment">// stop solving whenever you overcome this limit</span></div>
<div class="line">tol            0.0001                   <span class="comment">// tolerance for the task</span></div>
<div class="line">constr_tol     0.000001                 <span class="comment">// tolerance for the constraints</span></div>
<div class="line">interPoints    off                      <span class="comment">// if [on] the points discovered while converging are provided as well: they might be not so adjacent</span></div>
<div class="line">ping_robot_tmo 10.0                     <span class="comment">// at start-up, while connecting to the robot, wait for this timeout in [s] before giving up</span></div>
<div class="ttc" id="aicub-main_2src_2tools_2FirmwareUpdater_2main_8cpp_html_a1bdcfae3209cbd96db35a2ae356fa15e"><div class="ttname"><a href="icub-main_2src_2tools_2FirmwareUpdater_2main_8cpp.html#a1bdcfae3209cbd96db35a2ae356fa15e">verbosity</a></div><div class="ttdeci">int verbosity</div><div class="ttdef"><b>Definition:</b> <a href="icub-main_2src_2tools_2FirmwareUpdater_2main_8cpp_source.html#l00017">main.cpp:17</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_customcart_solver_initdevices"></a>
2. Initializing Motor Devices</h2>
<p>The solver must be aware of how to open a client to speak to motor device drivers. Prepare therefore as many <em>Property</em> objects containing the suitable options as it is required by the manipulator: i.e. if the manipulator is composed of two parts (e.g. torso + arm), prepare one <em>Property</em> for each part, filled with the instructions to open the corresponding motor client. <br  />
In the current example the fake manipulator is represented by just one motor part as it follows: </p><div class="fragment"><div class="line">Property optPart;</div>
<div class="line">optPart.put(<span class="stringliteral">&quot;device&quot;</span>,<span class="stringliteral">&quot;fakeyClient&quot;</span>);                    <span class="comment">// the name of the device</span></div>
<div class="line">optPart.put(<span class="stringliteral">&quot;remote&quot;</span>,(<span class="stringliteral">&quot;/&quot;</span>+robot+<span class="stringliteral">&quot;/&quot;</span>+part).c_str());     <span class="comment">// the stem-name of the server remote yarp port</span></div>
<div class="line">optPart.put(<span class="stringliteral">&quot;local&quot;</span>,(<span class="stringliteral">&quot;/&quot;</span>+slvName+<span class="stringliteral">&quot;/&quot;</span>+part).c_str());    <span class="comment">// the tag used as stem-name for the local ports</span></div>
<div class="line">optPart.put(<span class="stringliteral">&quot;part&quot;</span>,part.c_str());                       <span class="comment">// just the name of the part for displaying purpose</span></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_customcart_solver_kininfo"></a>
3. Retrieving Kinematics Info</h2>
<p>There is a special key in the configuration file <em>solver.ini</em> which is missing: the one that tells the solver how to retrieve the kinematics description. Its tag is "CustomKinFile" and must point to the <em>kinematics.ini</em> file. The path has to be absolute and can be easily completed automatically by the <em>ResourceFinder</em> class - as you know: that's why we code it like the following: </p><div class="fragment"><div class="line">Property config;</div>
<div class="line">config.fromConfigFile(rf.findFile(<span class="stringliteral">&quot;from&quot;</span>).c_str());</div>
<div class="line">config.put(<span class="stringliteral">&quot;CustomKinFile&quot;</span>,pathToKin.c_str());</div>
</div><!-- fragment --><p>We then build up the kinematic structure by populating an <em>iKinLimb</em> object with such information: </p><div class="fragment"><div class="line">Property linksOptions;</div>
<div class="line">linksOptions.fromConfigFile(options.find(<span class="stringliteral">&quot;CustomKinFile&quot;</span>).asString().c_str());</div>
<div class="line">iKinLimb *limb=<span class="keyword">new</span> iKinLimb(linksOptions);</div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_customcart_solver_filldesc"></a>
4. Filling the Descriptor</h2>
<p>Finally, we need to provide a descriptor that in turn will be processed by the superclass: </p><div class="fragment"><div class="line">PartDescriptor *<a class="code" href="show__eyes__axes_8m.html#ac483f6ce851c9ecd9fb835ff7551737c">p</a>=<span class="keyword">new</span> PartDescriptor;</div>
<div class="line"><a class="code" href="show__eyes__axes_8m.html#ac483f6ce851c9ecd9fb835ff7551737c">p</a>-&gt;lmb=limb;                <span class="comment">// a pointer to the iKinLimb</span></div>
<div class="line"><a class="code" href="show__eyes__axes_8m.html#ac483f6ce851c9ecd9fb835ff7551737c">p</a>-&gt;chn=limb-&gt;asChain();     <span class="comment">// the associated iKinChain object</span></div>
<div class="line"><a class="code" href="show__eyes__axes_8m.html#ac483f6ce851c9ecd9fb835ff7551737c">p</a>-&gt;cns=NULL;                <span class="comment">// any further (linear) constraints on the joints other than the bounds? This requires some more effort</span></div>
<div class="line"><a class="code" href="show__eyes__axes_8m.html#ac483f6ce851c9ecd9fb835ff7551737c">p</a>-&gt;prp.push_back(optPart);  <span class="comment">// attach the options to open the device driver of the fake part</span></div>
<div class="line"><a class="code" href="show__eyes__axes_8m.html#ac483f6ce851c9ecd9fb835ff7551737c">p</a>-&gt;rvs.push_back(<span class="keyword">false</span>);    <span class="comment">// (*)</span></div>
<div class="line"><a class="code" href="show__eyes__axes_8m.html#ac483f6ce851c9ecd9fb835ff7551737c">p</a>-&gt;num=1;                   <span class="comment">// only one device driver for the whole limb</span></div>
<div class="ttc" id="ashow__eyes__axes_8m_html_ac483f6ce851c9ecd9fb835ff7551737c"><div class="ttname"><a href="show__eyes__axes_8m.html#ac483f6ce851c9ecd9fb835ff7551737c">p</a></div><div class="ttdeci">p</div><div class="ttdef"><b>Definition:</b> <a href="show__eyes__axes_8m_source.html#l00023">show_eyes_axes.m:23</a></div></div>
</div><!-- fragment --><p> (*) It may happen that the motor commands to be sent are in reversed order with respect to the order of kinematics links as in the case of the <a class="el" href="namespaceiCub.html" title="This file contains the definition of unique IDs for the body parts and the skin parts of the robot.">iCub</a> torso; if so, push a "true" in the <em>rvs</em> field for the corresponding part.</p>
<p>Whenever a limb is actuated resorting to more than one device (e.g. for <a class="el" href="namespaceiCub.html" title="This file contains the definition of unique IDs for the body parts and the skin parts of the robot.">iCub</a>: torso+arm), the following applies: </p><div class="fragment"><div class="line"><a class="code" href="show__eyes__axes_8m.html#ac483f6ce851c9ecd9fb835ff7551737c">p</a>-&gt;prp.push_back(optTorso);</div>
<div class="line"><a class="code" href="show__eyes__axes_8m.html#ac483f6ce851c9ecd9fb835ff7551737c">p</a>-&gt;prp.push_back(optArm);</div>
<div class="line"><a class="code" href="show__eyes__axes_8m.html#ac483f6ce851c9ecd9fb835ff7551737c">p</a>-&gt;rvs.push_back(<span class="keyword">true</span>);</div>
<div class="line"><a class="code" href="show__eyes__axes_8m.html#ac483f6ce851c9ecd9fb835ff7551737c">p</a>-&gt;rvs.push_back(<span class="keyword">false</span>);</div>
<div class="line"><a class="code" href="show__eyes__axes_8m.html#ac483f6ce851c9ecd9fb835ff7551737c">p</a>-&gt;num=2;</div>
</div><!-- fragment --><p> Intuitively, the insertion order depends on the links of the chain. In <a class="el" href="namespaceiCub.html" title="This file contains the definition of unique IDs for the body parts and the skin parts of the robot.">iCub</a> the three links of torso come first, hence <em>optTorso</em> is the first object to be pushed in the queue.</p>
<p>To conclude, it is worth pointing out how all the steps described above can be conveniently handled also by means of the <a class="el" href="group__iKinCartesianSolver.html">iKinCartesianSolver</a> module.</p>
<h1><a class="anchor" id="sec_customcart_server_configuration"></a>
Configuring the Server</h1>
<p>Coming to the server, life gets a bit easier. It is indeed required to open the device drivers of each involved part (in our case just one, the "fake_part"), put them into a special list, open the <em>cartesiancontrollerserver</em> device passing the proper configuration parameters that ensure the initialization of the kinematic structure, finally attach that list to such cartesian device. <br  />
The code is worth a thousand words ... </p><div class="fragment"><div class="line">Property optPart(<span class="stringliteral">&quot;(device fakeyClient)&quot;</span>);</div>
<div class="line">optPart.put(<span class="stringliteral">&quot;device&quot;</span>,<span class="stringliteral">&quot;fakeyClient&quot;</span>);</div>
<div class="line">optPart.put(<span class="stringliteral">&quot;remote&quot;</span>,<span class="stringliteral">&quot;/fake_robot/fake_part&quot;</span>);</div>
<div class="line">optPart.put(<span class="stringliteral">&quot;local&quot;</span>,<span class="stringliteral">&quot;/server/fake_part&quot;</span>);</div>
<div class="line">optPart.put(<span class="stringliteral">&quot;part&quot;</span>,<span class="stringliteral">&quot;fake_part&quot;</span>);</div>
<div class="line"> </div>
<div class="line">PolyDriver partDrv;</div>
<div class="line">partDrv.open(optPart);                                          <span class="comment">// open the device driver for the &quot;fake_part&quot;</span></div>
<div class="line"> </div>
<div class="line">Property optServer(<span class="stringliteral">&quot;(device cartesiancontrollerserver)&quot;</span>);</div>
<div class="line">optServer.fromConfigFile(rf.findFile(<span class="stringliteral">&quot;from&quot;</span>).c_str(),<span class="keyword">false</span>);    <span class="comment">// init the server options from the ResourceFinder</span></div>
<div class="line"> </div>
<div class="line">PolyDriver server;</div>
<div class="line">server.open(optServer);                                         <span class="comment">// open the cartesian controller server</span></div>
<div class="line"> </div>
<div class="line">PolyDriverList list;</div>
<div class="line">list.push(&amp;partDrv,<span class="stringliteral">&quot;fake_part&quot;</span>);                                <span class="comment">// fill the list with the given tag-name (see below)</span></div>
<div class="line"> </div>
<div class="line">IMultipleWrapper *wrapper;</div>
<div class="line">server.view(wrapper);</div>
<div class="line">wrapper-&gt;attachAll(list);                                       <span class="comment">// attach the list</span></div>
</div><!-- fragment --><p>The configuration parameters of the server are the following: </p><div class="fragment"><div class="line">[GENERAL]</div>
<div class="line">ControllerName        server              <span class="comment">// the yarp stem-name of the controller</span></div>
<div class="line">ControllerPeriod      20                  <span class="comment">// the period of the control thread</span></div>
<div class="line">SolverNameToConnect   solver              <span class="comment">// the yarp stem-name of the solver to connect to</span></div>
<div class="line">KinematicPart         custom              <span class="comment">// this is a special keyword that tells the server to open custom kinematics</span></div>
<div class="line">CustomKinFile         kinematics.ini      <span class="comment">// the file containing the description of the kinematics (full path or relative to CustomKinContext)</span></div>
<div class="line">CustomKinContext      context             <span class="comment">// the context to locate the kinematics.ini file (optional)</span></div>
<div class="line">PositionControl       off                 <span class="comment">// (*)</span></div>
<div class="line">MultipleJointsControl <a class="code" href="show__eyes__axes_8m.html#a58ab1fd68e97078232808206b850161b">on</a>                  <span class="comment">// (**)</span></div>
<div class="line">NumberOfDrivers       1                   <span class="comment">// the number of parts composing the structure</span></div>
<div class="line"> </div>
<div class="line">[DRIVER_0]                                <span class="comment">// here come the parameters for each part driver</span></div>
<div class="line">Key                   fake_part           <span class="comment">// the tag-name assigned to the part within the code</span></div>
<div class="line">JointsOrder           direct              <span class="comment">// the joints order: [direct] or [reversed] (see explanation above)</span></div>
<div class="line">MinAbsVels            (0.0 0.0 0.0)       <span class="comment">// (***)</span></div>
<div class="ttc" id="ashow__eyes__axes_8m_html_a58ab1fd68e97078232808206b850161b"><div class="ttname"><a href="show__eyes__axes_8m.html#a58ab1fd68e97078232808206b850161b">on</a></div><div class="ttdeci">grid on</div><div class="ttdef"><b>Definition:</b> <a href="show__eyes__axes_8m_source.html#l00005">show_eyes_axes.m:5</a></div></div>
</div><!-- fragment --><p> (*) When "on" this parameter enables the low-level streaming position control of the robot's joints, meaning that the server will provide as output the position set-points straightaway instead of the velocity commands. As result, we gain much faster and more accurate movements, without requiring any <em>ad-hoc</em> dynamics compensation (see below). To do that, the <b>IPositionDirect</b> interface needs to be available. <br  />
(**) When "on" allows sending references to multiple joints with one yarp command saving bandwidth; when "off" each yarp command carries reference for one single joint. <br  />
(***) This is an optional parameter that accounts joint by joint for the minimum velocity (in [deg/s]) the motors can somehow achieve, and are meant to be provided in absolute values. Whenever the controller tries to deliver velocities under these thresholds, then it switches in a bang-bang mode to finally attain the target positions.</p>
<h2><a class="anchor" id="subsec_customcart_server_plantident"></a>
Plant Identification (Advanced)</h2>
<p>This topic is somewhat advanced and is concerned with the possibility to improve the controller's performance, so that it is not strictly required for normal operations and the user might consider skipping it at the early stage of his implementation. Further, if the <b>IPositionDirect</b> interface is detected as available by the server and the <b>PositionControl</b> configuration switch is set to "on", then the presence of the section [PLANT_MODEL] described hereinafter will turn to be irrilevant to the control. <br  />
The closed-loop joint controller is designed in such a way that it delivers velocity commands to shape the system response as to follow a trajectory that resembles a minimum-jerk profile. To this end, the strong assumption is that the joint itself behaves like a pure integrator. Of course the real world deviates - sometimes significantly - from the ideal conditions and a number of unmodelled factors starts taking place. In this respect, the following two elements deserve particular care since they can be conveniently compensated: (1) the high-order plant dynamics, (2) the dead-time affecting the plant response.</p>
<p>Regarding the high-order plant dynamics, as it is traditionally envisaged, a <em>chirp</em> signal can be injected into the system with the goal of identifying any further relevant zero and/or pole of the plant. Since the overall system is always stable and minimum-phase (i.e. both further poles and zeros belong to the left side of the complex plane), it derives that the controller is capable of filtering out the unwanted dynamics with pole-zero cancellation. <br  />
The framework can thus compensate plants characterized by the following transfer function:</p>
<p class="formulaDsp">
\[ P\left(s\right)=\frac{K_p}{s}\cdot\frac{1+T_zs}{1+2\zeta T_ws+\left(T_ws\right)^2}\cdot e^{-T_ds}, \]
</p>
<p>with two underdamped poles and one zero, besides the integrator. These parameters can be specified within the server configuration file for each joint belonging to the kinematic chain. </p><div class="fragment"><div class="line">[PLANT_MODEL]</div>
<div class="line">plant_compensator off   <span class="comment">// turn on this switch to enable plant compensation</span></div>
<div class="line">smith_predictor   off   <span class="comment">// turn on this switch to enable lag equalization</span></div>
<div class="line"> </div>
<div class="line">joint_0           ((Kp 1.022) (Tz 0.405) (Tw 0.248) (Zeta 0.797) (Td 0.000))</div>
<div class="line">joint_1           ((Kp 1.026) (Tz 0.407) (Tw 0.243) (Zeta 0.822) (Td 0.000))</div>
<div class="line">joint_2           ((Kp 1.040) (Tz 0.344) (Tw 0.160) (Zeta 1.110) (Td 0.000))</div>
<div class="line">joint_3           ((Kp 1.035) (Tz 0.410) (Tw 0.178) (Zeta 1.198) (Td 0.000))</div>
<div class="line">joint_4           ((Kp 1.016) (Tz 0.384) (Tw 0.159) (Zeta 1.222) (Td 0.000))</div>
<div class="line">joint_5           ((Kp 1.025) (Tz 0.823) (Tw 0.405) (Zeta 1.030) (Td 0.000))</div>
<div class="line">joint_6           ((Kp 1.022) (Tz 0.300) (Tw 0.120) (Zeta 1.303) (Td 0.000))</div>
<div class="line">joint_7           ((Kp 1.016) (Tz 0.123) (Tw 0.030) (Zeta 2.204) (Td 0.000))</div>
<div class="line">joint_8           ((Kp 1.000) (Tz 0.000) (Tw 0.000) (Zeta 0.000) (Td 0.000))</div>
<div class="line">joint_9           ((Kp 1.000) (Tz 0.000) (Tw 0.000) (Zeta 0.000) (Td 0.000))</div>
</div><!-- fragment --><p>To give the feeling of how important could be accounting for this dynamics, take a look at the picture below, where the ideal response of a joint commanded by our velocity controller (dashed black) is depicted against the two real cases: with (green) and without (red) the compensation.</p>
<div class="image">
<img src="cartIFPlantResponse.jpg" alt=""/>
<div class="caption">
System Response with and without Plant Compensantion</div></div>
<p>Interestingly, the application <em>jointVelCtrlIdent</em> available from this <a href="https://github.com/pattacini/icub-contrib.git">GitHub repository</a> lets you collect information about the system response to the chirp command. You can then think of employing the <em>System Identification Toolbox</em> from MATLAB to find out where these unwanted poles and zero are located in the complex plane. In fact, the <em>ident</em> tool contained whithin the MATLAB package allows you to go through an identification session for the process <em>P(s)</em> specified above.</p>
<p>Finally, as very last step, one can try also to compensate the lag of the control system represented by the exponential term in the transfer function. <br  />
As you might know, a lag in a control loop is dangerous because it introduces distortions in the response. To recover the ideal response profile equalizing the lag, one common solution is to plug into the system a Smith Predictor. Nonetheless, this further block should be applied only when between the controller and the plant there exist significant and deterministic communication delays as it happens for example when the controller does not run on the robot hub.</p>
<h1><a class="anchor" id="sec_customcart_client_configuration"></a>
Configuring the Client</h1>
<p>The client does not have to be aware of any particular implementation, thus it can be configured as documented in the <a class="el" href="icub_cartesian_interface.html">Cartesian Interface</a> page. In this respect, to open a client that connects to server above one can rely on the following: </p><div class="fragment"><div class="line">Property option(<span class="stringliteral">&quot;(device cartesiancontrollerclient)&quot;</span>);</div>
<div class="line">option.put(<span class="stringliteral">&quot;remote&quot;</span>,<span class="stringliteral">&quot;/server&quot;</span>);</div>
<div class="line">option.put(<span class="stringliteral">&quot;local&quot;</span>,<span class="stringliteral">&quot;/client&quot;</span>);</div>
<div class="line"> </div>
<div class="line">PolyDriver         client;</div>
<div class="line">ICartesianControl *ctrl=NULL;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (client.open(option)) {</div>
<div class="line">    client.view(ctrl);    <span class="comment">// open the view</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_customcart_compile_run_example"></a>
Compiling and Running the Example</h1>
<p>The example has been designed according to the packaging policy we pursue for iCub-based application: there is a <em>src</em> directory filled with the library and the code and then there is an <em>app</em> directory containing the configuration files and the scripts to run the binaries. Therefore, just create the <em>anyRobotCartesianInterface/build</em> directory (be always neat and divide the code from the compilation products :), go there and launch the <em>ccmake ../</em> command. After the compilation and the installation you'll end up having the directory <em>anyRobotCartesianInterface/bin</em> where all the binaries will be copied in, along with the configuration files and the xml scripts. Run the command <em>yarprun --server /node</em> from the same directory of the binaries and then launch in a row first the modules in <em>robot_server_solver.xml</em> and soon afterwards the modules in <em>client.xml</em>.</p>
<h1><a class="anchor" id="sec_customcart_succ_stories"></a>
Success Stories</h1>
<p>You are warmly encouraged to add up below your case study on the use of Cartesian Interface:</p><ul>
<li>Duarte Arag�o employed the Cartesian Interface for his robot Vizzy and documented the development <a href="http://mediawiki.isr.ist.utl.pt/wiki/Vizzy_Cartesian_Interface">here</a>.</li>
<li>Juan G. Victores managed to replicate the Cartesian Interface functionalities for Asibot whose server part is documented <a href="http://roboticslab.sourceforge.net/asibot/group__cartesianServer.html">here</a>.</li>
<li>Elena Ceseracciu customized the Cartesian <a class="el" href="classSolver.html">Solver</a> for the ARMAR III robot. Relevant info can be browsed <a href="http://wiki.icub.org/xperience/dox/html/group__ArmarIIICartesianSolver.html">here</a>. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 26 2024 16:02:19 for iCub-main by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
