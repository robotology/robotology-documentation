<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iCub-main: iCub::iDyn::iDynNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iCub-main
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceiCub.html">iCub</a></li><li class="navelem"><a class="el" href="namespaceiCub_1_1iDyn.html">iDyn</a></li><li class="navelem"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html">iDynNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classiCub_1_1iDyn_1_1iDynNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">iCub::iDyn::iDynNode Class Reference<div class="ingroups"><a class="el" href="group__icub__modules__all.html">Software</a> &raquo; <a class="el" href="group__icub__libraries.html">Libraries</a> &raquo; <a class="el" href="group__iDyn.html">iDyn</a> &raquo; <a class="el" href="group__iDynBody.html">iDynBody</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between limbs.  
 <a href="classiCub_1_1iDyn_1_1iDynNode.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for iCub::iDyn::iDynNode:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classiCub_1_1iDyn_1_1iDynNode__inherit__graph.png" border="0" usemap="#aiCub_1_1iDyn_1_1iDynNode_inherit__map" alt="Inheritance graph"/></div>
<map name="aiCub_1_1iDyn_1_1iDynNode_inherit__map" id="aiCub_1_1iDyn_1_1iDynNode_inherit__map">
<area shape="rect" title="A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between l..." alt="" coords="52,5,213,32"/>
<area shape="rect" href="classUpTorso.html" title=" " alt="" coords="14,80,89,107"/>
<area shape="rect" href="classiCub_1_1iDyn_1_1iDynSensorNode.html" title="A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between l..." alt="" coords="113,80,318,107"/>
<area shape="rect" href="classiCub_1_1iDyn_1_1iDynSensorTorsoNode.html" title="A class for connecting a central&#45;up limb, a left and right limb of the iCub, and exchanging kinematic..." alt="" coords="96,155,335,181"/>
<area shape="rect" href="classiCub_1_1iDyn_1_1iCubLowerTorso.html" title="A class for connecting torso, left and right leg of the iCub, and exchanging kinematic and wrench inf..." alt="" coords="5,229,204,256"/>
<area shape="rect" href="classiCub_1_1iDyn_1_1iCubUpperTorso.html" title="A class for connecting head, left and right arm of the iCub, and exchanging kinematic and wrench info..." alt="" coords="228,229,427,256"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9a53a62a5df3d14d368e99efcaa09551"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a9a53a62a5df3d14d368e99efcaa09551">iDynNode</a> (const <a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a> _mode=<a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3">DYNAMIC</a>)</td></tr>
<tr class="memdesc:a9a53a62a5df3d14d368e99efcaa09551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a9a53a62a5df3d14d368e99efcaa09551">More...</a><br /></td></tr>
<tr class="separator:a9a53a62a5df3d14d368e99efcaa09551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ead90a8cf09284157951a00025c6471"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a0ead90a8cf09284157951a00025c6471">iDynNode</a> (const std::string &amp;_info, const <a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a> _mode=<a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3">DYNAMIC</a>, unsigned int verb=<a class="el" href="namespaceiCub_1_1skinDynLib.html#a790824a527802db93c40eca73839b72da16220311c35a0345c00855ea2032c695">iCub::skinDynLib::VERBOSE</a>)</td></tr>
<tr class="memdesc:a0ead90a8cf09284157951a00025c6471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with parameters.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a0ead90a8cf09284157951a00025c6471">More...</a><br /></td></tr>
<tr class="separator:a0ead90a8cf09284157951a00025c6471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d930993d89391e724637e4cd4c123b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#af1d930993d89391e724637e4cd4c123b">addLimb</a> (<a class="el" href="classiCub_1_1iDyn_1_1iDynLimb.html">iDyn::iDynLimb</a> *limb, const yarp::sig::Matrix &amp;<a class="el" href="compute__ekf__sym_8m.html#afaafc315b95987fc2b071bcd8f698b81">H</a>, const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a> kinFlow=<a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a2ade845ecc299911bc2906e1e2539064">RBT_NODE_OUT</a>, const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a> wreFlow=<a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a733307f2252a4e82441f412c04653a29">RBT_NODE_IN</a>, bool hasSensor=false)</td></tr>
<tr class="memdesc:af1d930993d89391e724637e4cd4c123b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add one limb to the node, defining its <a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html" title="A class for setting a rigid body transformation between iDynLimb and iDynNode.">RigidBodyTransformation</a>.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#af1d930993d89391e724637e4cd4c123b">More...</a><br /></td></tr>
<tr class="separator:af1d930993d89391e724637e4cd4c123b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea75d75c4a4af88cb908b58cc544fb0"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a5ea75d75c4a4af88cb908b58cc544fb0">getRBT</a> (unsigned int iLimb) const</td></tr>
<tr class="memdesc:a5ea75d75c4a4af88cb908b58cc544fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the RBT matrix of a certain limb attached to the node.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a5ea75d75c4a4af88cb908b58cc544fb0">More...</a><br /></td></tr>
<tr class="separator:a5ea75d75c4a4af88cb908b58cc544fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b3da23a78324dff920a4d90e9050bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a80b3da23a78324dff920a4d90e9050bb">solveKinematics</a> (const yarp::sig::Vector &amp;w0, const yarp::sig::Vector &amp;dw0, const yarp::sig::Vector &amp;ddp0)</td></tr>
<tr class="memdesc:a80b3da23a78324dff920a4d90e9050bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function to manage the exchange of kinematic information among the limbs attached to the node.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a80b3da23a78324dff920a4d90e9050bb">More...</a><br /></td></tr>
<tr class="separator:a80b3da23a78324dff920a4d90e9050bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55a020dd4b6cd51c3c586099a38c059"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#aa55a020dd4b6cd51c3c586099a38c059">solveKinematics</a> ()</td></tr>
<tr class="memdesc:aa55a020dd4b6cd51c3c586099a38c059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function to manage the exchange of kinematic information among the limbs attached to the node.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#aa55a020dd4b6cd51c3c586099a38c059">More...</a><br /></td></tr>
<tr class="separator:aa55a020dd4b6cd51c3c586099a38c059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62354060f29d440a9e9c36991bc868a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#ac62354060f29d440a9e9c36991bc868a">setKinematicMeasure</a> (const yarp::sig::Vector &amp;w0, const yarp::sig::Vector &amp;dw0, const yarp::sig::Vector &amp;ddp0)</td></tr>
<tr class="memdesc:ac62354060f29d440a9e9c36991bc868a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the kinematic measurement (w,dw,ddp) on the limb where the kinematic flow is of type RBT_NODE_IN.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#ac62354060f29d440a9e9c36991bc868a">More...</a><br /></td></tr>
<tr class="separator:ac62354060f29d440a9e9c36991bc868a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad166af36d544d12a2aa6c3780fb06686"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#ad166af36d544d12a2aa6c3780fb06686">solveWrench</a> ()</td></tr>
<tr class="memdesc:ad166af36d544d12a2aa6c3780fb06686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function to manage the exchange of wrench information among the limbs attached to the node.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#ad166af36d544d12a2aa6c3780fb06686">More...</a><br /></td></tr>
<tr class="separator:ad166af36d544d12a2aa6c3780fb06686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cebfe81b63f533efd2f8d89300f0a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#af1cebfe81b63f533efd2f8d89300f0a7">solveWrench</a> (const yarp::sig::Matrix &amp;FM)</td></tr>
<tr class="memdesc:af1cebfe81b63f533efd2f8d89300f0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is to manage the exchange of wrench information among the limbs attached to the node.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#af1cebfe81b63f533efd2f8d89300f0a7">More...</a><br /></td></tr>
<tr class="separator:af1cebfe81b63f533efd2f8d89300f0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa277ea9054106efe80d77e4e9c120978"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#aa277ea9054106efe80d77e4e9c120978">solveWrench</a> (const yarp::sig::Matrix &amp;<a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#afbae85fc951a816738e887545dec6d1b">F</a>, const yarp::sig::Matrix &amp;M)</td></tr>
<tr class="memdesc:aa277ea9054106efe80d77e4e9c120978"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is to manage the exchange of wrench information among the limbs attached to the node.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#aa277ea9054106efe80d77e4e9c120978">More...</a><br /></td></tr>
<tr class="separator:aa277ea9054106efe80d77e4e9c120978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baf9422767d3f38b7d63ce72c246565"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a7baf9422767d3f38b7d63ce72c246565">setWrenchMeasure</a> (const yarp::sig::Matrix &amp;<a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#afbae85fc951a816738e887545dec6d1b">F</a>, const yarp::sig::Matrix &amp;M)</td></tr>
<tr class="memdesc:a7baf9422767d3f38b7d63ce72c246565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wrench measure on the limbs with input wrench.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a7baf9422767d3f38b7d63ce72c246565">More...</a><br /></td></tr>
<tr class="separator:a7baf9422767d3f38b7d63ce72c246565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3bf2f7eaa01c9c1bea5444e52f7ee8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a3c3bf2f7eaa01c9c1bea5444e52f7ee8">setWrenchMeasure</a> (const yarp::sig::Matrix &amp;FM)</td></tr>
<tr class="memdesc:a3c3bf2f7eaa01c9c1bea5444e52f7ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wrench measure on the limbs with input wrench.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a3c3bf2f7eaa01c9c1bea5444e52f7ee8">More...</a><br /></td></tr>
<tr class="separator:a3c3bf2f7eaa01c9c1bea5444e52f7ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49993bd267e6b663221d70ed0a3b3f37"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a49993bd267e6b663221d70ed0a3b3f37">getForce</a> () const</td></tr>
<tr class="memdesc:a49993bd267e6b663221d70ed0a3b3f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node force.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a49993bd267e6b663221d70ed0a3b3f37">More...</a><br /></td></tr>
<tr class="separator:a49993bd267e6b663221d70ed0a3b3f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d1306faec97f30675d668b620c6409"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a43d1306faec97f30675d668b620c6409">getMoment</a> () const</td></tr>
<tr class="memdesc:a43d1306faec97f30675d668b620c6409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node moment.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a43d1306faec97f30675d668b620c6409">More...</a><br /></td></tr>
<tr class="separator:a43d1306faec97f30675d668b620c6409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aaa82fdf13d57f059a9e2f12af4380"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a90aaa82fdf13d57f059a9e2f12af4380">getAngVel</a> () const</td></tr>
<tr class="memdesc:a90aaa82fdf13d57f059a9e2f12af4380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node angular velocity.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a90aaa82fdf13d57f059a9e2f12af4380">More...</a><br /></td></tr>
<tr class="separator:a90aaa82fdf13d57f059a9e2f12af4380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f004d511bde994e2a5ab5108f59cf5d"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a3f004d511bde994e2a5ab5108f59cf5d">getAngAcc</a> () const</td></tr>
<tr class="memdesc:a3f004d511bde994e2a5ab5108f59cf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node angular acceleration.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a3f004d511bde994e2a5ab5108f59cf5d">More...</a><br /></td></tr>
<tr class="separator:a3f004d511bde994e2a5ab5108f59cf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb96b671aed849b4b815a9552e2c059f"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#abb96b671aed849b4b815a9552e2c059f">getLinAcc</a> () const</td></tr>
<tr class="memdesc:abb96b671aed849b4b815a9552e2c059f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node linear acceleration.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#abb96b671aed849b4b815a9552e2c059f">More...</a><br /></td></tr>
<tr class="separator:abb96b671aed849b4b815a9552e2c059f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73ef1a6dbf022982665ec558bd84450"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#ac73ef1a6dbf022982665ec558bd84450">computeJacobian</a> (unsigned int iChain)</td></tr>
<tr class="memdesc:ac73ef1a6dbf022982665ec558bd84450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Jacobian of the limb with index iChain in the node, in its default direction (as it would be done by <a class="el" href="namespaceiCub_1_1iKin.html">iKin</a>).  <a href="classiCub_1_1iDyn_1_1iDynNode.html#ac73ef1a6dbf022982665ec558bd84450">More...</a><br /></td></tr>
<tr class="separator:ac73ef1a6dbf022982665ec558bd84450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3df54f3b7732d811b7d455254f54943"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#ab3df54f3b7732d811b7d455254f54943">computeJacobian</a> (unsigned int iChain, unsigned int iLink)</td></tr>
<tr class="memdesc:ab3df54f3b7732d811b7d455254f54943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Jacobian of the i-th link of the limb with index iChain in the node, in its default direction (as it would be done by <a class="el" href="namespaceiCub_1_1iKin.html">iKin</a>).  <a href="classiCub_1_1iDyn_1_1iDynNode.html#ab3df54f3b7732d811b7d455254f54943">More...</a><br /></td></tr>
<tr class="separator:ab3df54f3b7732d811b7d455254f54943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5010cc99800cced452459d674a21e665"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a5010cc99800cced452459d674a21e665">computeJacobian</a> (unsigned int iChainA, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirA, unsigned int iChainB, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirB)</td></tr>
<tr class="memdesc:a5010cc99800cced452459d674a21e665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Jacobian between two links in two different chains.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a5010cc99800cced452459d674a21e665">More...</a><br /></td></tr>
<tr class="separator:a5010cc99800cced452459d674a21e665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fd9aebc74f6bc4b9a57a593c36dfc9"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a48fd9aebc74f6bc4b9a57a593c36dfc9">computeJacobian</a> (unsigned int iChainA, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirA, unsigned int iChainB, unsigned int iLinkB, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirB)</td></tr>
<tr class="memdesc:a48fd9aebc74f6bc4b9a57a593c36dfc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Jacobian between two links in two different chains.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a48fd9aebc74f6bc4b9a57a593c36dfc9">More...</a><br /></td></tr>
<tr class="separator:a48fd9aebc74f6bc4b9a57a593c36dfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb7948ffb0c9eafb1d9cd9741cc38ca"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a7eb7948ffb0c9eafb1d9cd9741cc38ca">computePose</a> (unsigned int iChainA, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirA, unsigned int iChainB, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirB, const bool axisRep)</td></tr>
<tr class="memdesc:a7eb7948ffb0c9eafb1d9cd9741cc38ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Pose of the end-effector, given a "virtual" chain connecting two limbs.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a7eb7948ffb0c9eafb1d9cd9741cc38ca">More...</a><br /></td></tr>
<tr class="separator:a7eb7948ffb0c9eafb1d9cd9741cc38ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded1c0769eebf83dbfbbea34d078f99e"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#aded1c0769eebf83dbfbbea34d078f99e">computePose</a> (unsigned int iChainA, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirA, unsigned int iChainB, unsigned int iLinkB, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirB, const bool axisRep)</td></tr>
<tr class="memdesc:aded1c0769eebf83dbfbbea34d078f99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Pose of the end-effector, given a "virtual" chain connecting two limbs.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#aded1c0769eebf83dbfbbea34d078f99e">More...</a><br /></td></tr>
<tr class="separator:aded1c0769eebf83dbfbbea34d078f99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa106c9340f7e2ffd57305868ac5c87a2"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#aa106c9340f7e2ffd57305868ac5c87a2">TESTING_computeCOMJacobian</a> (unsigned int iChain, unsigned int iLink)</td></tr>
<tr class="memdesc:aa106c9340f7e2ffd57305868ac5c87a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Jacobian of the COM of the i-th link of the limb with index iChain in the node.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#aa106c9340f7e2ffd57305868ac5c87a2">More...</a><br /></td></tr>
<tr class="separator:aa106c9340f7e2ffd57305868ac5c87a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93feed610e2fbfc9c1f254668a3ee6f9"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a93feed610e2fbfc9c1f254668a3ee6f9">TESTING_computeCOMJacobian</a> (unsigned int iChainA, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirA, unsigned int iChainB, unsigned int iLinkB, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirB)</td></tr>
<tr class="memdesc:a93feed610e2fbfc9c1f254668a3ee6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Jacobian of the COM of link iLinkB, in chainB, when two different chains (A and B) are connected.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a93feed610e2fbfc9c1f254668a3ee6f9">More...</a><br /></td></tr>
<tr class="separator:a93feed610e2fbfc9c1f254668a3ee6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aea991e45c7d4b8bda29189071dffc5d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#aea991e45c7d4b8bda29189071dffc5d5">zero</a> ()</td></tr>
<tr class="memdesc:aea991e45c7d4b8bda29189071dffc5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all data to zero.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#aea991e45c7d4b8bda29189071dffc5d5">More...</a><br /></td></tr>
<tr class="separator:aea991e45c7d4b8bda29189071dffc5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693d676c499a4356d1696a24692d915c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a693d676c499a4356d1696a24692d915c">compute_Pn_HAN</a> (unsigned int iChainA, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirA, unsigned int iChainB, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirB, yarp::sig::Matrix &amp;Pn, yarp::sig::Matrix &amp;H_A_Node)</td></tr>
<tr class="memdesc:a693d676c499a4356d1696a24692d915c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Pn and H_A_Node matrices given two chains.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a693d676c499a4356d1696a24692d915c">More...</a><br /></td></tr>
<tr class="separator:a693d676c499a4356d1696a24692d915c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1daa891c049fadbede769ad26a6cfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#ace1daa891c049fadbede769ad26a6cfa">compute_Pn_HAN</a> (unsigned int iChainA, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirA, unsigned int iChainB, unsigned int iLinkB, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirB, yarp::sig::Matrix &amp;Pn, yarp::sig::Matrix &amp;H_A_Node)</td></tr>
<tr class="memdesc:ace1daa891c049fadbede769ad26a6cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Pn and H_A_Node matrices given two chains.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#ace1daa891c049fadbede769ad26a6cfa">More...</a><br /></td></tr>
<tr class="separator:ace1daa891c049fadbede769ad26a6cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc620c5393e599eed31dba2335b34192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#adc620c5393e599eed31dba2335b34192">compute_Pn_HAN_COM</a> (unsigned int iChainA, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirA, unsigned int iChainB, unsigned int iLinkB, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirB, yarp::sig::Matrix &amp;Pn, yarp::sig::Matrix &amp;H_A_Node)</td></tr>
<tr class="memdesc:adc620c5393e599eed31dba2335b34192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Pn and H_A_Node matrices given two chains.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#adc620c5393e599eed31dba2335b34192">More...</a><br /></td></tr>
<tr class="separator:adc620c5393e599eed31dba2335b34192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6609ff72c5f8fdbb48d232a6a4d84d65"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a6609ff72c5f8fdbb48d232a6a4d84d65">howManyWrenchInputs</a> (bool afterAttach=false) const</td></tr>
<tr class="memdesc:a6609ff72c5f8fdbb48d232a6a4d84d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of limbs with wrench input, i.e.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a6609ff72c5f8fdbb48d232a6a4d84d65">More...</a><br /></td></tr>
<tr class="separator:a6609ff72c5f8fdbb48d232a6a4d84d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3feea80c9d503b766d37afe108be6ce2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a3feea80c9d503b766d37afe108be6ce2">howManyKinematicInputs</a> (bool afterAttach=false) const</td></tr>
<tr class="memdesc:a3feea80c9d503b766d37afe108be6ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of limbs with kinematic input, i.e.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a3feea80c9d503b766d37afe108be6ce2">More...</a><br /></td></tr>
<tr class="separator:a3feea80c9d503b766d37afe108be6ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa2348a39cc0576e4de7624580a6997b9"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html">RigidBodyTransformation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#aa2348a39cc0576e4de7624580a6997b9">rbtList</a></td></tr>
<tr class="memdesc:aa2348a39cc0576e4de7624580a6997b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">the list of RBT  <a href="classiCub_1_1iDyn_1_1iDynNode.html#aa2348a39cc0576e4de7624580a6997b9">More...</a><br /></td></tr>
<tr class="separator:aa2348a39cc0576e4de7624580a6997b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4212761245758347118b0b685b83bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a6a4212761245758347118b0b685b83bf">mode</a></td></tr>
<tr class="memdesc:a6a4212761245758347118b0b685b83bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">STATIC/DYNAMIC/DYNAMIC_W_ROTOR/DYNAMIC_CORIOLIS_GRAVITY.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a6a4212761245758347118b0b685b83bf">More...</a><br /></td></tr>
<tr class="separator:a6a4212761245758347118b0b685b83bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c71d184a9385364ca17ac8acb134f99"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a9c71d184a9385364ca17ac8acb134f99">info</a></td></tr>
<tr class="memdesc:a9c71d184a9385364ca17ac8acb134f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">info or useful notes  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a9c71d184a9385364ca17ac8acb134f99">More...</a><br /></td></tr>
<tr class="separator:a9c71d184a9385364ca17ac8acb134f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fca92c14ebe1efb92463eb77ed67352"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a5fca92c14ebe1efb92463eb77ed67352">verbose</a></td></tr>
<tr class="memdesc:a5fca92c14ebe1efb92463eb77ed67352"><td class="mdescLeft">&#160;</td><td class="mdescRight">verbosity flag  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a5fca92c14ebe1efb92463eb77ed67352">More...</a><br /></td></tr>
<tr class="separator:a5fca92c14ebe1efb92463eb77ed67352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a74e80b0abb7063546f8b261bf359f"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a74a74e80b0abb7063546f8b261bf359f">w</a></td></tr>
<tr class="memdesc:a74a74e80b0abb7063546f8b261bf359f"><td class="mdescLeft">&#160;</td><td class="mdescRight">angular velocity  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a74a74e80b0abb7063546f8b261bf359f">More...</a><br /></td></tr>
<tr class="separator:a74a74e80b0abb7063546f8b261bf359f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03a7e6af6ef82ff22fe36456329d2c8"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#ad03a7e6af6ef82ff22fe36456329d2c8">dw</a></td></tr>
<tr class="memdesc:ad03a7e6af6ef82ff22fe36456329d2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">angular acceleration  <a href="classiCub_1_1iDyn_1_1iDynNode.html#ad03a7e6af6ef82ff22fe36456329d2c8">More...</a><br /></td></tr>
<tr class="separator:ad03a7e6af6ef82ff22fe36456329d2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c97b6d7b00ae9252f0c8b336a60e30c"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a0c97b6d7b00ae9252f0c8b336a60e30c">ddp</a></td></tr>
<tr class="memdesc:a0c97b6d7b00ae9252f0c8b336a60e30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear acceleration  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a0c97b6d7b00ae9252f0c8b336a60e30c">More...</a><br /></td></tr>
<tr class="separator:a0c97b6d7b00ae9252f0c8b336a60e30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbae85fc951a816738e887545dec6d1b"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#afbae85fc951a816738e887545dec6d1b">F</a></td></tr>
<tr class="memdesc:afbae85fc951a816738e887545dec6d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">force  <a href="classiCub_1_1iDyn_1_1iDynNode.html#afbae85fc951a816738e887545dec6d1b">More...</a><br /></td></tr>
<tr class="separator:afbae85fc951a816738e887545dec6d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d77ab92e63190024ee4b8c8e116637"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a80d77ab92e63190024ee4b8c8e116637">Mu</a></td></tr>
<tr class="memdesc:a80d77ab92e63190024ee4b8c8e116637"><td class="mdescLeft">&#160;</td><td class="mdescRight">moment  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a80d77ab92e63190024ee4b8c8e116637">More...</a><br /></td></tr>
<tr class="separator:a80d77ab92e63190024ee4b8c8e116637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ec3966a72191b31f266809403bfd06"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#af1ec3966a72191b31f266809403bfd06">COM</a></td></tr>
<tr class="memdesc:af1ec3966a72191b31f266809403bfd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">COM position of the node.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#af1ec3966a72191b31f266809403bfd06">More...</a><br /></td></tr>
<tr class="separator:af1ec3966a72191b31f266809403bfd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5db3235dc804286712724c035345412"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#ad5db3235dc804286712724c035345412">mass</a></td></tr>
<tr class="memdesc:ad5db3235dc804286712724c035345412"><td class="mdescLeft">&#160;</td><td class="mdescRight">total mass of the node  <a href="classiCub_1_1iDyn_1_1iDynNode.html#ad5db3235dc804286712724c035345412">More...</a><br /></td></tr>
<tr class="separator:ad5db3235dc804286712724c035345412"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between limbs. </p>
<p>A virtual node, connecting multiple limbs, is set. The limbs can exchange kinematics and wrench information with the node through a RigidBodyTransfromation. The node only has kinematic (w,dw,ddp) and wrench (F,Mu) information: no mass, length, inertia, COM, or else. Each limb is connected to the node by a roto-translation matrix, which must be set when a limb is attached to the node: a RigidBodyTransfromation object is then created, which allows the proper computation of wrench and kinematic variables. When multiple limbs are attached to a node, the kinematic variables are set by a single limb, having kinematic flow = RBT_NODE_IN, while the wrench variables are found as the sum of the wrench contribution of all the links (inbound and outbound wrenches must balance in the node). </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00531">531</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9a53a62a5df3d14d368e99efcaa09551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a53a62a5df3d14d368e99efcaa09551">&#9670;&nbsp;</a></span>iDynNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iDynNode::iDynNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a>&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3">DYNAMIC</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_mode</td><td>the modality for dynamic computation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00416">416</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a0ead90a8cf09284157951a00025c6471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ead90a8cf09284157951a00025c6471">&#9670;&nbsp;</a></span>iDynNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iDynNode::iDynNode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a>&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3">DYNAMIC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>verb</em> = <code><a class="el" href="namespaceiCub_1_1skinDynLib.html#a790824a527802db93c40eca73839b72da16220311c35a0345c00855ea2032c695">iCub::skinDynLib::VERBOSE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor with parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_info</td><td>some information on the node, i.e. its description </td></tr>
    <tr><td class="paramname">_mode</td><td>the modality for dynamic computation </td></tr>
    <tr><td class="paramname">verb</td><td>verbosity level </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00424">424</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af1d930993d89391e724637e4cd4c123b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d930993d89391e724637e4cd4c123b">&#9670;&nbsp;</a></span>addLimb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iDynNode::addLimb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiCub_1_1iDyn_1_1iDynLimb.html">iDyn::iDynLimb</a> *&#160;</td>
          <td class="paramname"><em>limb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a>&#160;</td>
          <td class="paramname"><em>kinFlow</em> = <code><a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a2ade845ecc299911bc2906e1e2539064">RBT_NODE_OUT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a>&#160;</td>
          <td class="paramname"><em>wreFlow</em> = <code><a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a733307f2252a4e82441f412c04653a29">RBT_NODE_IN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hasSensor</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add one limb to the node, defining its <a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html" title="A class for setting a rigid body transformation between iDynLimb and iDynNode.">RigidBodyTransformation</a>. </p>
<p>A new <a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html" title="A class for setting a rigid body transformation between iDynLimb and iDynNode.">RigidBodyTransformation</a> is added to the RBT list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limb</td><td>pointer to generic limb </td></tr>
    <tr><td class="paramname">H</td><td>a (4x4) roto-translational matrix defining the transformation between node and limb base/end </td></tr>
    <tr><td class="paramname">kinFlow</td><td>the type of information flow of kinematics variables </td></tr>
    <tr><td class="paramname">wreFlow</td><td>the type of information flow of wrench variables </td></tr>
    <tr><td class="paramname">hasSensor</td><td>flag for having or not a FT sensor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00442">442</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a693d676c499a4356d1696a24692d915c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693d676c499a4356d1696a24692d915c">&#9670;&nbsp;</a></span>compute_Pn_HAN() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iCub::iDyn::iDynNode::compute_Pn_HAN </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChainA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a>&#160;</td>
          <td class="paramname"><em>dirA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChainB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a>&#160;</td>
          <td class="paramname"><em>dirB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>Pn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>H_A_Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute Pn and H_A_Node matrices given two chains. </p>
<p>This function is private, and is used by <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#ac73ef1a6dbf022982665ec558bd84450" title="Compute the Jacobian of the limb with index iChain in the node, in its default direction (as it would...">computeJacobian()</a> and <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a7eb7948ffb0c9eafb1d9cd9741cc38ca" title="Compute the Pose of the end-effector, given a &quot;virtual&quot; chain connecting two limbs.">computePose()</a> to merely avoid code duplication. </p>

</div>
</div>
<a id="ace1daa891c049fadbede769ad26a6cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1daa891c049fadbede769ad26a6cfa">&#9670;&nbsp;</a></span>compute_Pn_HAN() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iCub::iDyn::iDynNode::compute_Pn_HAN </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChainA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a>&#160;</td>
          <td class="paramname"><em>dirA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChainB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iLinkB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a>&#160;</td>
          <td class="paramname"><em>dirB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>Pn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>H_A_Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute Pn and H_A_Node matrices given two chains. </p>
<p>This function is private, and is used by <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#ac73ef1a6dbf022982665ec558bd84450" title="Compute the Jacobian of the limb with index iChain in the node, in its default direction (as it would...">computeJacobian()</a> and <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a7eb7948ffb0c9eafb1d9cd9741cc38ca" title="Compute the Pose of the end-effector, given a &quot;virtual&quot; chain connecting two limbs.">computePose()</a> to merely avoid code duplication. </p>

</div>
</div>
<a id="adc620c5393e599eed31dba2335b34192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc620c5393e599eed31dba2335b34192">&#9670;&nbsp;</a></span>compute_Pn_HAN_COM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iDynNode::compute_Pn_HAN_COM </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChainA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a>&#160;</td>
          <td class="paramname"><em>dirA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChainB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iLinkB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a>&#160;</td>
          <td class="paramname"><em>dirB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>Pn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>H_A_Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute Pn and H_A_Node matrices given two chains. </p>
<p>This function is private, and is used by computeCOMJacobian() and computeCOMPose() to merely avoid code duplication. </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l01281">1281</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="ac73ef1a6dbf022982665ec558bd84450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73ef1a6dbf022982665ec558bd84450">&#9670;&nbsp;</a></span>computeJacobian() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix iDynNode::computeJacobian </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Jacobian of the limb with index iChain in the node, in its default direction (as it would be done by <a class="el" href="namespaceiCub_1_1iKin.html">iKin</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChain</td><td>the index of the chain (limb) in the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00834">834</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="ab3df54f3b7732d811b7d455254f54943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3df54f3b7732d811b7d455254f54943">&#9670;&nbsp;</a></span>computeJacobian() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix iDynNode::computeJacobian </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iLink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Jacobian of the i-th link of the limb with index iChain in the node, in its default direction (as it would be done by <a class="el" href="namespaceiCub_1_1iKin.html">iKin</a>). </p>
<p>If the link index is not correct, a null Jacobian is returned.</p>
<p>Important note: since we are specifying the link index in the chain, the Jacobian computation will deal with all the links, even blocked links. The Jacobian size is not 6x(the DOF until iLinkB) but 6xiLinkB, where 0&lt;iLinkB&lt;N</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChain</td><td>the index of the chain (limb) in the node </td></tr>
    <tr><td class="paramname">iLink</td><td>the index of the limnk in the limb </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00847">847</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a5010cc99800cced452459d674a21e665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5010cc99800cced452459d674a21e665">&#9670;&nbsp;</a></span>computeJacobian() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix iDynNode::computeJacobian </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChainA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a>&#160;</td>
          <td class="paramname"><em>dirA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChainB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a>&#160;</td>
          <td class="paramname"><em>dirB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Jacobian between two links in two different chains. </p>
<p>The chains are specified by their index in the list (the progressive number of insertion). The first limb (limb A - index=iChainA) has the base link of the jacobian while the second limb (limb B - index=iChainB) has the final link of the jacobian. Whether the base/final of the Jacobian coincides with the base/end of the chains, depends on the flags dirA,dirB: if dirA=JAC_DIR, then the beginning is at the base of chain, otherwise it is at the end-effector; if dirB=JAC_DIR, the final link of the jacobian is on the end-effector of the chain, otherwise on its base. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChainA</td><td>the index of the chain (the limb) in the node having the base frame </td></tr>
    <tr><td class="paramname">dirA</td><td>the 'direction' of the chain wrt the jacobian computation </td></tr>
    <tr><td class="paramname">iChainB</td><td>the index of the chain (the limb) in the node having the final frame </td></tr>
    <tr><td class="paramname">dirB</td><td>the 'direction' of the chain wrt the jacobian computation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00862">862</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a48fd9aebc74f6bc4b9a57a593c36dfc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fd9aebc74f6bc4b9a57a593c36dfc9">&#9670;&nbsp;</a></span>computeJacobian() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix iDynNode::computeJacobian </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChainA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a>&#160;</td>
          <td class="paramname"><em>dirA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChainB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iLinkB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a>&#160;</td>
          <td class="paramname"><em>dirB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Jacobian between two links in two different chains. </p>
<p>The chains are specified by their index in the list (the progressive number of insertion). The first limb has the base of the jacobian (base or end-effector of the limb, depending on the Jacobian direction JacA) while the second limb (limb B - index=iChainB) has the final link of the jacobian (index=iLinkB).</p>
<p>Important note: since we are specifying the link index in chain B, the Jacobian computation on chain B will deal with all the links, even blocked links. The Jacobian size is not 6x(DOF_A + the DOF until iLinkB) but 6x(DOF_A+iLinkB), where 0&lt;iLinkB&lt;N</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChainA</td><td>the index of the chain (the limb) in the node having the base (&lt;0&gt;) frame </td></tr>
    <tr><td class="paramname">dirA</td><td>the 'direction' of the chain wrt the jacobian computation </td></tr>
    <tr><td class="paramname">iChainB</td><td>the index of the chain (the limb) in the node having the final (&lt;N&gt;) frame </td></tr>
    <tr><td class="paramname">iLinkB</td><td>the index of the link, in the indexChainN chain, being the final (&lt;N&gt;) frame for the Jacobian computation </td></tr>
    <tr><td class="paramname">dirB</td><td>the 'direction' of the chain wrt the jacobian computation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00927">927</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a7eb7948ffb0c9eafb1d9cd9741cc38ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb7948ffb0c9eafb1d9cd9741cc38ca">&#9670;&nbsp;</a></span>computePose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector iDynNode::computePose </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChainA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a>&#160;</td>
          <td class="paramname"><em>dirA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChainB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a>&#160;</td>
          <td class="paramname"><em>dirB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>axisRep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Pose of the end-effector, given a "virtual" chain connecting two limbs. </p>
<p>The chains are specified by their index in the list (the progressive number of insertion). The first limb (limb A - index=iChainA) has the base link of the augmented chain while the second limb (limb B - index=iChainB) has the final link of the augmented chain . Whether the base/end of the augmented chain coincides with the base/end of the single chains, depends on the flags dirA,dirB: if dirA=JAC_DIR, then the beginning is at the base of chain, otherwise it is at the end-effector; if dirB=JAC_DIR, the final link of the augmented chain is on the end-effector of the chain, otherwise on its base. This method is useful to compute the end-effector pose (i.e. computing the arm pose, when the chain torso + arm is considered) in a multi-limb chain. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChainA</td><td>the index of the chain (the limb) in the node having the base frame </td></tr>
    <tr><td class="paramname">dirA</td><td>the 'direction' of visit of the chain </td></tr>
    <tr><td class="paramname">iChainB</td><td>the index of the chain (the limb) in the node having the final frame </td></tr>
    <tr><td class="paramname">dirB</td><td>the 'direction' of visit of the chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l01062">1062</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="aded1c0769eebf83dbfbbea34d078f99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded1c0769eebf83dbfbbea34d078f99e">&#9670;&nbsp;</a></span>computePose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector iDynNode::computePose </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChainA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a>&#160;</td>
          <td class="paramname"><em>dirA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChainB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iLinkB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a>&#160;</td>
          <td class="paramname"><em>dirB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>axisRep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Pose of the end-effector, given a "virtual" chain connecting two limbs. </p>
<p>The chains are specified by their index in the list (the progressive number of insertion). The first limb (limb A - index=iChainA) has the base link of the augmented chain while the second limb (limb B - index=iChainB) has the final link of the augmented chain, ending in the link iLinkB. Whether the base/end of the augmented chain coincides with the base/end of the single chains, depends on the flags dirA,dirB: if dirA=JAC_DIR, then the beginning is at the base of chain, otherwise it is at the end-effector; if dirB=JAC_DIR, the final link of the augmented chain is on the end-effector of the chain, otherwise on its base. This method is useful to compute the end-effector pose (i.e. computing the elbow pose, when the chain torso + arm is considered) in a multi-limb chain. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChainA</td><td>the index of the chain (the limb) in the node having the base frame </td></tr>
    <tr><td class="paramname">dirA</td><td>the 'direction' of visit of the chain </td></tr>
    <tr><td class="paramname">iChainB</td><td>the index of the chain (the limb) in the node having the final frame </td></tr>
    <tr><td class="paramname">iLinkB</td><td>the index of the link, in the indexChainN chain, being the final (&lt;N&gt;) frame for the Jacobian computation </td></tr>
    <tr><td class="paramname">dirB</td><td>the 'direction' of visit of the chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l01122">1122</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a3f004d511bde994e2a5ab5108f59cf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f004d511bde994e2a5ab5108f59cf5d">&#9670;&nbsp;</a></span>getAngAcc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector iDynNode::getAngAcc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the node angular acceleration. </p>
<dl class="section return"><dt>Returns</dt><dd>the node angular acceleration </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00823">823</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a90aaa82fdf13d57f059a9e2f12af4380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90aaa82fdf13d57f059a9e2f12af4380">&#9670;&nbsp;</a></span>getAngVel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector iDynNode::getAngVel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the node angular velocity. </p>
<dl class="section return"><dt>Returns</dt><dd>the node angular velocity </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00821">821</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a49993bd267e6b663221d70ed0a3b3f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49993bd267e6b663221d70ed0a3b3f37">&#9670;&nbsp;</a></span>getForce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector iDynNode::getForce </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the node force. </p>
<dl class="section return"><dt>Returns</dt><dd>the node force </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00817">817</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="abb96b671aed849b4b815a9552e2c059f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb96b671aed849b4b815a9552e2c059f">&#9670;&nbsp;</a></span>getLinAcc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector iDynNode::getLinAcc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the node linear acceleration. </p>
<dl class="section return"><dt>Returns</dt><dd>the node linear acceleration </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00825">825</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a43d1306faec97f30675d668b620c6409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d1306faec97f30675d668b620c6409">&#9670;&nbsp;</a></span>getMoment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector iDynNode::getMoment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the node moment. </p>
<dl class="section return"><dt>Returns</dt><dd>the node moment </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00819">819</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a5ea75d75c4a4af88cb908b58cc544fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea75d75c4a4af88cb908b58cc544fb0">&#9670;&nbsp;</a></span>getRBT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix iDynNode::getRBT </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iLimb</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the RBT matrix of a certain limb attached to the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iLimb</td><td>the index of the limb - the index is the number of insertion of the limb in the node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the RBT matrix of that limb, attached to the node </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00449">449</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a3feea80c9d503b766d37afe108be6ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3feea80c9d503b766d37afe108be6ce2">&#9670;&nbsp;</a></span>howManyKinematicInputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int iDynNode::howManyKinematicInputs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>afterAttach</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of limbs with kinematic input, i.e. </p>
<p>receiving kinematic information from external measurements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">afterAttach</td><td>=true only if the limb received kinematic parameters during an attachTorso() procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of limbs with kinematic input, if afterAttach=false; if afterAttach=true, the number is of limbs - 1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00801">801</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a6609ff72c5f8fdbb48d232a6a4d84d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6609ff72c5f8fdbb48d232a6a4d84d65">&#9670;&nbsp;</a></span>howManyWrenchInputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int iDynNode::howManyWrenchInputs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>afterAttach</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of limbs with wrench input, i.e. </p>
<p>receiving wrench information from external measurements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">afterAttach</td><td>=true only if the limb received wrench parameters during an attachTorso() procedure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of limbs with wrench input, if afterAttach=false; if afterAttach=true, the number is of limbs - 1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00785">785</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="ac62354060f29d440a9e9c36991bc868a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62354060f29d440a9e9c36991bc868a">&#9670;&nbsp;</a></span>setKinematicMeasure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynNode::setKinematicMeasure </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>w0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>dw0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>ddp0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the kinematic measurement (w,dw,ddp) on the limb where the kinematic flow is of type RBT_NODE_IN. </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00561">561</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a7baf9422767d3f38b7d63ce72c246565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7baf9422767d3f38b7d63ce72c246565">&#9670;&nbsp;</a></span>setWrenchMeasure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool iCub::iDyn::iDynNode::setWrenchMeasure </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the wrench measure on the limbs with input wrench. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>a (3xN) matrix with forces </td></tr>
    <tr><td class="paramname">M</td><td>a (3xN) matrix with moments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeds, false otherwise </dd></dl>

</div>
</div>
<a id="a3c3bf2f7eaa01c9c1bea5444e52f7ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3bf2f7eaa01c9c1bea5444e52f7ee8">&#9670;&nbsp;</a></span>setWrenchMeasure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool iCub::iDyn::iDynNode::setWrenchMeasure </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>FM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the wrench measure on the limbs with input wrench. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FM</td><td>a (6xN) matrix with forces and moments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeds, false otherwise </dd></dl>

</div>
</div>
<a id="aa55a020dd4b6cd51c3c586099a38c059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55a020dd4b6cd51c3c586099a38c059">&#9670;&nbsp;</a></span>solveKinematics() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynNode::solveKinematics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function to manage the exchange of kinematic information among the limbs attached to the node. </p>
<dl class="section return"><dt>Returns</dt><dd>true if succeeds, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00462">462</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a80b3da23a78324dff920a4d90e9050bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b3da23a78324dff920a4d90e9050bb">&#9670;&nbsp;</a></span>solveKinematics() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iCub::iDyn::iDynNode::solveKinematics </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>w0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>dw0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Vector &amp;&#160;</td>
          <td class="paramname"><em>ddp0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function to manage the exchange of kinematic information among the limbs attached to the node. </p>
<p>One single limb with kinematic flow of input type must exist: this limb is initilized with the kinematic variables w0,dw0,ddp0 (eg the up receives this information from the inertia sensor). The limb itself knows where to init the chain (base/end) depending on how it is attached to the node. Then the first limb kinematics is solved. The kinematic variables are retrieved from the RBT, which applies its roto-translation. Then the kinematic variables are sent to the other limbs, having kinematic flow of output type: the RBT transformation is applied from node to limb. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w0</td><td>the initial/measured angular velocity </td></tr>
    <tr><td class="paramname">dw0</td><td>the initial/measured angular acceleration </td></tr>
    <tr><td class="paramname">ddp0</td><td>the initial/measured linear acceleration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeds, false otherwise </dd></dl>

</div>
</div>
<a id="ad166af36d544d12a2aa6c3780fb06686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad166af36d544d12a2aa6c3780fb06686">&#9670;&nbsp;</a></span>solveWrench() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynNode::solveWrench </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Main function to manage the exchange of wrench information among the limbs attached to the node. </p>
<p>Multiple limbs with wrench flow of input type can exist, but at least one limb with output type must exist, to compute the wrench balance on the node. The measured/input wrenches to the limbs are here assumed to be set elsewhere: eg another class or the main is setting the measured wrenches. Note: RBT calls computeWrenchNewtonEuler in the limb, meaning that performs a "basic" wrench computation without any sensor, just setting wrenches at the end-effector or at the base, and calling recursive wrench computation. </p><dl class="section return"><dt>Returns</dt><dd>true if succeeds, false otherwise </dd></dl>

<p>Reimplemented in <a class="el" href="classiCub_1_1iDyn_1_1iDynSensorNode.html#a6c3f09586f4cba4d18446fabbeb7394d">iCub::iDyn::iDynSensorNode</a>.</p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00590">590</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="aa277ea9054106efe80d77e4e9c120978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa277ea9054106efe80d77e4e9c120978">&#9670;&nbsp;</a></span>solveWrench() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iCub::iDyn::iDynNode::solveWrench </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is to manage the exchange of wrench information among the limbs attached to the node. </p>
<p>Multiple limbs with wrench flow of input type can exist, but at least one limb with output type must exist, to compute the wrench balance on the node. The measured/input wrenches to the limbs are here passed as a big matrix. In this function the input wrench is set in the limb calling initWrenchNewtonEuler(), which simply set the measured forces in the base/final link of the limb. Input (eg measured) wrenches are stored in two 3xN matrix: each column is a 3x1 vector with force/moment; N is the number of columns, ie the number of measured/input wrenches to the limb the order is assumed coherent with the one built when adding limbs eg: adding limbs: addLimb(limb1), addLimb(limb2), addLimb(limb3) where limb1, limb3 have wrench flow input passing wrenches: Matrix F(3,2), F.setcol(0,f1), F.setcol(1,f3) and similar for moment</p>
<p>Note: RBT calls computeWrenchNewtonEuler in the limb, meaning that perform a "basic" wrench computation without any sensor, just setting wrenches at the end-effector or at the base, and calling recursive wrench computation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>a (3xN) matrix with forces </td></tr>
    <tr><td class="paramname">M</td><td>a (3xN) matrix with moments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeds, false otherwise </dd></dl>

</div>
</div>
<a id="af1cebfe81b63f533efd2f8d89300f0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1cebfe81b63f533efd2f8d89300f0a7">&#9670;&nbsp;</a></span>solveWrench() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iCub::iDyn::iDynNode::solveWrench </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>FM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is to manage the exchange of wrench information among the limbs attached to the node. </p>
<p>Multiple limbs with wrench flow of input type can exist, but at least one limb with output type must exist, to compute the wrench balance on the node. The measured/input wrenches to the limbs are here passed as a big matrix. In this function the input wrench is set in the limb calling initWrenchNewtonEuler(), which simply set the measured forces in the base/final link of the limb. elsewhere: eg another class or the main is setting the measured wrenches. Input (eg measured) wrenches are stored in a 6xN matrix: each column is a 6x1 vector with force/moment; N is the number of columns, ie the number of measured/input wrenches to the limb the order is assumed coherent with the one built when adding limbs eg: adding limbs: addLimb(limb1), addLimb(limb2), addLimb(limb3) where limb1, limb3 have wrench flow input setting wrenches: Matrix FM(6,2), FM.setcol(0,fm1), FM.setcol(1,fm3)</p>
<p>Note: RBT calls computeWrenchNewtonEuler in the limb, meaning that perform a "basic" wrench computation without any sensor, just setting wrenches at the end-effector or at the base, and calling recursive wrench computation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FM</td><td>a (6xN) matrix with forces and moments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeds, false otherwise </dd></dl>

</div>
</div>
<a id="aa106c9340f7e2ffd57305868ac5c87a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa106c9340f7e2ffd57305868ac5c87a2">&#9670;&nbsp;</a></span>TESTING_computeCOMJacobian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix iDynNode::TESTING_computeCOMJacobian </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iLink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Jacobian of the COM of the i-th link of the limb with index iChain in the node. </p>
<p>If the link index is not correct, a null Jacobian is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChain</td><td>the index of the chain (limb) in the node </td></tr>
    <tr><td class="paramname">iLink</td><td>the index of the limnk in the limb </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix of the COM </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l01194">1194</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a93feed610e2fbfc9c1f254668a3ee6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93feed610e2fbfc9c1f254668a3ee6f9">&#9670;&nbsp;</a></span>TESTING_computeCOMJacobian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix iDynNode::TESTING_computeCOMJacobian </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChainA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a>&#160;</td>
          <td class="paramname"><em>dirA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iChainB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iLinkB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a>&#160;</td>
          <td class="paramname"><em>dirB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Jacobian of the COM of link iLinkB, in chainB, when two different chains (A and B) are connected. </p>
<p>The chains are specified by their index in the list (the progressive number of insertion). The first limb has the base of the jacobian (base or end-effector of the limb, depending on the Jacobian direction JacA) while the second limb (limb B - index=iChainB) has the final link of the jacobian (index=iLinkB). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChainA</td><td>the index of the chain (the limb) in the node having the base (&lt;0&gt;) frame </td></tr>
    <tr><td class="paramname">dirA</td><td>the 'direction' of the chain wrt the jacobian computation </td></tr>
    <tr><td class="paramname">iChainB</td><td>the index of the chain (the limb) in the node having the final (&lt;N&gt;) frame </td></tr>
    <tr><td class="paramname">iLinkB</td><td>the index of the link, in the indexChainN chain, being the final (&lt;N&gt;) frame for the Jacobian computation </td></tr>
    <tr><td class="paramname">dirB</td><td>the 'direction' of the chain wrt the jacobian computation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Jacobian matrix of the COM </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l01209">1209</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="aea991e45c7d4b8bda29189071dffc5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea991e45c7d4b8bda29189071dffc5d5">&#9670;&nbsp;</a></span>zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void iDynNode::zero </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset all data to zero. </p>
<p>The list of limbs is not modified or deleted. </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l00433">433</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af1ec3966a72191b31f266809403bfd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ec3966a72191b31f266809403bfd06">&#9670;&nbsp;</a></span>COM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Vector iCub::iDyn::iDynNode::COM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>COM position of the node. </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00558">558</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="a0c97b6d7b00ae9252f0c8b336a60e30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c97b6d7b00ae9252f0c8b336a60e30c">&#9670;&nbsp;</a></span>ddp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Vector iCub::iDyn::iDynNode::ddp</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>linear acceleration </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00552">552</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="ad03a7e6af6ef82ff22fe36456329d2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03a7e6af6ef82ff22fe36456329d2c8">&#9670;&nbsp;</a></span>dw</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Vector iCub::iDyn::iDynNode::dw</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>angular acceleration </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00550">550</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="afbae85fc951a816738e887545dec6d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbae85fc951a816738e887545dec6d1b">&#9670;&nbsp;</a></span>F</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Vector iCub::iDyn::iDynNode::F</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>force </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00554">554</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="a9c71d184a9385364ca17ac8acb134f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c71d184a9385364ca17ac8acb134f99">&#9670;&nbsp;</a></span>info</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string iCub::iDyn::iDynNode::info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>info or useful notes </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00542">542</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="ad5db3235dc804286712724c035345412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5db3235dc804286712724c035345412">&#9670;&nbsp;</a></span>mass</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double iCub::iDyn::iDynNode::mass</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>total mass of the node </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00560">560</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="a6a4212761245758347118b0b685b83bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4212761245758347118b0b685b83bf">&#9670;&nbsp;</a></span>mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a> iCub::iDyn::iDynNode::mode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STATIC/DYNAMIC/DYNAMIC_W_ROTOR/DYNAMIC_CORIOLIS_GRAVITY. </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00539">539</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="a80d77ab92e63190024ee4b8c8e116637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d77ab92e63190024ee4b8c8e116637">&#9670;&nbsp;</a></span>Mu</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Vector iCub::iDyn::iDynNode::Mu</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>moment </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00556">556</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="aa2348a39cc0576e4de7624580a6997b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2348a39cc0576e4de7624580a6997b9">&#9670;&nbsp;</a></span>rbtList</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;<a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html">RigidBodyTransformation</a>&gt; iCub::iDyn::iDynNode::rbtList</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the list of RBT </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00536">536</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="a5fca92c14ebe1efb92463eb77ed67352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fca92c14ebe1efb92463eb77ed67352">&#9670;&nbsp;</a></span>verbose</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int iCub::iDyn::iDynNode::verbose</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>verbosity flag </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00545">545</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<a id="a74a74e80b0abb7063546f8b261bf359f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a74e80b0abb7063546f8b261bf359f">&#9670;&nbsp;</a></span>w</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">yarp::sig::Vector iCub::iDyn::iDynNode::w</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>angular velocity </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00548">548</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>icub-main/src/libraries/iDyn/include/iCub/iDyn/<a class="el" href="iDynBody_8h_source.html">iDynBody.h</a></li>
<li>icub-main/src/libraries/iDyn/src/<a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 26 2024 16:02:21 for iCub-main by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
