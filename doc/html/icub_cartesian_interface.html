<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iCub-main: The Cartesian Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iCub-main
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The Cartesian Interface </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sec_cart_intro">Introduction</a></li>
<li class="level1"><a href="#sec_cart_dependencies">Dependencies</a></li>
<li class="level1"><a href="#sec_cart_opencloseinterface">Opening and Closing the Cartesian Interface</a></li>
<li class="level1"><a href="#sec_cart_coordsystem">Coordinate System</a></li>
<li class="level1"><a href="#sec_cart_useinterface">Using the Cartesian Interface</a></li>
<li class="level1"><a href="#sec_cart_nonlineardesign">Nonlinear Problem Design</a></li>
<li class="level1"><a href="#sec_cart_contextswitch">Context Switch</a></li>
<li class="level1"><a href="#sec_cart_taskrefvel">Task-Space Reference Velocity Command</a></li>
<li class="level1"><a href="#sec_cart_tipframe">Defining a Different Effector</a></li>
<li class="level1"><a href="#sec_cart_eventscallbacks">Events Callbacks</a></li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Ugo Pattacini</dd></dl>
<h1><a class="anchor" id="sec_cart_intro"></a>
Introduction</h1>
<p>The YARP <b>Cartesian Interface</b> has been conceived in order to enable the control of the arms and the legs of the robot directly in the operational space, that is instead of commanding new configuration for the joints, user can require for instance the arm to reach a specified pose in the Cartesian space, expressed as a combination of a 3d point to be attained by the end-effector (the center of the palm in this case) along with the desired orientation given in axis-angle representation.</p>
<p>Before proceeding, the reader might find helpful to recap some motor control fundamentals (see <a class="el" href="icub_motor_control_tutorial.html">here</a>) as well as to be introduced to the underneath topic of forward and inverse kinematics by going through the <a class="el" href="group__iKin.html">iKin</a> documentation and tutorials.</p>
<p>The architecture of the Cartesian Interface is based on three components: 1) a complex <b>nonlinear optimizer</b> that handles the inverse kinematics problem; 2) a <b>biologically inspired controller</b> that represents the server part of the interface and is responsible for generating the human-like velocity profiles to move the system from its initial state to the joints configuration found by the solver; 3) a <b>client</b> part that exposes a collection of C++ methods to abstract the interface from its specific implementation. <br  />
Alternatively, the client can act as a pure wrapper over the solver coping with the inverse kinematics, whereas the user might consider developing his own controller meeting some specific requirements. However, also in this configuration, the server part needs to be launched (even if not employed) as a gateway to let the client communicate with the solver.</p>
<dl class="section note"><dt>Note</dt><dd><b>If you're going to use this controller for your work, please quote it within any resulting publication</b>: U. Pattacini, F. Nori, L. Natale, G. Metta, G. Sandini, "An Experimental Evaluation of a Novel Minimum-Jerk Cartesian Controller for Humanoid Robots", <em>IEEE/RSJ International Conference on Intelligent Robots and Systems</em>, Taipei, Taiwan, 2010.</dd></dl>
<h1><a class="anchor" id="sec_cart_dependencies"></a>
Dependencies</h1>
<p>In order to use the Cartesian Interface, make sure that the following steps are done: <br  />
[Note that the term <em>cluster</em> refers to the set of computers directly connected to the robot network, whereas <em>icub-head</em> indicates the hub board mounted on the robot]</p>
<ol type="1">
<li>Install the required <a href="https://icub-tech-iit.github.io/documentation/sw_installation/">software dependencies</a>.</li>
<li>On the cluster: compile the repository with the switch <b>ENABLE_icubmod_cartesiancontrollerclient</b> enabled. This will make the client part of the interface available.</li>
<li>On icub-head: compile the repository with the switch <b>ENABLE_icubmod_cartesiancontrollerserver</b> enabled. This will make the server part of the interface available on the hub.</li>
</ol>
<p><b>iCubStartup Application <a class="el" href="classLauncher.html" title="This container class launches the server part of the fake motor device in order to simulate a robot c...">Launcher</a></b> <br  />
 Henceforth rely on the installed copy of <em>$ICUB_ROOT/main/app/iCubStartup/scripts/iCubStartup.xml.template</em> application to launch both the Cartesian solvers (and other useful tools as well). <br  />
The <a class="el" href="group__iKinCartesianSolver.html">Cartesian Solvers</a> are required to invert the kinematics using Ipopt and they are meant to run on the cluster to avoid overloading the icub-head core. Make sure that the machines where the solvers will be running are configured properly to work with the specific robot (e.g. the <b>YARP_ROBOT_NAME</b> correctly points to the name of the robot) in order to load at start-up the robot dependent kinematics. <br  />
The solvers need the robotInterface to connect to the robot to get useful data to operate (e.g. the joints bounds) and also the robotInterface needs them to open the server side of the Cartesian Interface. Therefore the <em>chicken-egg</em> problem is solved by applying proper connection timeout to the solvers and to keep them as close as possible to the robotInterface by using the application. Moreover, once everything is launched from within the application, if the user <em>accidentally</em> stops one of these modules, it turns to be mandatory to restart all of them from the beginning; this comes from the requirement to keep the communication protocol as light as possible, avoiding requests for integrity check and reinitialization. <br  />
</p>
<h1><a class="anchor" id="sec_cart_opencloseinterface"></a>
Opening and Closing the Cartesian Interface</h1>
<p>The Cartesian Interface can be opened as a normal YARP interface resorting to the <em>PolyDriver</em> class: </p><div class="fragment"><div class="line">Property option;</div>
<div class="line">option.put(<span class="stringliteral">&quot;device&quot;</span>,<span class="stringliteral">&quot;cartesiancontrollerclient&quot;</span>);</div>
<div class="line">option.put(<span class="stringliteral">&quot;remote&quot;</span>,<span class="stringliteral">&quot;/icub/cartesianController/right_arm&quot;</span>);</div>
<div class="line">option.put(<span class="stringliteral">&quot;local&quot;</span>,<span class="stringliteral">&quot;/client/right_arm&quot;</span>);</div>
<div class="line"> </div>
<div class="line">PolyDriver clientCartCtrl(option);</div>
<div class="line"> </div>
<div class="line">ICartesianControl *icart=NULL;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (clientCartCtrl.isValid()) {</div>
<div class="line">   clientCartCtrl.view(icart);</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you might have noticed, the stem-name of the Cartesian server controller (taken as standard) is "/&lt;robot_name&gt;/cartesianController/&lt;part_name&gt;". Thus, similarly to a usual motor controller, a state port streaming out the Cartesian pose of the limb's end-effector is also available whose name is "/&lt;robot_name&gt;/cartesianController/&lt;part_name&gt;/state:o". As result you can do: </p><div class="fragment"><div class="line"><a class="code" href="namespaceyarp.html">yarp</a> <a class="code" href="namespaceeth_1_1parser.html#a8ec58da625146082584ad1a365bdd0e5">read</a> /<a class="code" href="namespaceeth_1_1parser.html#a8ec58da625146082584ad1a365bdd0e5">read</a> /icub/cartesianController/right_arm/<a class="code" href="WholeBodyPlayerModule_8h.html#a055865842672bfeb446ff98a1e9104ab">state</a>:o</div>
<div class="ttc" id="aWholeBodyPlayerModule_8h_html_a055865842672bfeb446ff98a1e9104ab"><div class="ttname"><a href="WholeBodyPlayerModule_8h.html#a055865842672bfeb446ff98a1e9104ab">state</a></div><div class="ttdeci">state</div><div class="ttdef"><b>Definition:</b> <a href="WholeBodyPlayerModule_8h_source.html#l00064">WholeBodyPlayerModule.h:64</a></div></div>
<div class="ttc" id="anamespaceeth_1_1parser_html_a8ec58da625146082584ad1a365bdd0e5"><div class="ttname"><a href="namespaceeth_1_1parser.html#a8ec58da625146082584ad1a365bdd0e5">eth::parser::read</a></div><div class="ttdeci">bool read(yarp::os::Searchable &amp;cfgtotal, pc104Data &amp;pc104data)</div><div class="ttdef"><b>Definition:</b> <a href="ethParser_8cpp_source.html#l00092">ethParser.cpp:92</a></div></div>
<div class="ttc" id="anamespaceyarp_html"><div class="ttname"><a href="namespaceyarp.html">yarp</a></div><div class="ttdoc">Copyright (C) 2008 RobotCub Consortium.</div><div class="ttdef"><b>Definition:</b> <a href="DebugInterfaces_8h_source.html#l00051">DebugInterfaces.h:51</a></div></div>
</div><!-- fragment --><p> getting the current pose of the right hand end-effector expressed with seven double \( \left[x,y,z,a_x,a_y,a_z,\theta\right] \), where the first three components are the 3d location of the center of the palm, whilst the final four describe the rotation of the frame attached to the end-effector with respect to the root reference frame in axis/angle notation (see <a class="el" href="icub_cartesian_interface.html#sec_cart_coordsystem">Coordinate System</a>).</p>
<p>When you are done with controlling the robot you can explicitly close the device (or just let the destructor do it for you): </p><div class="fragment"><div class="line">clientCartCtrl.close();</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_cart_coordsystem"></a>
Coordinate System</h1>
<p>Central for a correct usage of the Cartesian controller is the knowledge of the coordinate system that shall be adopted to describe any desired limb pose.</p>
<p>Positions (in meters) and orientation refer to the root frame attached to the waist as in the <a href="https://icub-tech-iit.github.io/documentation/icub_kinematics/icub-forward-kinematics/icub-forward-kinematics">documentation</a>. <br  />
The root <b>x-axis</b> points backward, the <b>y-axis</b> points rightward, while the <b>z-axis</b> points upward.</p>
<p>To specify a target orientation of the end-effector, you have to provide three components for the rotation axis (whose norm is 1) and a fourth component for the rotation angle expressed in radians as required by the axis/angle notation (see <a href="http://en.wikipedia.org/wiki/Axis_angle">here</a>). <br  />
The axis/angle format compacts the notation and protects from some singularities that might appear when the Euler angles are adopted, but obviously one can still use his most preferable representation since there exist transformation formulas from one domain to another (e.g. look at yarp::math::dcm2axis or yarp::math::axis2dcm documentation).</p>
<p><b>Example</b> <br  />
 We want to represent the orientation of the right hand when the arm is in the rest position (the torso and arm joints are zeroed), for which the x-axis attached to the center of the palm points downward, the y-axis points backward, while the z-axis points leftward. Hence, to transform the root reference frame in the end-effector frame, one solution is to rotate of pi/2 around the y-axis and then of -pi/2 around the z-axis.</p>
<p>In formulas: </p><div class="fragment"><div class="line">Vector oy(4), oz(4);</div>
<div class="line">oy[0]=0.0; oy[1]=1.0; oy[2]=0.0; oy[3]=+<a class="code" href="XSensMTx_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>/2.0;</div>
<div class="line">oz[0]=0.0; oz[1]=0.0; oz[2]=1.0; oz[3]=-<a class="code" href="XSensMTx_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>/2.0;</div>
<div class="line"> </div>
<div class="line">Matrix Ry=yarp::math::axis2dcm(oy);        <span class="comment">// from axis/angle to rotation matrix notation</span></div>
<div class="line">Matrix Rz=yarp::math::axis2dcm(oz);</div>
<div class="line"> </div>
<div class="line">Matrix R=Rz*Ry;                            <span class="comment">// compose the two rotations keeping the order</span></div>
<div class="line">Vector o=yarp::math::dcm2axis(R);          <span class="comment">// from rotation matrix back to the axis/angle notation</span></div>
<div class="ttc" id="aXSensMTx_8cpp_html_ae71449b1cc6e6250b91f539153a7a0d3"><div class="ttname"><a href="XSensMTx_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a></div><div class="ttdeci">#define M_PI</div><div class="ttdef"><b>Definition:</b> <a href="XSensMTx_8cpp_source.html#l00024">XSensMTx.cpp:24</a></div></div>
</div><!-- fragment --><p>The outcome is: o = [0.57735 0.57735 -0.57735 2.094395]. <br  />
Alternatively, one can specify directly the matrix R as a collection of column vectors representing the axes of the goal pose expressed in the root reference frame: </p><div class="fragment"><div class="line">Matrix R(3,3);</div>
<div class="line"><span class="comment">// pose x-axis   y-axis        z-axis</span></div>
<div class="line">   R(0,0)= 0.0;  R(0,1)= 1.0;  R(0,2)= 0.0;    <span class="comment">// x-coordinate in root frame</span></div>
<div class="line">   R(1,0)= 0.0;  R(1,1)= 0.0;  R(1,2)=-1.0;    <span class="comment">// y-coordinate    &quot;</span></div>
<div class="line">   R(2,0)=-1.0;  R(2,1)= 0.0;  R(2,2)= 0.0;    <span class="comment">// z-coordinate    &quot;</span></div>
<div class="line"> </div>
<div class="line">Vector o=yarp::math::dcm2axis(R);</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_cart_useinterface"></a>
Using the Cartesian Interface</h1>
<p>The YARP documentation contains a full description of <b><a href="https://yarp.it/latest/classyarp_1_1dev_1_1ICartesianControl.html">Cartesian Interface</a></b>. Moreover, some examples are also reported hereafter to gain a deeper insight into the Cartesian device.</p>
<p>Imagine that we want to get the actual arm pose from within our code. What we have to write is just: </p><div class="fragment"><div class="line">Vector x0,o0;</div>
<div class="line">icart-&gt;getPose(x0,o0);</div>
</div><!-- fragment --><p> The current translational position is returned in <em>x0</em> while <em>o0</em> contains now the current orientation.</p>
<p>Then we want to move the hand a bit farther from the body, let's say just 10 cm away along -x, keeping the orientation constant: </p><div class="fragment"><div class="line">Vector xd=x0; xd[0]+=-0.1;</div>
<div class="line">Vector od=o0;</div>
<div class="line">icart-&gt;goToPose(xd,od);   <span class="comment">// send request and forget</span></div>
</div><!-- fragment --><p> The <em>goToPose()</em> method does not wait for any acknowledgement that the server has received the request, but it just lets the client module go straight to the next instruction in the code flow. Therefore, the intended use of this method is for streaming input (e.g. while tracking).</p>
<p>If we would like to test whether the new pose has been achieved, it's as follows: </p><div class="fragment"><div class="line">icart-&gt;goToPoseSync(xd,od);   <span class="comment">// send request and wait for reply</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="icub-main_2src_2tools_2canBusSniffer_2canBusSnifferV5_2main_8cpp.html#a1d39aac66e12dae50a24cd7a9100ef33">done</a>=<span class="keyword">false</span>;</div>
<div class="line"><span class="keywordflow">while</span> (!<a class="code" href="icub-main_2src_2tools_2canBusSniffer_2canBusSnifferV5_2main_8cpp.html#a1d39aac66e12dae50a24cd7a9100ef33">done</a>) {</div>
<div class="line">   icart-&gt;checkMotionDone(&amp;<a class="code" href="icub-main_2src_2tools_2canBusSniffer_2canBusSnifferV5_2main_8cpp.html#a1d39aac66e12dae50a24cd7a9100ef33">done</a>);</div>
<div class="line">   Time::delay(0.04);   <span class="comment">// or any suitable delay</span></div>
<div class="line">}</div>
<div class="ttc" id="aicub-main_2src_2tools_2canBusSniffer_2canBusSnifferV5_2main_8cpp_html_a1d39aac66e12dae50a24cd7a9100ef33"><div class="ttname"><a href="icub-main_2src_2tools_2canBusSniffer_2canBusSnifferV5_2main_8cpp.html#a1d39aac66e12dae50a24cd7a9100ef33">done</a></div><div class="ttdeci">bool done</div><div class="ttdef"><b>Definition:</b> <a href="icub-main_2src_2tools_2canBusSniffer_2canBusSnifferV5_2main_8cpp_source.html#l00042">main.cpp:42</a></div></div>
</div><!-- fragment --><p> The same can be achieved also by the following streamlined snippet of code: </p><div class="fragment"><div class="line">icart-&gt;goToPoseSync(xd,od);   <span class="comment">// send request and wait for reply</span></div>
<div class="line">icart-&gt;waitMotionDone(0.04);  <span class="comment">// wait until the motion is done and ping at each 0.04 seconds</span></div>
</div><!-- fragment --><p> Here the method <em>goToPoseSync()</em> guarantees that the server has received the request and initiated the movement before allowing the code flow to proceed. If we had used the analogous non-sync method, then the result of first check would have been unpredictable.</p>
<p>To tune the trajectory execution time for point-to-point movements, you can call the proper function: </p><div class="fragment"><div class="line">icart-&gt;setTrajTime(1.5);  <span class="comment">// given in seconds</span></div>
</div><!-- fragment --><p>To let the controller determine when to declare the movement accomplished, there is a dedicated tolerance acting both at the level of position and orientation errors. To set this tolerance you can write the following: </p><div class="fragment"><div class="line">icart-&gt;setInTargetTol(0.001);</div>
</div><!-- fragment --><p> This means that the movement will be intended finished whenever norm(xd-x)&lt;0.001, where x comprises the position and the orientation of the end-effector.</p>
<p>While moving to a target pose, you can query the controller to find out which will be the final joints configuration as determined by the solver: </p><div class="fragment"><div class="line">Vector xdhat, odhat, qdhat;</div>
<div class="line">icart-&gt;getDesired(xdhat,odhat,qdhat);</div>
</div><!-- fragment --><p> Of course due to the optimization process \( \hat{x}_d \) differs from the commanded \( x_d \), so as \( \hat{o}_d \) from \( o_d \); \( \hat{q}_d \) is such that \( \left[\hat{x}_d,\hat{o}_d\right]=K\left(\hat{q}_d\right) \), where \( K\left(\cdot\right) \) is the forward kinematic map. <br  />
 By contrast, if you want to solve for a given pose without actually moving there, you can use the ask-based methods as follows: </p><div class="fragment"><div class="line">Vector xd(3);</div>
<div class="line">xd[0]=-0.3;</div>
<div class="line">xd[1]=0.0;</div>
<div class="line">xd[2]=0.1;</div>
<div class="line"> </div>
<div class="line">Vector xdhat, odhat, qdhat;</div>
<div class="line">icart-&gt;askForPosition(xd,xdhat,odhat,qdhat);</div>
</div><!-- fragment --><p> The ask-based methods such as <em>askForPosition()</em> and <em>askForPose()</em> allow the user to employ the Cartesian Interface just as a <b>simple layer that wraps around the inverse kinematics solver</b>.</p>
<p>One useful feature is the possibility to enable/disable some degrees of freedom on-line. For example, the arm comes with 10 possible DOF's (the torso is included) that the user may or may not want to use at the same time while reaching. <br  />
In the following snippet of code we ask to enable the torso pitch and yaw joints (which are off by default). </p><div class="fragment"><div class="line">Vector curDof;</div>
<div class="line">icart-&gt;getDOF(curDof);</div>
<div class="line">cout&lt;&lt;<span class="stringliteral">&quot;[&quot;</span>&lt;&lt;curDof.toString()&lt;&lt;<span class="stringliteral">&quot;]&quot;</span>&lt;&lt;endl;  <span class="comment">// [0 0 0 1 1 1 1 1 1 1] will be printed out</span></div>
<div class="line"> </div>
<div class="line">Vector newDof(3);</div>
<div class="line">newDof[0]=1;    <span class="comment">// torso pitch: 1 =&gt; enable</span></div>
<div class="line">newDof[1]=2;    <span class="comment">// torso roll:  2 =&gt; skip</span></div>
<div class="line">newDof[2]=1;    <span class="comment">// torso yaw:   1 =&gt; enable</span></div>
<div class="line">icart-&gt;setDOF(newDof,curDof);</div>
<div class="line">cout&lt;&lt;<span class="stringliteral">&quot;[&quot;</span>&lt;&lt;curDof.toString()&lt;&lt;<span class="stringliteral">&quot;]&quot;</span>&lt;&lt;endl;  <span class="comment">// [1 0 1 1 1 1 1 1 1 1] will be printed out</span></div>
</div><!-- fragment --><p> To sum up, a value of '1' makes the joint a real degree of freedom, a value of '0' switches it off, while the special value of '2' indicates that the joint status won't be modified (to skip it and proceed forward).</p>
<p>Two things deserve your attention:</p><ul>
<li>The torso joints order is the one defined by the kinematic description available from the wiki: [pitch,roll,yaw]. Usually the motor control interfaces stream the torso joints in the reversed order (i.e. [yaw,roll,pitch]) since they assume a different kinematic origin (the base of the neck in this case).</li>
<li>The shoulder joints are considered all together to be a super-joint (in order to take into account the shoulder's cable length issue) so that you are not allowed to enable/disable one of them differently from the others.</li>
</ul>
<p>Furthermore, as you can easily figure out, the torso joints are shared by both arms. This tells us to take care of a misuse of the Cartesian device that might arise when one arm is controlled simultaneously to the other one: if this happens, a supervisor that enables/disables the torso joints according to the needs should be put in place.</p>
<p>When the torso is being controlled by an external module, there exists also the possibility for the Cartesian device to counteract to the induced movements of the uncontrolled joints in order to maintain the final end-effector pose stable. <br  />
To enable this feature one should call the proper method: </p><div class="fragment"><div class="line">icart-&gt;setTrackingMode(<span class="keyword">true</span>);</div>
</div><!-- fragment --><p> Usually the Cartesian device brings up in <em>non-tracking</em> mode: this means that once the limb has reached the desired pose, the controller gets disconnected until the next command is yielded and the limb can be moved by other external agents. <br  />
Conversely, in <em>tracking</em> mode the controller stays connected and tries to compensate for externally induced movements on the uncontrolled joints (that are seen as disturbs on the actual end-effector position) such as the torso ones (in case they have been previously disabled).</p>
<p>Another advanced feature you can benefit from is the chance to change dynamically the rest position the solver uses to specify a secondary task while converging to the solution. <br  />
Briefly (a detailed description is given in the <a class="el" href="group__iKinSlv.html">solver page</a>), the Cartesian solver implements a nonlinear constrained optimization that can be described in this way:</p>
<p class="formulaDsp">
\[ \begin{array}{c} \mathbf{q}=\arg\min\limits_{\mathbf{q} \in \mathbb{R}^{n} }\left(\left\|\mathbf{\alpha}_d-\mathit{K_{\alpha}}\left(\mathbf{q}\right)\right\|^2+\mathit{w}\cdot\left(\mathbf{q}_r-\mathbf{q}\right)^{\top}\mathit{W}_r\left(\mathbf{q}_r-\mathbf{q}\right)\right) \\ \text{s.t.} \begin{cases} \left\|\mathbf{x}_d-\mathit{K_x}\left(\mathbf{q}\right)\right\|^2=0 \\ \mathbf{q}_L&lt;\mathbf{q}&lt;\mathbf{q}_U \end{cases} \end{array}. \]
</p>
<p>The term \( \left(\mathbf{q}_r-\mathbf{q}\right)^{\top}\mathit{W}_r\left(\mathbf{q}_r-\mathbf{q}\right) \) represents the aforementioned secondary task, where \( \mathbf{q}_r \) is used to keep the solution as close as possible to a given rest position in the joint space, weighting component by component with the diagonal matrix \( \mathit{W}_r \). <br  />
Thereby, to access the elements of \( \mathbf{q}_r \) and \( \mathit{W}_r \) one should call the following methods: </p><div class="fragment"><div class="line">Vector curRestPos;</div>
<div class="line">icart-&gt;getRestPos(curRestPos);</div>
<div class="line">cout&lt;&lt;<span class="stringliteral">&quot;[&quot;</span>&lt;&lt;curRestPos.toString()&lt;&lt;<span class="stringliteral">&quot;]&quot;</span>&lt;&lt;endl;  <span class="comment">// [0 0 0 0 0 0 0 0 0 0] will be printed out</span></div>
<div class="line"> </div>
<div class="line">Vector curRestWeights;</div>
<div class="line">icart-&gt;getRestWeights(curRestWeights);</div>
<div class="line">cout&lt;&lt;<span class="stringliteral">&quot;[&quot;</span>&lt;&lt;curRestWeights.toString()&lt;&lt;<span class="stringliteral">&quot;]&quot;</span>&lt;&lt;endl;  <span class="comment">// [1 1 1 0 0 0 0 0 0 0] will be printed out</span></div>
</div><!-- fragment --><p> Above we've asked for the default configuration of the secondary task which tries to minimize against the rest position (0,0,0) that considers only the torso joints in the computation. This prevents the robot from leaning out too much if the target position can be reached easily with just the arm.</p>
<h1><a class="anchor" id="sec_cart_nonlineardesign"></a>
Nonlinear Problem Design</h1>
<p>In this small section a couple of considerations that motivated the design of the inversion problem are briefly summarized as taken from the article on the Cartesian controller and perhaps more importantly as they came up from discussions with some meticulous users.</p>
<p>One of the main aspects of the nonlinear problem as handled by the Cartesian solver is that the reaching for position is a constraint, whereas the reaching in orientation appears directly in the cost function. As result, the former is treated with higher priority with respect to the latter to reflect the requirement of achieving the task in a very localized zone of the space. For example, this particular preference is of major interest for grasping, where having an hand perfectly oriented with respect to the object to be grasped but with a position of even a couple of centimeters away from the target will cause the task to fail much more frequently than having the hand perfectly located in position and with even ten degrees out of the alignment. One behavior emerging from this design that the user may experience effortlessly is the following: when a out-of-range position is commanded together with a given orientation, it turns that the robot will stretch its body up to its maximum extension (depending on the parts currently enabled) almost irrespective of the final orientation. As consequence, bear always in mind to enable the torso to enlarge as much as possible the dexterous space of the <a class="el" href="namespaceiCub.html" title="This file contains the definition of unique IDs for the body parts and the skin parts of the robot.">iCub</a>.</p>
<p>Conversely, if for any reason the orientation is meant to be handled with higher priority with respect to position, user can then declare the reaching in orientation as a contraint and the reaching in position as an objective, respectively. This swap is performed by the following call: </p><div class="fragment"><div class="line">icart-&gt;setPosePriority(<span class="stringliteral">&quot;orientation&quot;</span>);</div>
</div><!-- fragment --><p> To switch back to the normal configuration where position is again predominant: </p><div class="fragment"><div class="line">icart-&gt;setPosePriority(<span class="stringliteral">&quot;position&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_cart_contextswitch"></a>
Context Switch</h1>
<p>We define here the <em>context</em> as the configuration in which the controller operates: therefore the context includes the actual number of DOF's, their angular bounds, the resting positions and weights, the trajectory execution time, the current tracking mode, the pose priority and so on. Obviously the controller performs the same action differently depending on the current context. A way to easily switch among contexts is to rely on <em>storeContext()</em> and <em>restoreContext()</em> methods as follows: </p><div class="fragment"><div class="line">icart-&gt;setDOF(newDof1,curDof1);         <span class="comment">// here the user prepares the context</span></div>
<div class="line">icart-&gt;setTrackingMode(<span class="keyword">true</span>);</div>
<div class="line">...</div>
<div class="line">int context_0;</div>
<div class="line">icart-&gt;storeContext(&amp;context_0);        <span class="comment">// latch the context</span></div>
<div class="line"> </div>
<div class="line">icart-&gt;setDOF(newDof2,curDof2);         <span class="comment">// at certain point the user may want the controller to</span></div>
<div class="line">icart-&gt;goToPose(<a class="code" href="compute__ekf__sym_8m.html#abe119338ba11d7fd166333a3941bc2c4">x</a>,o);                   <span class="comment">// perform some actions with different configuration</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">icart-&gt;restoreContext(context_0);       <span class="comment">// ... and then retrieve the stored context_0</span></div>
<div class="line">icart-&gt;goToPose(<a class="code" href="compute__ekf__sym_8m.html#abe119338ba11d7fd166333a3941bc2c4">x</a>,o);                   <span class="comment">// now the controller performs the same action but within the context_0</span></div>
<div class="ttc" id="acompute__ekf__sym_8m_html_abe119338ba11d7fd166333a3941bc2c4"><div class="ttname"><a href="compute__ekf__sym_8m.html#abe119338ba11d7fd166333a3941bc2c4">x</a></div><div class="ttdeci">x</div><div class="ttdef"><b>Definition:</b> <a href="compute__ekf__sym_8m_source.html#l00021">compute_ekf_sym.m:21</a></div></div>
</div><!-- fragment --><p> Unless the user needs the interface just for logging purposes, it's a good rule to store the context at the initialization of his module in order to then restore it at releasing time to preserve the controller configuration. <br  />
Note that the special context tagged with the id 0 is reserved by the system to let the user restore the start-up configuration of the controller at any time.</p>
<h1><a class="anchor" id="sec_cart_taskrefvel"></a>
Task-Space Reference Velocity Command</h1>
<p>The user is further provided with the method <em>setTaskVelocities()</em> that allows commanding a reference velocity for the end-effector in the operational space as follows: </p><div class="fragment"><div class="line">Vector xdot(3); <span class="comment">// move the end-effector along y-axis at specified velocity</span></div>
<div class="line">xdot[0]=0.0;    <span class="comment">// [m/s]</span></div>
<div class="line">xdot[1]=0.01;</div>
<div class="line">xdot[2]=0.0;</div>
<div class="line"> </div>
<div class="line">Vector odot(4); <span class="comment">// no rotation is required</span></div>
<div class="line">odot=0.0;       <span class="comment">// [rad/s]</span></div>
<div class="line"> </div>
<div class="line">icart-&gt;setTaskVelocities(xdot,odot);</div>
</div><!-- fragment --><p> The solver still plays a meaningful role in this command mode so that the whole set of constraints active in the inverse kinematics problem are taken into account. Moreover, the task-space reference velocity will be tracked according to the reactivity level of the internal controller which is basically determined by the current trajectory time; thus, for executing high task-space velocity the trajectory time should be tuned towards lower values, whereas it should be increased to track low task-space reference velocity.</p>
<h1><a class="anchor" id="sec_cart_tipframe"></a>
Defining a Different Effector</h1>
<p>The Cartesian controller can be also instructed to control a different effector that can be suitably expressed with respect to the standard end-effector reference frame. This is thus equivalent to rigidly attaching a tip to the standard end-effector. Therefore, to achieve such extension, it is required to call the <em>attachTipFrame()</em> method of the interface as done in the following example, where the aim is to control the tip of the index finger rather than the center of the palm: </p><div class="fragment"><div class="line">IEncoders *iencs;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">int nEncs;</div>
<div class="line">iencs-&gt;getAxes(&amp;nEncs);</div>
<div class="line">Vector <a class="code" href="namespacepython-motor-control.html#aa4a312653eff9f950af80bbf61a3d925">encs</a>(nEncs);</div>
<div class="line">iencs-&gt;getEncoders(<a class="code" href="namespacepython-motor-control.html#aa4a312653eff9f950af80bbf61a3d925">encs</a>.data());</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">Vector joints;</div>
<div class="line">iCubFinger finger(<span class="stringliteral">&quot;right_index&quot;</span>);                  <span class="comment">// relevant code to get the position of the finger tip</span></div>
<div class="line">finger.getChainJoints(<a class="code" href="namespacepython-motor-control.html#aa4a312653eff9f950af80bbf61a3d925">encs</a>,joints);                <span class="comment">// wrt the end-effector frame</span></div>
<div class="line">Matrix tipFrame=finger.getH((<a class="code" href="XSensMTx_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>/180.0)*joints);</div>
<div class="line"> </div>
<div class="line">Vector tip_x=tipFrame.getCol(3);</div>
<div class="line">Vector tip_o=yarp::math::dcm2axis(tipFrame);</div>
<div class="line">icart-&gt;attachTipFrame(tip_x,tip_o);                <span class="comment">// establish the new controlled frame</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">icart-&gt;getPose(<a class="code" href="compute__ekf__sym_8m.html#abe119338ba11d7fd166333a3941bc2c4">x</a>,o);                               <span class="comment">// now we get the pose of the finger tip frame</span></div>
<div class="line">icart-&gt;goToPose(xd,od);                            <span class="comment">// so as the target will be attained with the finger tip</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">icart-&gt;removeTipFrame();                           <span class="comment">// to restore the center of the palm as actual end-effector</span></div>
<div class="ttc" id="anamespacepython-motor-control_html_aa4a312653eff9f950af80bbf61a3d925"><div class="ttname"><a href="namespacepython-motor-control.html#aa4a312653eff9f950af80bbf61a3d925">python-motor-control.encs</a></div><div class="ttdeci">encs</div><div class="ttdef"><b>Definition:</b> <a href="python-motor-control_8py_source.html#l00036">python-motor-control.py:36</a></div></div>
</div><!-- fragment --><p> Importantly, the tip frame is part of the current context, hence it might happen that several tip frames are attached or removed as result of the user context switching requests.</p>
<h1><a class="anchor" id="sec_cart_eventscallbacks"></a>
Events Callbacks</h1>
<p>The Cartesian Interface provides also an easy way to register events callbacks. For example, an event might be represented by the onset of the movement when the controller gets activated upon the reception of a new target or the end of the movement itself. The user can then attach a callback to any event generated by the interface. <br  />
It is required to inherit from the specific class <em>CartesianEvent</em> that handles events and overrides the <em>cartesianEventCallback()</em> method. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MotionDoneEvent : <span class="keyword">public</span> CartesianEvent</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">   MotionDoneEvent()</div>
<div class="line">   {</div>
<div class="line">      cartesianEventParameters.type=<span class="stringliteral">&quot;motion-done&quot;</span>;         <span class="comment">// select here the event type we want to listen to</span></div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">void</span> cartesianEventCallback()</div>
<div class="line">   {</div>
<div class="line">      cout&lt;&lt;<span class="stringliteral">&quot;motion complete&quot;</span>&lt;&lt;endl;</div>
<div class="line">   }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MotionDoneEvent event;</div>
<div class="line">icart-&gt;registerEvent(event);                               <span class="comment">// the tag &quot;motion-done&quot; identifies the event to be notified</span></div>
<div class="line">icart-&gt;goToPosition(<a class="code" href="compute__ekf__sym_8m.html#abe119338ba11d7fd166333a3941bc2c4">x</a>);                                    <span class="comment">// as soon as the motion is complete, the callback will print out the message</span></div>
</div><!-- fragment --><p>To know which events are available for notification, the user can do: </p><div class="fragment"><div class="line">Bottle <a class="code" href="namespaceiCub_1_1action_1_1log.html#a4ba5ea132464d0ea49d618130163c769a432470a52cfded222c35744229d1069e">info</a>;</div>
<div class="line">icart-&gt;getInfo(<a class="code" href="namespaceiCub_1_1action_1_1log.html#a4ba5ea132464d0ea49d618130163c769a432470a52cfded222c35744229d1069e">info</a>);</div>
<div class="line">cout&lt;&lt;<a class="code" href="namespaceiCub_1_1action_1_1log.html#a4ba5ea132464d0ea49d618130163c769a432470a52cfded222c35744229d1069e">info</a>.find(<span class="stringliteral">&quot;events&quot;</span>).asList()-&gt;toString().c_str()&lt;&lt;endl;</div>
<div class="ttc" id="anamespaceiCub_1_1action_1_1log_html_a4ba5ea132464d0ea49d618130163c769a432470a52cfded222c35744229d1069e"><div class="ttname"><a href="namespaceiCub_1_1action_1_1log.html#a4ba5ea132464d0ea49d618130163c769a432470a52cfded222c35744229d1069e">iCub::action::log::info</a></div><div class="ttdeci">@ info</div><div class="ttdef"><b>Definition:</b> <a href="actionPrimitives_8cpp_source.html#l00066">actionPrimitives.cpp:66</a></div></div>
</div><!-- fragment --><p>The class <em>CartesianEvent</em> contains two structures: the <em>cartesianEventParameters</em> and the <em>cartesianEventVariables</em>. The former has to be filled by the user to set up the event details, whereas the latter is filled directly by the event handler in order to provide information to the callback. <br  />
For instance, to raise a callback at the middle point of the path, one can do: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MotionMiddleEvent : <span class="keyword">public</span> CartesianEvent</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">   MotionMiddleEvent()</div>
<div class="line">   {</div>
<div class="line">      cartesianEventParameters.type=<span class="stringliteral">&quot;motion-ongoing&quot;</span>;</div>
<div class="line">      cartesianEventParameters.motionOngoingCheckPoint=0.5;   <span class="comment">// middle point is at 50% of the path</span></div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">void</span> cartesianEventCallback()</div>
<div class="line">   {</div>
<div class="line">      cout&lt;&lt;<span class="stringliteral">&quot;attained the &quot;</span>&lt;&lt;100.0*cartesianEventVariables.motionOngoingCheckPoint;</div>
<div class="line">      cout&lt;&lt;<span class="stringliteral">&quot;% of the path&quot;</span>&lt;&lt;endl;</div>
<div class="line">   }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The special wildcard "*" can be used to assign a callback to any event, regardless of its type, as done below. </p><div class="fragment"><div class="line"><span class="keyword">class </span>GeneralEvent : <span class="keyword">public</span> CartesianEvent</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">   GeneralEvent()</div>
<div class="line">   {</div>
<div class="line">      cartesianEventParameters.type=<span class="stringliteral">&quot;*&quot;</span>;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">void</span> cartesianEventCallback()</div>
<div class="line">   {</div>
<div class="line">      cout&lt;&lt;<span class="stringliteral">&quot;event of type: &quot;</span>&lt;&lt;cartesianEventVariables.type.c_str()&lt;&lt;endl;</div>
<div class="line">      cout&lt;&lt;<span class="stringliteral">&quot;happened at:   &quot;</span>&lt;&lt;cartesianEventVariables.time&lt;&lt; <span class="stringliteral">&quot;[s] (source time)&quot;</span>&lt;&lt;endl;</div>
<div class="line">   }</div>
<div class="line">};</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 26 2024 16:02:19 for iCub-main by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
