<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iCub-main: iCub::iDyn::iDynSensorNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iCub-main
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceiCub.html">iCub</a></li><li class="navelem"><a class="el" href="namespaceiCub_1_1iDyn.html">iDyn</a></li><li class="navelem"><a class="el" href="classiCub_1_1iDyn_1_1iDynSensorNode.html">iDynSensorNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classiCub_1_1iDyn_1_1iDynSensorNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">iCub::iDyn::iDynSensorNode Class Reference<div class="ingroups"><a class="el" href="group__icub__modules__all.html">Software</a> &raquo; <a class="el" href="group__icub__libraries.html">Libraries</a> &raquo; <a class="el" href="group__iDyn.html">iDyn</a> &raquo; <a class="el" href="group__iDynBody.html">iDynBody</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between limbs, when one or multiple limbs have FT sensors.  
 <a href="classiCub_1_1iDyn_1_1iDynSensorNode.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for iCub::iDyn::iDynSensorNode:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classiCub_1_1iDyn_1_1iDynSensorNode__inherit__graph.png" border="0" usemap="#aiCub_1_1iDyn_1_1iDynSensorNode_inherit__map" alt="Inheritance graph"/></div>
<map name="aiCub_1_1iDyn_1_1iDynSensorNode_inherit__map" id="aiCub_1_1iDyn_1_1iDynSensorNode_inherit__map">
<area shape="rect" title="A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between l..." alt="" coords="113,80,318,107"/>
<area shape="rect" href="classiCub_1_1iDyn_1_1iDynSensorTorsoNode.html" title="A class for connecting a central&#45;up limb, a left and right limb of the iCub, and exchanging kinematic..." alt="" coords="96,155,335,181"/>
<area shape="rect" href="classiCub_1_1iDyn_1_1iDynNode.html" title="A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between l..." alt="" coords="135,5,296,32"/>
<area shape="rect" href="classiCub_1_1iDyn_1_1iCubLowerTorso.html" title="A class for connecting torso, left and right leg of the iCub, and exchanging kinematic and wrench inf..." alt="" coords="5,229,204,256"/>
<area shape="rect" href="classiCub_1_1iDyn_1_1iCubUpperTorso.html" title="A class for connecting head, left and right arm of the iCub, and exchanging kinematic and wrench info..." alt="" coords="228,229,427,256"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afbfeafcc6cbb5b7cb6cf78a9df472e4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynSensorNode.html#afbfeafcc6cbb5b7cb6cf78a9df472e4a">iDynSensorNode</a> (const <a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a> _mode=<a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3">DYNAMIC</a>)</td></tr>
<tr class="memdesc:afbfeafcc6cbb5b7cb6cf78a9df472e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classiCub_1_1iDyn_1_1iDynSensorNode.html#afbfeafcc6cbb5b7cb6cf78a9df472e4a">More...</a><br /></td></tr>
<tr class="separator:afbfeafcc6cbb5b7cb6cf78a9df472e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6b5ad83dcf8c789bdbb52ee046786e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynSensorNode.html#a0b6b5ad83dcf8c789bdbb52ee046786e">iDynSensorNode</a> (const std::string &amp;_info, const <a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a> _mode=<a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3">DYNAMIC</a>, unsigned int verb=<a class="el" href="namespaceiCub_1_1skinDynLib.html#a790824a527802db93c40eca73839b72da16220311c35a0345c00855ea2032c695">iCub::skinDynLib::VERBOSE</a>)</td></tr>
<tr class="memdesc:a0b6b5ad83dcf8c789bdbb52ee046786e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classiCub_1_1iDyn_1_1iDynSensorNode.html#a0b6b5ad83dcf8c789bdbb52ee046786e">More...</a><br /></td></tr>
<tr class="separator:a0b6b5ad83dcf8c789bdbb52ee046786e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca622b10b105fc894fd10bd01655d324"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynSensorNode.html#aca622b10b105fc894fd10bd01655d324">addLimb</a> (<a class="el" href="classiCub_1_1iDyn_1_1iDynLimb.html">iDyn::iDynLimb</a> *limb, const yarp::sig::Matrix &amp;<a class="el" href="compute__ekf__sym_8m.html#afaafc315b95987fc2b071bcd8f698b81">H</a>, const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a> kinFlow=<a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a2ade845ecc299911bc2906e1e2539064">RBT_NODE_OUT</a>, const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a> wreFlow=<a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a733307f2252a4e82441f412c04653a29">RBT_NODE_IN</a>)</td></tr>
<tr class="memdesc:aca622b10b105fc894fd10bd01655d324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add one limb to the node, defining its <a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html" title="A class for setting a rigid body transformation between iDynLimb and iDynNode.">RigidBodyTransformation</a>.  <a href="classiCub_1_1iDyn_1_1iDynSensorNode.html#aca622b10b105fc894fd10bd01655d324">More...</a><br /></td></tr>
<tr class="separator:aca622b10b105fc894fd10bd01655d324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ede78ee13e6ff86f2cdcf92ae205058"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynSensorNode.html#a0ede78ee13e6ff86f2cdcf92ae205058">addLimb</a> (<a class="el" href="classiCub_1_1iDyn_1_1iDynLimb.html">iDyn::iDynLimb</a> *limb, const yarp::sig::Matrix &amp;<a class="el" href="compute__ekf__sym_8m.html#afaafc315b95987fc2b071bcd8f698b81">H</a>, <a class="el" href="classiCub_1_1iDyn_1_1iDynSensor.html">iDyn::iDynSensor</a> *sensor, const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a> kinFlow=<a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a2ade845ecc299911bc2906e1e2539064">RBT_NODE_OUT</a>, const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a> wreFlow=<a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a733307f2252a4e82441f412c04653a29">RBT_NODE_IN</a>)</td></tr>
<tr class="memdesc:a0ede78ee13e6ff86f2cdcf92ae205058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add one limb to the node, defining its <a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html" title="A class for setting a rigid body transformation between iDynLimb and iDynNode.">RigidBodyTransformation</a> and the <a class="el" href="classiCub_1_1iDyn_1_1iDynSensor.html" title="A class for computing forces and torques in a iDynChain, when a force/torque sensor is placed in the ...">iDynSensor</a> used to solve it after FT sensor measurements.  <a href="classiCub_1_1iDyn_1_1iDynSensorNode.html#a0ede78ee13e6ff86f2cdcf92ae205058">More...</a><br /></td></tr>
<tr class="separator:a0ede78ee13e6ff86f2cdcf92ae205058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3f09586f4cba4d18446fabbeb7394d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynSensorNode.html#a6c3f09586f4cba4d18446fabbeb7394d">solveWrench</a> ()</td></tr>
<tr class="memdesc:a6c3f09586f4cba4d18446fabbeb7394d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function to manage the exchange of wrench information among the limbs attached to the node.  <a href="classiCub_1_1iDyn_1_1iDynSensorNode.html#a6c3f09586f4cba4d18446fabbeb7394d">More...</a><br /></td></tr>
<tr class="separator:a6c3f09586f4cba4d18446fabbeb7394d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0159e32468ded8899f5a96db0a08ca"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynSensorNode.html#a8c0159e32468ded8899f5a96db0a08ca">setWrenchMeasure</a> (const yarp::sig::Matrix &amp;<a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#afbae85fc951a816738e887545dec6d1b">F</a>, const yarp::sig::Matrix &amp;M, bool afterAttach=false)</td></tr>
<tr class="memdesc:a8c0159e32468ded8899f5a96db0a08ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Wrench measures on the limbs attached to the node.  <a href="classiCub_1_1iDyn_1_1iDynSensorNode.html#a8c0159e32468ded8899f5a96db0a08ca">More...</a><br /></td></tr>
<tr class="separator:a8c0159e32468ded8899f5a96db0a08ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e479a089cfe2b2709066b1d9b941212"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynSensorNode.html#a2e479a089cfe2b2709066b1d9b941212">setWrenchMeasure</a> (const yarp::sig::Matrix &amp;FM, bool afterAttach=false)</td></tr>
<tr class="memdesc:a2e479a089cfe2b2709066b1d9b941212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Wrench measures on the limbs attached to the node.  <a href="classiCub_1_1iDyn_1_1iDynSensorNode.html#a2e479a089cfe2b2709066b1d9b941212">More...</a><br /></td></tr>
<tr class="separator:a2e479a089cfe2b2709066b1d9b941212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d2a24e580e9fbd193017c0a327a121"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynSensorNode.html#a92d2a24e580e9fbd193017c0a327a121">estimateSensorsWrench</a> (const yarp::sig::Matrix &amp;FM, bool afterAttach=false)</td></tr>
<tr class="memdesc:a92d2a24e580e9fbd193017c0a327a121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exploit <a class="el" href="classiCub_1_1iDyn_1_1iDynInvSensor.html" title="A class for computing force/moment of a sensor placed anywhere in a kinematic chain; its position in ...">iDynInvSensor</a> methods to retrieve FT sensor measurements after solving wrenches in the limbs.  <a href="classiCub_1_1iDyn_1_1iDynSensorNode.html#a92d2a24e580e9fbd193017c0a327a121">More...</a><br /></td></tr>
<tr class="separator:a92d2a24e580e9fbd193017c0a327a121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classiCub_1_1iDyn_1_1iDynNode')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html">iCub::iDyn::iDynNode</a></td></tr>
<tr class="memitem:a9a53a62a5df3d14d368e99efcaa09551 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a9a53a62a5df3d14d368e99efcaa09551">iDynNode</a> (const <a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a> _mode=<a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3">DYNAMIC</a>)</td></tr>
<tr class="memdesc:a9a53a62a5df3d14d368e99efcaa09551 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a9a53a62a5df3d14d368e99efcaa09551">More...</a><br /></td></tr>
<tr class="separator:a9a53a62a5df3d14d368e99efcaa09551 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ead90a8cf09284157951a00025c6471 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a0ead90a8cf09284157951a00025c6471">iDynNode</a> (const std::string &amp;_info, const <a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a> _mode=<a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3">DYNAMIC</a>, unsigned int verb=<a class="el" href="namespaceiCub_1_1skinDynLib.html#a790824a527802db93c40eca73839b72da16220311c35a0345c00855ea2032c695">iCub::skinDynLib::VERBOSE</a>)</td></tr>
<tr class="memdesc:a0ead90a8cf09284157951a00025c6471 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with parameters.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a0ead90a8cf09284157951a00025c6471">More...</a><br /></td></tr>
<tr class="separator:a0ead90a8cf09284157951a00025c6471 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d930993d89391e724637e4cd4c123b inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#af1d930993d89391e724637e4cd4c123b">addLimb</a> (<a class="el" href="classiCub_1_1iDyn_1_1iDynLimb.html">iDyn::iDynLimb</a> *limb, const yarp::sig::Matrix &amp;<a class="el" href="compute__ekf__sym_8m.html#afaafc315b95987fc2b071bcd8f698b81">H</a>, const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a> kinFlow=<a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a2ade845ecc299911bc2906e1e2539064">RBT_NODE_OUT</a>, const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a> wreFlow=<a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a733307f2252a4e82441f412c04653a29">RBT_NODE_IN</a>, bool hasSensor=false)</td></tr>
<tr class="memdesc:af1d930993d89391e724637e4cd4c123b inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add one limb to the node, defining its <a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html" title="A class for setting a rigid body transformation between iDynLimb and iDynNode.">RigidBodyTransformation</a>.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#af1d930993d89391e724637e4cd4c123b">More...</a><br /></td></tr>
<tr class="separator:af1d930993d89391e724637e4cd4c123b inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea75d75c4a4af88cb908b58cc544fb0 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a5ea75d75c4a4af88cb908b58cc544fb0">getRBT</a> (unsigned int iLimb) const</td></tr>
<tr class="memdesc:a5ea75d75c4a4af88cb908b58cc544fb0 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the RBT matrix of a certain limb attached to the node.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a5ea75d75c4a4af88cb908b58cc544fb0">More...</a><br /></td></tr>
<tr class="separator:a5ea75d75c4a4af88cb908b58cc544fb0 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b3da23a78324dff920a4d90e9050bb inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a80b3da23a78324dff920a4d90e9050bb">solveKinematics</a> (const yarp::sig::Vector &amp;w0, const yarp::sig::Vector &amp;dw0, const yarp::sig::Vector &amp;ddp0)</td></tr>
<tr class="memdesc:a80b3da23a78324dff920a4d90e9050bb inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function to manage the exchange of kinematic information among the limbs attached to the node.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a80b3da23a78324dff920a4d90e9050bb">More...</a><br /></td></tr>
<tr class="separator:a80b3da23a78324dff920a4d90e9050bb inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55a020dd4b6cd51c3c586099a38c059 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#aa55a020dd4b6cd51c3c586099a38c059">solveKinematics</a> ()</td></tr>
<tr class="memdesc:aa55a020dd4b6cd51c3c586099a38c059 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function to manage the exchange of kinematic information among the limbs attached to the node.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#aa55a020dd4b6cd51c3c586099a38c059">More...</a><br /></td></tr>
<tr class="separator:aa55a020dd4b6cd51c3c586099a38c059 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62354060f29d440a9e9c36991bc868a inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#ac62354060f29d440a9e9c36991bc868a">setKinematicMeasure</a> (const yarp::sig::Vector &amp;w0, const yarp::sig::Vector &amp;dw0, const yarp::sig::Vector &amp;ddp0)</td></tr>
<tr class="memdesc:ac62354060f29d440a9e9c36991bc868a inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the kinematic measurement (w,dw,ddp) on the limb where the kinematic flow is of type RBT_NODE_IN.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#ac62354060f29d440a9e9c36991bc868a">More...</a><br /></td></tr>
<tr class="separator:ac62354060f29d440a9e9c36991bc868a inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cebfe81b63f533efd2f8d89300f0a7 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#af1cebfe81b63f533efd2f8d89300f0a7">solveWrench</a> (const yarp::sig::Matrix &amp;FM)</td></tr>
<tr class="memdesc:af1cebfe81b63f533efd2f8d89300f0a7 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is to manage the exchange of wrench information among the limbs attached to the node.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#af1cebfe81b63f533efd2f8d89300f0a7">More...</a><br /></td></tr>
<tr class="separator:af1cebfe81b63f533efd2f8d89300f0a7 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa277ea9054106efe80d77e4e9c120978 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#aa277ea9054106efe80d77e4e9c120978">solveWrench</a> (const yarp::sig::Matrix &amp;<a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#afbae85fc951a816738e887545dec6d1b">F</a>, const yarp::sig::Matrix &amp;M)</td></tr>
<tr class="memdesc:aa277ea9054106efe80d77e4e9c120978 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is to manage the exchange of wrench information among the limbs attached to the node.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#aa277ea9054106efe80d77e4e9c120978">More...</a><br /></td></tr>
<tr class="separator:aa277ea9054106efe80d77e4e9c120978 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baf9422767d3f38b7d63ce72c246565 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a7baf9422767d3f38b7d63ce72c246565">setWrenchMeasure</a> (const yarp::sig::Matrix &amp;<a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#afbae85fc951a816738e887545dec6d1b">F</a>, const yarp::sig::Matrix &amp;M)</td></tr>
<tr class="memdesc:a7baf9422767d3f38b7d63ce72c246565 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wrench measure on the limbs with input wrench.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a7baf9422767d3f38b7d63ce72c246565">More...</a><br /></td></tr>
<tr class="separator:a7baf9422767d3f38b7d63ce72c246565 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3bf2f7eaa01c9c1bea5444e52f7ee8 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a3c3bf2f7eaa01c9c1bea5444e52f7ee8">setWrenchMeasure</a> (const yarp::sig::Matrix &amp;FM)</td></tr>
<tr class="memdesc:a3c3bf2f7eaa01c9c1bea5444e52f7ee8 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wrench measure on the limbs with input wrench.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a3c3bf2f7eaa01c9c1bea5444e52f7ee8">More...</a><br /></td></tr>
<tr class="separator:a3c3bf2f7eaa01c9c1bea5444e52f7ee8 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49993bd267e6b663221d70ed0a3b3f37 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a49993bd267e6b663221d70ed0a3b3f37">getForce</a> () const</td></tr>
<tr class="memdesc:a49993bd267e6b663221d70ed0a3b3f37 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node force.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a49993bd267e6b663221d70ed0a3b3f37">More...</a><br /></td></tr>
<tr class="separator:a49993bd267e6b663221d70ed0a3b3f37 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d1306faec97f30675d668b620c6409 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a43d1306faec97f30675d668b620c6409">getMoment</a> () const</td></tr>
<tr class="memdesc:a43d1306faec97f30675d668b620c6409 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node moment.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a43d1306faec97f30675d668b620c6409">More...</a><br /></td></tr>
<tr class="separator:a43d1306faec97f30675d668b620c6409 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aaa82fdf13d57f059a9e2f12af4380 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a90aaa82fdf13d57f059a9e2f12af4380">getAngVel</a> () const</td></tr>
<tr class="memdesc:a90aaa82fdf13d57f059a9e2f12af4380 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node angular velocity.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a90aaa82fdf13d57f059a9e2f12af4380">More...</a><br /></td></tr>
<tr class="separator:a90aaa82fdf13d57f059a9e2f12af4380 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f004d511bde994e2a5ab5108f59cf5d inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a3f004d511bde994e2a5ab5108f59cf5d">getAngAcc</a> () const</td></tr>
<tr class="memdesc:a3f004d511bde994e2a5ab5108f59cf5d inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node angular acceleration.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a3f004d511bde994e2a5ab5108f59cf5d">More...</a><br /></td></tr>
<tr class="separator:a3f004d511bde994e2a5ab5108f59cf5d inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb96b671aed849b4b815a9552e2c059f inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#abb96b671aed849b4b815a9552e2c059f">getLinAcc</a> () const</td></tr>
<tr class="memdesc:abb96b671aed849b4b815a9552e2c059f inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node linear acceleration.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#abb96b671aed849b4b815a9552e2c059f">More...</a><br /></td></tr>
<tr class="separator:abb96b671aed849b4b815a9552e2c059f inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73ef1a6dbf022982665ec558bd84450 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#ac73ef1a6dbf022982665ec558bd84450">computeJacobian</a> (unsigned int iChain)</td></tr>
<tr class="memdesc:ac73ef1a6dbf022982665ec558bd84450 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Jacobian of the limb with index iChain in the node, in its default direction (as it would be done by <a class="el" href="namespaceiCub_1_1iKin.html">iKin</a>).  <a href="classiCub_1_1iDyn_1_1iDynNode.html#ac73ef1a6dbf022982665ec558bd84450">More...</a><br /></td></tr>
<tr class="separator:ac73ef1a6dbf022982665ec558bd84450 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3df54f3b7732d811b7d455254f54943 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#ab3df54f3b7732d811b7d455254f54943">computeJacobian</a> (unsigned int iChain, unsigned int iLink)</td></tr>
<tr class="memdesc:ab3df54f3b7732d811b7d455254f54943 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Jacobian of the i-th link of the limb with index iChain in the node, in its default direction (as it would be done by <a class="el" href="namespaceiCub_1_1iKin.html">iKin</a>).  <a href="classiCub_1_1iDyn_1_1iDynNode.html#ab3df54f3b7732d811b7d455254f54943">More...</a><br /></td></tr>
<tr class="separator:ab3df54f3b7732d811b7d455254f54943 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5010cc99800cced452459d674a21e665 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a5010cc99800cced452459d674a21e665">computeJacobian</a> (unsigned int iChainA, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirA, unsigned int iChainB, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirB)</td></tr>
<tr class="memdesc:a5010cc99800cced452459d674a21e665 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Jacobian between two links in two different chains.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a5010cc99800cced452459d674a21e665">More...</a><br /></td></tr>
<tr class="separator:a5010cc99800cced452459d674a21e665 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fd9aebc74f6bc4b9a57a593c36dfc9 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a48fd9aebc74f6bc4b9a57a593c36dfc9">computeJacobian</a> (unsigned int iChainA, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirA, unsigned int iChainB, unsigned int iLinkB, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirB)</td></tr>
<tr class="memdesc:a48fd9aebc74f6bc4b9a57a593c36dfc9 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Jacobian between two links in two different chains.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a48fd9aebc74f6bc4b9a57a593c36dfc9">More...</a><br /></td></tr>
<tr class="separator:a48fd9aebc74f6bc4b9a57a593c36dfc9 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb7948ffb0c9eafb1d9cd9741cc38ca inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a7eb7948ffb0c9eafb1d9cd9741cc38ca">computePose</a> (unsigned int iChainA, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirA, unsigned int iChainB, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirB, const bool axisRep)</td></tr>
<tr class="memdesc:a7eb7948ffb0c9eafb1d9cd9741cc38ca inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Pose of the end-effector, given a "virtual" chain connecting two limbs.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a7eb7948ffb0c9eafb1d9cd9741cc38ca">More...</a><br /></td></tr>
<tr class="separator:a7eb7948ffb0c9eafb1d9cd9741cc38ca inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded1c0769eebf83dbfbbea34d078f99e inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#aded1c0769eebf83dbfbbea34d078f99e">computePose</a> (unsigned int iChainA, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirA, unsigned int iChainB, unsigned int iLinkB, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirB, const bool axisRep)</td></tr>
<tr class="memdesc:aded1c0769eebf83dbfbbea34d078f99e inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Pose of the end-effector, given a "virtual" chain connecting two limbs.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#aded1c0769eebf83dbfbbea34d078f99e">More...</a><br /></td></tr>
<tr class="separator:aded1c0769eebf83dbfbbea34d078f99e inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa106c9340f7e2ffd57305868ac5c87a2 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#aa106c9340f7e2ffd57305868ac5c87a2">TESTING_computeCOMJacobian</a> (unsigned int iChain, unsigned int iLink)</td></tr>
<tr class="memdesc:aa106c9340f7e2ffd57305868ac5c87a2 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Jacobian of the COM of the i-th link of the limb with index iChain in the node.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#aa106c9340f7e2ffd57305868ac5c87a2">More...</a><br /></td></tr>
<tr class="separator:aa106c9340f7e2ffd57305868ac5c87a2 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93feed610e2fbfc9c1f254668a3ee6f9 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a93feed610e2fbfc9c1f254668a3ee6f9">TESTING_computeCOMJacobian</a> (unsigned int iChainA, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirA, unsigned int iChainB, unsigned int iLinkB, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirB)</td></tr>
<tr class="memdesc:a93feed610e2fbfc9c1f254668a3ee6f9 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Jacobian of the COM of link iLinkB, in chainB, when two different chains (A and B) are connected.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a93feed610e2fbfc9c1f254668a3ee6f9">More...</a><br /></td></tr>
<tr class="separator:a93feed610e2fbfc9c1f254668a3ee6f9 inherit pub_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a897edb0fcfc7166b39792d3afebe8f12"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynSensorNode.html#a897edb0fcfc7166b39792d3afebe8f12">howManySensors</a> () const</td></tr>
<tr class="separator:a897edb0fcfc7166b39792d3afebe8f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classiCub_1_1iDyn_1_1iDynNode')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html">iCub::iDyn::iDynNode</a></td></tr>
<tr class="memitem:aea991e45c7d4b8bda29189071dffc5d5 inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#aea991e45c7d4b8bda29189071dffc5d5">zero</a> ()</td></tr>
<tr class="memdesc:aea991e45c7d4b8bda29189071dffc5d5 inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all data to zero.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#aea991e45c7d4b8bda29189071dffc5d5">More...</a><br /></td></tr>
<tr class="separator:aea991e45c7d4b8bda29189071dffc5d5 inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693d676c499a4356d1696a24692d915c inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a693d676c499a4356d1696a24692d915c">compute_Pn_HAN</a> (unsigned int iChainA, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirA, unsigned int iChainB, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirB, yarp::sig::Matrix &amp;Pn, yarp::sig::Matrix &amp;H_A_Node)</td></tr>
<tr class="memdesc:a693d676c499a4356d1696a24692d915c inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Pn and H_A_Node matrices given two chains.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a693d676c499a4356d1696a24692d915c">More...</a><br /></td></tr>
<tr class="separator:a693d676c499a4356d1696a24692d915c inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1daa891c049fadbede769ad26a6cfa inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#ace1daa891c049fadbede769ad26a6cfa">compute_Pn_HAN</a> (unsigned int iChainA, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirA, unsigned int iChainB, unsigned int iLinkB, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirB, yarp::sig::Matrix &amp;Pn, yarp::sig::Matrix &amp;H_A_Node)</td></tr>
<tr class="memdesc:ace1daa891c049fadbede769ad26a6cfa inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Pn and H_A_Node matrices given two chains.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#ace1daa891c049fadbede769ad26a6cfa">More...</a><br /></td></tr>
<tr class="separator:ace1daa891c049fadbede769ad26a6cfa inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc620c5393e599eed31dba2335b34192 inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#adc620c5393e599eed31dba2335b34192">compute_Pn_HAN_COM</a> (unsigned int iChainA, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirA, unsigned int iChainB, unsigned int iLinkB, <a class="el" href="namespaceiCub_1_1iDyn.html#af499ebb28864858a6ef02f9cbce82b23">JacobType</a> dirB, yarp::sig::Matrix &amp;Pn, yarp::sig::Matrix &amp;H_A_Node)</td></tr>
<tr class="memdesc:adc620c5393e599eed31dba2335b34192 inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Pn and H_A_Node matrices given two chains.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#adc620c5393e599eed31dba2335b34192">More...</a><br /></td></tr>
<tr class="separator:adc620c5393e599eed31dba2335b34192 inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6609ff72c5f8fdbb48d232a6a4d84d65 inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a6609ff72c5f8fdbb48d232a6a4d84d65">howManyWrenchInputs</a> (bool afterAttach=false) const</td></tr>
<tr class="memdesc:a6609ff72c5f8fdbb48d232a6a4d84d65 inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of limbs with wrench input, i.e.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a6609ff72c5f8fdbb48d232a6a4d84d65">More...</a><br /></td></tr>
<tr class="separator:a6609ff72c5f8fdbb48d232a6a4d84d65 inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3feea80c9d503b766d37afe108be6ce2 inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a3feea80c9d503b766d37afe108be6ce2">howManyKinematicInputs</a> (bool afterAttach=false) const</td></tr>
<tr class="memdesc:a3feea80c9d503b766d37afe108be6ce2 inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of limbs with kinematic input, i.e.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a3feea80c9d503b766d37afe108be6ce2">More...</a><br /></td></tr>
<tr class="separator:a3feea80c9d503b766d37afe108be6ce2 inherit pro_methods_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae4c47fb7f73b890d3b85f1e4498e8cc2"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="classiCub_1_1iDyn_1_1iDynSensor.html">iDyn::iDynSensor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynSensorNode.html#ae4c47fb7f73b890d3b85f1e4498e8cc2">sensorList</a></td></tr>
<tr class="memdesc:ae4c47fb7f73b890d3b85f1e4498e8cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">the list of iDynSensors used to solve each limb after FT sensor measurements  <a href="classiCub_1_1iDyn_1_1iDynSensorNode.html#ae4c47fb7f73b890d3b85f1e4498e8cc2">More...</a><br /></td></tr>
<tr class="separator:ae4c47fb7f73b890d3b85f1e4498e8cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classiCub_1_1iDyn_1_1iDynNode')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html">iCub::iDyn::iDynNode</a></td></tr>
<tr class="memitem:aa2348a39cc0576e4de7624580a6997b9 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html">RigidBodyTransformation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#aa2348a39cc0576e4de7624580a6997b9">rbtList</a></td></tr>
<tr class="memdesc:aa2348a39cc0576e4de7624580a6997b9 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">the list of RBT  <a href="classiCub_1_1iDyn_1_1iDynNode.html#aa2348a39cc0576e4de7624580a6997b9">More...</a><br /></td></tr>
<tr class="separator:aa2348a39cc0576e4de7624580a6997b9 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4212761245758347118b0b685b83bf inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a6a4212761245758347118b0b685b83bf">mode</a></td></tr>
<tr class="memdesc:a6a4212761245758347118b0b685b83bf inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">STATIC/DYNAMIC/DYNAMIC_W_ROTOR/DYNAMIC_CORIOLIS_GRAVITY.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a6a4212761245758347118b0b685b83bf">More...</a><br /></td></tr>
<tr class="separator:a6a4212761245758347118b0b685b83bf inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c71d184a9385364ca17ac8acb134f99 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a9c71d184a9385364ca17ac8acb134f99">info</a></td></tr>
<tr class="memdesc:a9c71d184a9385364ca17ac8acb134f99 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">info or useful notes  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a9c71d184a9385364ca17ac8acb134f99">More...</a><br /></td></tr>
<tr class="separator:a9c71d184a9385364ca17ac8acb134f99 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fca92c14ebe1efb92463eb77ed67352 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a5fca92c14ebe1efb92463eb77ed67352">verbose</a></td></tr>
<tr class="memdesc:a5fca92c14ebe1efb92463eb77ed67352 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">verbosity flag  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a5fca92c14ebe1efb92463eb77ed67352">More...</a><br /></td></tr>
<tr class="separator:a5fca92c14ebe1efb92463eb77ed67352 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a74e80b0abb7063546f8b261bf359f inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a74a74e80b0abb7063546f8b261bf359f">w</a></td></tr>
<tr class="memdesc:a74a74e80b0abb7063546f8b261bf359f inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">angular velocity  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a74a74e80b0abb7063546f8b261bf359f">More...</a><br /></td></tr>
<tr class="separator:a74a74e80b0abb7063546f8b261bf359f inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03a7e6af6ef82ff22fe36456329d2c8 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#ad03a7e6af6ef82ff22fe36456329d2c8">dw</a></td></tr>
<tr class="memdesc:ad03a7e6af6ef82ff22fe36456329d2c8 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">angular acceleration  <a href="classiCub_1_1iDyn_1_1iDynNode.html#ad03a7e6af6ef82ff22fe36456329d2c8">More...</a><br /></td></tr>
<tr class="separator:ad03a7e6af6ef82ff22fe36456329d2c8 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c97b6d7b00ae9252f0c8b336a60e30c inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a0c97b6d7b00ae9252f0c8b336a60e30c">ddp</a></td></tr>
<tr class="memdesc:a0c97b6d7b00ae9252f0c8b336a60e30c inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear acceleration  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a0c97b6d7b00ae9252f0c8b336a60e30c">More...</a><br /></td></tr>
<tr class="separator:a0c97b6d7b00ae9252f0c8b336a60e30c inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbae85fc951a816738e887545dec6d1b inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#afbae85fc951a816738e887545dec6d1b">F</a></td></tr>
<tr class="memdesc:afbae85fc951a816738e887545dec6d1b inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">force  <a href="classiCub_1_1iDyn_1_1iDynNode.html#afbae85fc951a816738e887545dec6d1b">More...</a><br /></td></tr>
<tr class="separator:afbae85fc951a816738e887545dec6d1b inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d77ab92e63190024ee4b8c8e116637 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#a80d77ab92e63190024ee4b8c8e116637">Mu</a></td></tr>
<tr class="memdesc:a80d77ab92e63190024ee4b8c8e116637 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">moment  <a href="classiCub_1_1iDyn_1_1iDynNode.html#a80d77ab92e63190024ee4b8c8e116637">More...</a><br /></td></tr>
<tr class="separator:a80d77ab92e63190024ee4b8c8e116637 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ec3966a72191b31f266809403bfd06 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">yarp::sig::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#af1ec3966a72191b31f266809403bfd06">COM</a></td></tr>
<tr class="memdesc:af1ec3966a72191b31f266809403bfd06 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">COM position of the node.  <a href="classiCub_1_1iDyn_1_1iDynNode.html#af1ec3966a72191b31f266809403bfd06">More...</a><br /></td></tr>
<tr class="separator:af1ec3966a72191b31f266809403bfd06 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5db3235dc804286712724c035345412 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#ad5db3235dc804286712724c035345412">mass</a></td></tr>
<tr class="memdesc:ad5db3235dc804286712724c035345412 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="mdescLeft">&#160;</td><td class="mdescRight">total mass of the node  <a href="classiCub_1_1iDyn_1_1iDynNode.html#ad5db3235dc804286712724c035345412">More...</a><br /></td></tr>
<tr class="separator:ad5db3235dc804286712724c035345412 inherit pro_attribs_classiCub_1_1iDyn_1_1iDynNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for connecting two or mutiple limbs and exchanging kinematic and wrench information between limbs, when one or multiple limbs have FT sensors. </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00916">916</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afbfeafcc6cbb5b7cb6cf78a9df472e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfeafcc6cbb5b7cb6cf78a9df472e4a">&#9670;&nbsp;</a></span>iDynSensorNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iDynSensorNode::iDynSensorNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a>&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3">DYNAMIC</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_mode</td><td>the computation mode for kinematic/wrench using Newton-Euler's formula </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l01327">1327</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a0b6b5ad83dcf8c789bdbb52ee046786e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6b5ad83dcf8c789bdbb52ee046786e">&#9670;&nbsp;</a></span>iDynSensorNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iDynSensorNode::iDynSensorNode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362">NewEulMode</a>&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="namespaceiCub_1_1iDyn.html#a6b03dffbe5b7a4931b1d7afeff96b362ac034feb4663b0e2591e629606ef5e2f3">DYNAMIC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>verb</em> = <code><a class="el" href="namespaceiCub_1_1skinDynLib.html#a790824a527802db93c40eca73839b72da16220311c35a0345c00855ea2032c695">iCub::skinDynLib::VERBOSE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_info</td><td>some information, ie the node name </td></tr>
    <tr><td class="paramname">_mode</td><td>the computation mode for kinematic/wrench using Newton-Euler's formula </td></tr>
    <tr><td class="paramname">verb</td><td>verbosity flag </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l01333">1333</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aca622b10b105fc894fd10bd01655d324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca622b10b105fc894fd10bd01655d324">&#9670;&nbsp;</a></span>addLimb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void iCub::iDyn::iDynSensorNode::addLimb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiCub_1_1iDyn_1_1iDynLimb.html">iDyn::iDynLimb</a> *&#160;</td>
          <td class="paramname"><em>limb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a>&#160;</td>
          <td class="paramname"><em>kinFlow</em> = <code><a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a2ade845ecc299911bc2906e1e2539064">RBT_NODE_OUT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a>&#160;</td>
          <td class="paramname"><em>wreFlow</em> = <code><a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a733307f2252a4e82441f412c04653a29">RBT_NODE_IN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add one limb to the node, defining its <a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html" title="A class for setting a rigid body transformation between iDynLimb and iDynNode.">RigidBodyTransformation</a>. </p>
<p>A new <a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html" title="A class for setting a rigid body transformation between iDynLimb and iDynNode.">RigidBodyTransformation</a> is added to the RBT list. Since there's not an <a class="el" href="classiCub_1_1iDyn_1_1iDynSensor.html" title="A class for computing forces and torques in a iDynChain, when a force/torque sensor is placed in the ...">iDynSensor</a> for this limb, it is set to NULL in the sensorList. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limb</td><td>pointer to generic limb </td></tr>
    <tr><td class="paramname">H</td><td>a (4x4) roto-translational matrix defining the transformation between node and limb base/end </td></tr>
    <tr><td class="paramname">kinFlow</td><td>the type of information flow of kinematics variables </td></tr>
    <tr><td class="paramname">wreFlow</td><td>the type of information flow of wrench variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ede78ee13e6ff86f2cdcf92ae205058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ede78ee13e6ff86f2cdcf92ae205058">&#9670;&nbsp;</a></span>addLimb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iCub::iDyn::iDynSensorNode::addLimb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiCub_1_1iDyn_1_1iDynLimb.html">iDyn::iDynLimb</a> *&#160;</td>
          <td class="paramname"><em>limb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiCub_1_1iDyn_1_1iDynSensor.html">iDyn::iDynSensor</a> *&#160;</td>
          <td class="paramname"><em>sensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a>&#160;</td>
          <td class="paramname"><em>kinFlow</em> = <code><a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a2ade845ecc299911bc2906e1e2539064">RBT_NODE_OUT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1">FlowType</a>&#160;</td>
          <td class="paramname"><em>wreFlow</em> = <code><a class="el" href="namespaceiCub_1_1iDyn.html#a2242db13fd8695c6b4e5c086809f45f1a733307f2252a4e82441f412c04653a29">RBT_NODE_IN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add one limb to the node, defining its <a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html" title="A class for setting a rigid body transformation between iDynLimb and iDynNode.">RigidBodyTransformation</a> and the <a class="el" href="classiCub_1_1iDyn_1_1iDynSensor.html" title="A class for computing forces and torques in a iDynChain, when a force/torque sensor is placed in the ...">iDynSensor</a> used to solve it after FT sensor measurements. </p>
<p>A new <a class="el" href="classiCub_1_1iDyn_1_1RigidBodyTransformation.html" title="A class for setting a rigid body transformation between iDynLimb and iDynNode.">RigidBodyTransformation</a> is added to the RBT list. The <a class="el" href="classiCub_1_1iDyn_1_1iDynSensor.html" title="A class for computing forces and torques in a iDynChain, when a force/torque sensor is placed in the ...">iDynSensor</a> is added to the sensorList. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limb</td><td>pointer to generic limb </td></tr>
    <tr><td class="paramname">H</td><td>a (4x4) roto-translational matrix defining the transformation between node and limb base/end </td></tr>
    <tr><td class="paramname">sensor</td><td>pointer to <a class="el" href="classiCub_1_1iDyn_1_1iDynSensor.html" title="A class for computing forces and torques in a iDynChain, when a force/torque sensor is placed in the ...">iDynSensor</a> of the limb </td></tr>
    <tr><td class="paramname">kinFlow</td><td>the type of information flow of kinematics variables </td></tr>
    <tr><td class="paramname">wreFlow</td><td>the type of information flow of wrench variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92d2a24e580e9fbd193017c0a327a121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d2a24e580e9fbd193017c0a327a121">&#9670;&nbsp;</a></span>estimateSensorsWrench()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix iDynSensorNode::estimateSensorsWrench </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>FM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>afterAttach</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exploit <a class="el" href="classiCub_1_1iDyn_1_1iDynInvSensor.html" title="A class for computing force/moment of a sensor placed anywhere in a kinematic chain; its position in ...">iDynInvSensor</a> methods to retrieve FT sensor measurements after solving wrenches in the limbs. </p>
<p>The parameter FM is a (6xN), where each column is an external wrench to be used for initializing the wrench phase; N is the number of limbs Nlimbs attached to the node. The boolean flag is used in case the external wrench on the first limb has already been set; this is useful whenever two different nodes are connected and share information: the first node sends kinematic and wrench information to the 'first' limb of the second node (eg the torso). In that case the FM matrix should only contain external wrench for the other limbs, so it should be a (6x(Nlimbs-1)). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FM</td><td>a (6xN) matrix with the external wrenches,where N is the number of limbs if afterAttach=false, number of limbs -1 if afterAttach=true </td></tr>
    <tr><td class="paramname">afterAttach</td><td>a flag for specifying if the external wrench of the first limb has been already set or not </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l01562">1562</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a897edb0fcfc7166b39792d3afebe8f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897edb0fcfc7166b39792d3afebe8f12">&#9670;&nbsp;</a></span>howManySensors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int iDynSensorNode::howManySensors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of limbs with sensor </dd></dl>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l01707">1707</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<a id="a8c0159e32468ded8899f5a96db0a08ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0159e32468ded8899f5a96db0a08ca">&#9670;&nbsp;</a></span>setWrenchMeasure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool iCub::iDyn::iDynSensorNode::setWrenchMeasure </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>afterAttach</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the Wrench measures on the limbs attached to the node. </p>
<p>The parameters F and M are (3xN) matrices, where each column is an external wrench to be used for initializing the wrench phase; N is the number of limbs Nlimbs attached to the node. The boolean flag is used in case the external wrench on the first limb has already been set; this is useful whenever two different nodes are connected and share information: the first node sends kinematic and wrench information to the 'first' limb of the second node (eg the torso). In that case the F and M matrices should only contain external wrench for the other limbs, so it should be a (6x(Nlimbs-1)). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>a (3xN) matrix with forces, where N is the number of limbs if afterAttach=false, number of limbs -1 if afterAttach=true </td></tr>
    <tr><td class="paramname">M</td><td>a (3xN) matrix with moments , where N is the number of limbs if afterAttach=false, number of limbs -1 if afterAttach=true </td></tr>
    <tr><td class="paramname">afterAttach</td><td>a flag for specifying if the external wrench of the first limb has been already set or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeds, false otherwise </dd></dl>

</div>
</div>
<a id="a2e479a089cfe2b2709066b1d9b941212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e479a089cfe2b2709066b1d9b941212">&#9670;&nbsp;</a></span>setWrenchMeasure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool iCub::iDyn::iDynSensorNode::setWrenchMeasure </td>
          <td>(</td>
          <td class="paramtype">const yarp::sig::Matrix &amp;&#160;</td>
          <td class="paramname"><em>FM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>afterAttach</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the Wrench measures on the limbs attached to the node. </p>
<p>The parameter FM is a (6xN), where each column is an external wrench to be used for initializing the wrench phase; N is the number of limbs Nlimbs attached to the node. The boolean flag is used in case the external wrench on the first limb has already been set; this is useful whenever two different nodes are connected and share information: the first node sends kinematic and wrench information to the 'first' limb of the second node (eg the torso). In that case the FM matrix should only contain external wrench for the other limbs, so it should be a (6x(Nlimbs-1)). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FM</td><td>a (6xN) matrix with the external wrenches, where N is the number of limbs if afterAttach=false, number of limbs -1 if afterAttach=true </td></tr>
    <tr><td class="paramname">afterAttach</td><td>a flag for specifying if the external wrench of the first limb has been already set or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if succeeds, false otherwise </dd></dl>

</div>
</div>
<a id="a6c3f09586f4cba4d18446fabbeb7394d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3f09586f4cba4d18446fabbeb7394d">&#9670;&nbsp;</a></span>solveWrench()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynSensorNode::solveWrench </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Main function to manage the exchange of wrench information among the limbs attached to the node. </p>
<p>Multiple limbs with wrench flow of input type can exist, but at least one limb with output type must exist, to compute the wrench balance on the node. The measured/input wrenches to the limbs are here assumed to be set elsewhere: eg another class or the main is setting the measured wrenches. Note: RBT calls computeWrenchNewtonEuler in the limb, meaning that performs a "basic" wrench computation without any sensor, just setting wrenches at the end-effector or at the base, and calling recursive wrench computation. </p><dl class="section return"><dt>Returns</dt><dd>true if succeeds, false otherwise </dd></dl>

<p>Reimplemented from <a class="el" href="classiCub_1_1iDyn_1_1iDynNode.html#ad166af36d544d12a2aa6c3780fb06686">iCub::iDyn::iDynNode</a>.</p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8cpp_source.html#l01352">1352</a> of file <a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae4c47fb7f73b890d3b85f1e4498e8cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c47fb7f73b890d3b85f1e4498e8cc2">&#9670;&nbsp;</a></span>sensorList</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;<a class="el" href="classiCub_1_1iDyn_1_1iDynSensor.html">iDyn::iDynSensor</a> *&gt; iCub::iDyn::iDynSensorNode::sensorList</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the list of iDynSensors used to solve each limb after FT sensor measurements </p>

<p class="definition">Definition at line <a class="el" href="iDynBody_8h_source.html#l00922">922</a> of file <a class="el" href="iDynBody_8h_source.html">iDynBody.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>icub-main/src/libraries/iDyn/include/iCub/iDyn/<a class="el" href="iDynBody_8h_source.html">iDynBody.h</a></li>
<li>icub-main/src/libraries/iDyn/src/<a class="el" href="iDynBody_8cpp_source.html">iDynBody.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 26 2024 16:02:21 for iCub-main by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
